/*----------------------------------------------------------------------------------------------------------------------
	Java ile Nesne Yönelimli Programlama

	Eğitmen: Oğuz KARAN

	C ve Sistem Programcıları Derneği
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	05.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java, hem programlama diline hem de ortamına (platform) verilen bir isimdir. Genel olarak kursumuzda Java dendiğinde
	programlama dili anlaşılacaktır. Ayrıca Java ortamı için JavaSE'de kullanılacaktır. Aslında JavaSE de genel bir
	terimdir.

	Java Ortamının Temel Özellikler:
	- Arakodlu çalışma sistemi: C ve C++ gibi dillerde yazılan programdan üretilen dosya (executable file)
	sistem düzeyinde (donanım, isletim sistemi vs.) çalışabilir. Örneğin, Windows işletim sistemi için üretilmiş
	bir program, Mac OS işletim sisteminde doğrudan çalıştırılamaz. O sistem için çalışabilir dosyanın ayrıca üretilmesi
	gerekir. Java'da yazılan programdan üretilen kod geneldir ve herhangi bir sisteme özgü değildir. Kendine ait
	standart formatı vardır. Bu şekilde üretilen dosyalara genel olarak "ara kod (intermediate code)" denir. Java özelinde
	bu arakoda "byte code" denir. Bu durumda byte code'u işletim sistemi çalıştıramaz. İşte bu durumda bu kodu çalıştıran
	işletim sistemine özgü ayrı bir program kullanılır. Bu programa genel olarak "Java Virtual Machine (JVM)" denir. Aslında
	sistem düzeyinde çalışan program budur. JVM arakodu yorumlayarak makine koduna (machine code) dönüştürür. Bu işleme
	"Just In Time Compilation (JIT)" denir. Böylesi bir tasarımın en büyük avantajı programın taşınabilirliğidir. Yani
	Java programcısı, programını bir kez yazar ve bir kez byte code'unu üretir ve bu byte her sistemde çalıştırılabilir.
	Şüphesiz bu durumun da istisnaları vardır. Ancak unutulmamalıdır ki, arakodlu çalışma sistemi görece yavaştır. Ancak
	bu yavaşlık Java'nın hedeflediği uygulamalar açısından önemsizdir. Geliştirme ve çalıştırma anlamında şu temel kavramlar
	önemlidir:
		- JVM (Java Virtual Machine): Byte code'u yorumlayarak aşağı seviyeli makine koduna dönüştürür. Aslında JVM
		byte code'un nasıl yorumlayanacağına yönelik soyut bir kavramdır.

		- JRE (Java Runtime Environment): genel olarak Java ile yazılmış bir uygulamayı çalıştırmak için gereken araçları ve
		uygulamaları içeren bir pakettir. Yani Java ile yazılmış bir programın çalıştırılabilmesi için JRE gereklidir.

		- JDK (Java Development Kit): Geliştirme (development) için kullanılan araçları barındıran bir pakettir. JDK içerisinde
		geliştirme yaparken kullanılmak üzere çalıştırma araçları da bulunur.

		Ticari kullanımlarda Java 11 ile birlikte bir takım değişiklikler yapılmıştır. Şu şekilde özetlenebilir: Genel olarak geliştirme ortamı
		ücretsizdir, çalıştırma ortamı ücretli olabilir ancak ücretsiz olanları da vardır. Bu konuların detayları vardır. Bu
		bölümde ele alınmayacaktır. Örneğin Oracle firmasının JRE'si ücretlidir ancak Open JRE denilen tamamen ücretsiz bir
		ortam da mevcuttur.

		Arakodlu çalışma sisteminin yukarıda anlatılan avantajına "Write Once Run Anywhere (WORA)" da denilmektedir.

	- Hızlı uygulama geliştirme ortamı: Java hızlı uygulama geliştirme (rapid application development) ortamı sunar. Bu anlamda
	ürün elde edilmesi daha çabuk olabilmektedir ve aynı zamanda öğrenmesi de görece kolay olabilmektedir.

	- Geniş bir sınıf kütüphanesi: Java'da (JavaSE'de) geniş bir sınıf kütüphanesi vardır. Veritabanı işlemleri, web programlama
	vb. için gereken bir çok sınıf hazır olarak bulunmaktadır.

	- Güvenli çalışma ortamı: Java'da yazılan programların, programcının yaptığı hatalardan dolayı sisteme zarar verme olasıkları
	çok çok azdır. Bu da güvenli bir çalışma ortamı sunmasına yol açar.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	06.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programlama Dillerinin Sınıflandırılması: Programlama dilleri çeşitli şekillerde sınıflandırılabilse de genel olarak
	3 şekilde sınıflandırma eğilimi söz konusudur:
	1. Seviyelerine (level) göre sınıflandırma: Programlama dilinin seviyesi onun insan algısına yakınlığının ölçüsüdür. Yüksek
	seviyeli diller (high level languages) hem dil özellikleri, hem de uygulama geliştirme anlamında insan algısına yakınlıkları
	dolayısıyla daha kolay öğrenebilirler. Düşük seviyeli diller (low level languages) makineye daha yakın dillerdir. Olabilecek
	en düşük seviyeli dil makine dilidir.

	2. Kullanım alanlarına göre sınıflandırma: Dilin hangi alanlarda kullanılabileceğine göre sınıflandırmadır. Bazı diller
	birden fazla alanda kullanılabilirler. Bazı diller ise sadece bir alanda kullanılabilirler. Bu anlamda genel amaçlı diller,
	bilimsel ve mühendislik dilleri, veritabanı dilleri, yapay zeka dilleri, oyun ve animasyon dilleri vb. alanlar için diller
	söz konusu olabilmektedir.

	3. Programlama modeline göre sınıflandırma: Bir programı yazarken kullanılan genel model (paradigm) önemlidir. Bazı dillerde
	sınıf yoktur. Program çeşitli alt programların (function) bir araya getirilmesiyle yazılır. Bu modele "procedurel model"
	denir. Bazı dillerde sınıflar vardır ve programlar sınıflar kullanılarak yazılır. Başka bir çok kavramla birlikte sınıflar
	kullanılarak yazılan programlama modeline "nesne yönelimli model (object oriented model)" denir. Bazı dillerde programlar
	matematiksel formül yazıyormuş gibi yazılmaktadır. Bu tarz programlama modeline "fonksiyonel (functional)" model denir.
	Bazı diller birden fazla modeli desteklerler. Bu tarz dillere "multi paradigm languages" denilmektedir. Birden fazla modeli
	destekleyen diller, modellerin tüm özelliklerini desteklemeyebilir.

	Bu durumda Java, bilimsel ve mühendislik uygulamalarında, web uygulamalarında, yapay zeka uygulamalarında, mobil
	programlamada vb. kullanılabilen genel amaçlı, yüksek seviyeli, nesne yönelimli programlama modeli ile uygulama
	geliştirilebilen ve özellikle Java 8 ile birlike fonksiyonel programlama modelini de belirli ölçüde destekleyen
	"multi paradigm" bir dildir.

	Anahtar Notlar: Bir dilin bir çok alanda kullanılabilmesi, o dilin tüm alanlarında pratikte kullanılacağı anlamına gelmez.
	Bir alanda daha etkin kullanılabilen bir dil varsa o dil daha fazla tercih edilebilir.

	Anahtar Notlar: Yukarıda anlatılan kavramların detayları vardır. Zaman içerisinde anlaşılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Temel Kavramlar:
	Çevirici Programlar, Derleyiciler ve Yorumlayıcılar: Bir dilde yazılmış programı başka bir dile çeviren programlara
	çevirici programlar (translator) denir. Çevirici programlarda bir kaynak dil (source language) ve bir hedef dil (target/destination language)
	vardır. Kaynak dil yüksek seviyeli, hedef dil düşük seviyeli bir programlama diliyse bu durumda çevirici programa
	derleyici (compiler) denir. Örneğin Java programlama dilinden Kotlin programlama diline dönüştürme yapan program
	bir translator, Java programlama dilinden byte code'a dönüştürme yapan program ise bir compiler'dır. JVM'in byte code'u
	makine kodu makine koduna çevirme faaliyeti de bir derleme işlemidir. Bu sebeple buna JIT compilation denir. Bazı
	dillerde yazılan programlar herhangi bir kod üretilmeden çalıştırılırlar. Bu tarz dillerde yazılmış programları
	herhangi bir kod üretmeden çalıştıran programlara "interpreter" denir. Bazı diller hem derleyici hem yorumlayıcı ile
	kullanılabilirler. Java pratikte derleyici ile kullanılan Java 11 ile birlikte "java" programı yorumlayıcı olarak da
	java kodunu byte code üretilmeden çalıştırabilmektedir. Yorumlayıcı ile kullanılan diller derleyici ile kullanılan dillere
	göre daha yavaş olma eğilimindedir.

	Anahtar Notlar: Bir uygulama tek bir java dosyasından oluşmak zorunda değildir. Hatta bir Java uygulaması yalnızca
	java kodlarından da oluşmak zorunda değildir. Bu durumda farklı java dosyaları ayrı derlenir. Hatta aynı dosyada
	bulunan sınıflar da ayrı derlenir. Bir ürün aslında tüm birimlerinin uygun şekilde derlenmesi ve ele alınmasıyla
	elde edilir. Bu işleme genel olarak "build" terimi kullanılır. Build işlemi yalnızca derleme işlemi değildir. Yani
	bir uygulamanın ürün olarak elde edilmesi süreci "build" işlemidir. Burada anlatılanların da detayları zamanla
	ele alınacaktır.

	İşletim Sistemi (Operating System): Makinenin donanımını yöneten, bilgisayar ile kullanıcı arasında bir köprü oluşturan
	yazılımdır. Br işletim sisteminin pek çok görevi vardır. Programları çalıştırmak, çeşitli cihazları ve aygıtları yönetmek,
	dosyaları ve dizinleri (directory) organize etmek vb. görevler sayılabilir. İşletim sistemleri genel olarak iki gruba
	ayrılabilir: masaüstü işletim sistemleri (desktop operating systems), mobil işletim sistemleri (mobile operating systems).
	Şüphesiz başka çeşit işletim sistemleri de vardır. Popüler masaüstü işletim sistemleri Windows, Mac OS X, Unix ve Linux
	gibi işlemleridir. Popüler mobil işletim sistemleri Android ve IOS'dur.

	Açık kaynak kodlu yazılım, özgür yazılım ve mülkiyete sahip yazılım: Özgür yazılım (free software) ve açık kaynak kodlu
	(open source) yazılımlar arasında farklar olsa genel olarak aşağıdaki ortak özelliklere sahiptirler:
		- Bedavadır. Kullanılabilmesi için herhangi bir lisans gerekmez.
		- Kaynak kodlar sahiplenilemez. Kaynak koda ekleme yapıldığında ya da bir kaynak kod kullanıldığında kodlar kapatılamaz.
		Onların da açılması gerekir.
		- Çoğaltılabilir, izin almadan kullanılabilir.

	Bunun tam tersi olarak mülkiyete sahip (propriatery) yazlımlardır. Bu yazılımlar para verilerek kullanılır ve izin
	almadan çoğaltılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	IDE (Integrated Development Environment): Derleyicler ve yorumlayıcılar komut satırından çalışan ve basit arayüzlere
	sahip programlardır. Aslında teorik olarak bir uygulamadaki tüm Java dosyaları ve diğer dosyalar basit bir editör programla
	yazılıp komut satırından derlenebilir. Ancak bu uygulama büyüdükçe zahmetli olmaya başlar. Bu da programcıya zaman
	kaybettirir. Bu amaçla pratikte yazılm geliştirmeyi kolaylaştırmak için IDE denilen yazılımlar kullanılır. IDE'lerde
	örneğin bir takım yardımlar veren editörler, tasarım araçları, test araçları, debug araçları vb. programcının geliştirme
	sırasında kullandığı araçlar bulunur. Java ile uygulama geliştirmede iki tane IDE yoğun olarak kullanılmaktadır:
	Eclipse, IntelliJIDEA. Biz kursumuzda belirli bir zaman (yaklaşık kursun yarısına kadar) Eclipse, sonrasında IntelliJIDEA
	kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	12.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	JDK'nın kurulumu için işletim sistemine göre aşağıdaki şu link'den ilgili "installer" indirilebilir: 
	https://www.oracle.com/tr/java/technologies/downloads/. Burada LTS olması açısından 17 seçilebilir. Ya da en son
	versiyon seçilebilir. Dersin tarihinde en son versiyon JDK 20 'dir. Kursumuzda Java 17 özellikleri de konular
	içerisinde ele alınacağından en az Java 17 kurulumu önerilir. Java 17 öncesinde en az Java 11 olmalıdır. Kurulum
	aşamasından sonra java ve javac programları -version seçeneği ile çalıştırılarak versiyon kontrolü yapılabilir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki programı çalıştırmak için JDK kurulu olan bir bilgisayarda aşağıdaki işlemlerin yapılması gerekir:
	1. Herhangi bir dizinde (directory/folder) csd isimli bir dizin açılır. Buradaki csd isminin tamamı küçük harf olacak
	şekilde yapılmalıdır.

	2. csd dizini içerisinde App.java isimli bir dosya açılır. Windows sisteminde uzantılar gizlenmişse görünür hale getirilip
	uzantının .java olduğuna dikkat ediniz. Buradaki dosya isminin de büyük küçük harf duyarlı olarak yazılması gerekir

	3. Komut yorumlayıcı program (command prompt or terminal) ile ilgili dizine geçilir. Dizin geçişleri için tüm sistemlerde
	aynı olan cd (change directory) komutu kullanılabilir. Örneğin: cd Dropbox/CSD/Kurslar/Java-Aug-2023/src/src-console

	4. Harhangi bir editör program ile App.java dosyasında aşağıdaki programı yazınız

	5. Komut yorumlayıcı programda, csd'nin bulunduğu dizinde aşağıdaki komutları çalıştırarak derleme işlemi yapılır:
		javac csd/App.java -> Windows dışı sistemler için
		javac csd\App.java -> Windows sistemi için
	Derleme işleminde herhangi bir hata (error) mesajı alınmazsa derleme işlemi başarılıdır ve App.class isminde byte code
	üretilir

	6. Komut yorumlayıcı programda aşağıdaki biçimde byte code çalıştırılır:
		java csd.App

	Anahtar Notlar: Yukarıdaki maddelerdeki bazı zorunluluklar ilerideki konularda anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dil Kavramı: İletişimde kullanılan semboller topluluğudur. Bir dilin kurallarına "gramer" denir.  Gramerin pek çok
	bileşeni vardır. Bunlardan en önemlileri "sentaks (syntax) ve semantik (semaintic)" kavramlarıdır. Bir olgunun dil
	olabilmesi için en az sentaks ve semantiğesahip olması gerekir. Tersine sentaks ve semantiğe sahip olan bir olgu dildir. 

	Sentaks (sözdizim) doğru yazılmış ve doğru dizilmiş öğelere ilişkin kurallardır:
		"I am from Turkey"
	cümlesi sentaks olarak doğru yazılmıştır. Burada örneğin cümle "I from am Turkey" olarak yazılsaydı sentaks olarak
	hatalı olurdu. Java olarak bakarsak, örneğin
		System.out.println("Hello, World"); 
	cümlesinde noktalı virgül olmazsa sentaks hatası yapılmış olur. 

	Dildeki doğru yazılmış ve dizilmiş öğelerin ne anlam ifade ettiğine yönelik kurallara semantik kurallar denir. 

	Anahtar Notlar: Gramer'in daha çok doğal dillere özgü morfoloji gib başka bileşenleri de bulunur

	Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar sistemlerinde kullanılmak üzere tasarlanmış dillere bilgisayar 
	dilleri (computer languages) denir. Bir bilgisayar dilinde akış (flow) öğesi de varsa programlama dili (programming language)
	denir. Her programlama dili bir bilgisayar dilidir, her bilgisayar dili programlama dili değildir. Örneğin HTML, XML
	dilleri bilgisayar dilleridir ancak programlama dilleri değildir. Java'da bir akış olduğundan, programlama dilidir dolayısıyla
	bilgisayar dilidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Boşluk karakterleri (whitespace characters): Klavyeden basıldığında boşluk hissi veren karakterlerdir. Bu anlamda
	SPACE, ENTER ve TAB karakterleri klavyedeki tipik boşluk karakterleridir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atom (Token): Programlam dilinin parçalanamayan en küçük birimine denir. Burada parçalama terimi genel olarak boşluk
	karakterleri ile ayırma anlamında düşünülebilir. Java'da atomlar şunlardır:
	1. Anahtar Sözcükler (keywords/reserved words): Dile ait olan, herhangi bir şekilde tanıtılması gerekmeyen ve doğrudan
	değişken ismi olarak kullanılamayan atomlardır. Örneğin package, class, public, static, void.

	2. Değişkenler (variables/identifiers): İsmini programcının belirlediği ve isimlendirmesinde çeşitli kuralların bulunduğu
	atomlardır. Örneğin: csd, App, main, String, args, System, out, println.

	3. Sabitler (literals/constants): Program içerisinde doğrudan yazılan değerlere denir. Örneğin x = 10 ifadesinde 10 
	bir sabittir. 

	4. Operatörler (operators): Belirli işleme yol açan ve bu işlem sonucunda değer üreten atomlardır. 
	Örneğin, nokta (.), metot çağırma (()) operatörleri.

	5. String'ler (string literals/strings): İki tane iki tırnak (double quote) arasındaki yazılara tırnaklarıyla birlikte
	string denir. Örneğin, "Hello, World".

	6. Ayraçlar (delimiters/punctuators): Yukarıdakiler dışında kalan diğer atomlardır. Örneğin:;, {}, (), [].
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da kod yazma kuralları:
	1. Atomlar arasında istenildiği kadar boşluk(whitespace) bırakılabilir
	2. Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir. İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	
	Atomlar arasında istenildiği kadar boşluk bırakılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	






public static 









void main(String [






] args)
	{
		System.out





.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
	İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
packagecsd;class App{public static void main(String [] args){System.out.println("Hello, World");}} //error

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki iki kural aslında programcının okunabilir/algılanabilir (readable) kodlar yazabilmesini
	sağlar. Bu anlamda şirketlerin kendilerine özgü yazım stillerini içeren kuralları bulunabilir. Bu kurallara 
	İnglizce olarak "coding convention" ya da "code style guide" gibi terimler kullanılabilir. Buradaki yazım stilleri
	şirketten şirkete farklılıklar ya da benzerlikler içerebilir. Burada C ve Sistem Programcıları Derneği'nin 
	yazım stili ile yazılacaktır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da "derleme zamanı (compile time)" ve "çalışma zamanı (run time)" denilen iki önemli kavram vardır.
	Derleme zamanı, derleme sürecine ilişkin işlemlere denir. Çalışma zamanı ise, byte code'un çalıştırılması sürecine 
	ilişkin işlemlere denir. Bu kavramlar birbirleriyle ilişkili olsalar da, ayrı kavramlardır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	13.08.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Derleyicinin Teşhis Mesajları (Diagnostics):
	1. Gerçek hatalar (Errors): Dilin sentaks ya da semantik kurallarına uyulmamasından dolayı verilen mesajlardır. Bu durumda
	"byte code" üretilmez. Programcının bu hataları düzeltip kodu derlemesi gerekir.

	2. Uyarılar (Warnings): Byte code'un üretimine engel olmayan, olası programlama ve mantık hatalarının bildirilmesi
	için verilen mesajlardır. Programcı bu uyarıları kesinlikle dikkate almalıdır. Özel bir durum yoksa uyarı mesajlarının
	oluşumuna yol açan kodlar düzeltilmeldir. Bazı durumlarda derleyicinin uyarı mesajı vermediği ancak IDE'nin kullandığı
	bir "static kod analizi aracları" konfigürasyonları gereği uyarı verebilir. Bunlar da dikkate alınmalıdır. Ancak hepsinin
	düzeltilmesi gerekmez. Tipik olarak ürün elde edilmesi aşamasında derleyici anlamında hiç bir uyarı mesajının olmaması gerekir.

	3. Ölümcül hatalar (Fatal errors): Derleme işleminin bile tamamlanmasını engelleyen hatalardır. Bu durumda programcının
	yazdığı kod açısından yapacak birşeyi yoktur. Çünkü kod henüz derlenmemiş bile olabilir. Programcının ölümcül hataya 
	yol açan durumu ortadan kaldırması gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar
	ölümcül hatalara yol açar

	Programın çalışma zamanı sırasında oluşan hatalı durumlara genel olarak "exception" denir. Exception işlemleri
	ileride "exception handling" isimli bölümde ele alınacaktır. Bu konu ele alınana kadar exception oluştuğunda
	"program sonlanır" olarak anlaşılacaktır. Exception terimi yerine "run time error" da kullanılmaktadır. "error"
	dendiğinde "compile time error" anlaşılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Program içerisinde derleyicinin görmezden geleceği yazılara "yorum satırları (comment lines)" denir. Java'da iki
	çeşit yorum satırı kullanılmaktadır. Aşağıda örnekleri gösterilmiştir. İç içe yorum satırlarının kullanımında
	dikkatli olunmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

//App sınıfı
class App {
/*
	Burası da 
	derleyici tarafından dikkate alınmayacak
*/
	public static void main(String [] args) 
	{
		
		System.out.println("Hello, World"); //Burası derleyici tarafından dikkate alınmayacak
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programcı yorum satırlarını gereksiz yere ve karışık olarak yazmamalıdır. Gereksiz ve karışık olarak
	yazılmış yorum satırlarının da okunabilirliği/algılanabilirliği olumsuz etkileyebileceği unutulmamalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da birden fazla ".java" dosyası ile çalışmanın bir takım ayrıntıları vardır. Bu sebeple 
	paketler konusuna kadar yalnızca tek bir ".java" dosyası (App.java) ile çalışacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlama dili gibi formal olarak tasarlanmış kavramlar açıklanırken genel biçimlere ilişkin bir 
	takım yöntemler kullanılır. Özellikle bir takım standartlar BNF (Backus Neuer Form) notasyonu kullanırlar. 
	"Java Language Specification (JLS)" içerisinde de büyük ölçüde BNF kullanılmıiştır. BNF görece karmaşık bir yapıya 
	sahiptir. Özellikle başlangıç düzeyinde öğrenmek için kullanılması çok etkin bir yöntem değildir. Bu sebeple biz 
	kursumuzda BNF notasyonu kullanmayacağız. Biz açısal parantez köşeli parantez tekniğini kullanacağız. Bir genel 
	biçimde açısal parantez içerisine alınan bir bilgi zorunlu bir bilgi anlamına gelir, köşeli parantez içerisine 
	alınan bilgi ise seçenekli bir bilgi yani orada olmaya dabilir anlamına gelir. Şüphesiz olması ile olmaması aynı 
	anlamda olmak zorunda değildir. Açısal parantez veya köşeli parantez içerisine alınmamış her bilgi orda olması 
	gereken şeklinde anlamına gelir. Örneğin:
		package <paket ismi>;
	anlatımında package sözcüğü olması ve onu takip eden bir paket ismi bulunmalı anlamındadır. Ayrıca kodlar
	içerisinde //... biçimindeki gösterim de burada bir takım kodlar olabilir ancak şu durumda bizi ilgilendirmiyor
	anlamındadır. Ayrıca son 15 yıldır kaynaklarda (buna JSL de dahil) bir takım konular anlatılırken herhangi bir 
	senaryodan bağımsız olması anlamında isimlendirmede foo, bar, tar, car, zar gibi uydurma isimler kullanılmaktadır.
	Biz de konularımızda bu isimleri kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bildirim (declaration): Bir ismin derleyiciye tanıtılmasıdır. Yani derleyici bir ismin bildirimini arar 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı genel olarak paketlerden, paketler sınıflardan, sınıflar da metotlardan oluşur. Paket bildiriminin
	genel biçimi şu şekildedir:
		package <paket ismi>;
	Paket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Örneğin:
		package csd;
	Paket bildirimi tüm diğer bildirimlerden önce yani tipik olarak kaynak kodun tepesinde bulunmalıdır. Bu sebeple bir 
	".java" dosyasında yalnızca bir tane paket bildirimi bulunabilir. Paketler konusu ayrıntılı bir konudur. İleride detaylı 
	olarak ele alınacaktır. Sınıf bildiriminin genel biçimi şu şekildedir:
		[erişim belirleyici] class <sınıf ismi> {
			//...
		}
	Erişim belirleyici dışında başka sözcükler de olabilir. Erişim belirleyici ve diğerleri konular içerisinde ele
	alınacaktır. Sınıf ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Sınıflar konusu da
	oldukça detaylı bir konudur. Neredeyse her konuda sınıflarla ilgili detaylar ele alınacaktır. Örneğin:
		class Sample {
			//...
		}
		
		class Person {
			//...
		}
		
		class SerialPort {
			//...
		}
	Java'da alt programlara metot (method) denir. Bir metodun ne iş yapacağının yani kodlarının yazılmasına 
	metot bildirimi (method declaration), kodlarının çalıştırılmasına ise metot çağrısı (method call) denir. Java'da
	bir metot bir sınıf içerisinde bildirilmek zorundadır. Metot bildiriminin genel biçimi şu şekildedir:
	  [erişim belirleyici] [static] <geri dönüş değeri> <metot ismi>([parametre değişkenleri])
	  {
	  		//...
	  }
	Erişim belirleyici şunlardan biri olabilir: public, protected, no-modifier, private. Burada no-modifier hiç bir şey
	yazmamak anlamındadır. Bu erişim belirleyicilerin hepsi farklı anlamdadır. İlgili konuya gelene kadar bir tüm
	metotlardaki erişim belirleyicileri public yapacağız. Java'da bir metot static veya non-static olarak bildirilebilir.
	Bir metodun bildiriminde static anahtar sözcüğü yazılırsa metot static olur. İlgili konuya gelene kadar tüm metotlarımızı
	static olarak bildireceğiz. Metodun kodlarının yazıldığı bölüme metodun gövdesi (method body) denir. static bir metodu 
	çağırmanın genel biçimi şu şekildedir:
		[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);
	Bir metot genel olarak başka bir metot içerisinde çağrılabilir. Akış java programına verilen sınıfın main metodundan
	başlar. main metodu bittiğinde akış sonlanır. Bizim bu kursdaki programlarımızda bir tane akış olduğundan main metodu
	bittiğinde program sonlanır. main metodu JVM tarafından akışı başlatmak üzere çağrılır. Bu anlamda akışı başlatmak
	için çağrılan main metoduna "giriş noktası (entry point)" denir. Bir metot çağrıldığında akış metodun kodlarına 
	dallanır ve metodun kodları çalıştırıldıktan sonra akış çağrılan noktaya geri döner. Metodun geri dönüş değeri
	yoksa void anahtar sözcüğü yazılır. Metodun ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir.
	Metodun parametre değişkenleri olabilir. Metodun geri dönüş değeri ve parametre değişkenleri ileride ele
	alınacaktır. Yani aslında bir program main metodun çağrılmasıyla başlar ve bi rçok metodun çağrılması ile devam eder.
	print ve println'de birer metottur. Ancak bu metotlar static metot değildir. Bu sebeple System.out.print veya
	System.out.println çağrıları yukarıdaki biçimden farklıdır. Burada System bir sınıf, out bir referans, print ve prinln de
	birer metot ismidir. Detaylar şu an önemsizdir. Bu iki metot aldıkları yazıyı basarlar. println son yazdığı 
	karakterden sonra bir sonra satıra geçme karakterini de basar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		csd.Mample.tar();
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı pakette ise çağrı
	sırasında paket ismi yazılmayabilir. Çağıran metodun ait olduğu sınıf ile çağrılan metodun ait olduğu sınıf aynı ise
	paket ismi yazılmazsa sınıf ismi de yazılmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		Sample.foo();
		Sample.bar();
		Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		Mample.tar();		
	}
	
	public static void bar()
	{
		System.out.println("bar");
		foo();
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sayı sistemleri
	Biz 10'luk sistemi (decimal system) kullanmaktayız. 10'luk sistemde sayıları ifade etmek için 10 sembol vardır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9

	10'luk sistemde sayının her bir basamağı 10'nun kuvvetleriyle çarpılıp toplanmaktadır. Örneğin:

	123.25 = 3 * 10^0 + 2 * 10^1 + 1 * 10^2 + 2 * 10^-1 + 5 * 10^-2

	Halbuki bilgisayarlar 'lik sistemi (binary system) kullanmaktadır. 2'lik sistemde sayıları ifade etmek için 2 sembol kullanılmaktadır:

	0 
	1

	2'lik sistemde sayının her bir basamağına "bit (binary digit)" denilmektedir. 2'lik sistemde sayının her basamağı 2'nin kuvvetiyle çarpılarak sayı elde edilir.
	Bit en küçük bellek birimidir. 8 bite 1 byte denilmektedir. Genellikle bitler 4'erli gruplanarak yazılırlar. Örneğin:

	1010 0010

	Burada 1 byte'lık bir bilgi vardır. Byte temel bellek birimidir. 

	Byte da küçük bir birimdir. Kile diğer bilimlerde "1000 katı" anlamına gelmektedir. Ancak bilgisayarlar 2'lik sistemi kullandığj için 1000 katı iyi bir
	kat değildir. Bu nedenle genel olarak Kilo byte için 2'nin 102uncu kuvveti olan 1024 kat kullanılır. Yani 1KB (kısaca 1K) 1024 byte'tır. Mega diğer bilimlerde 
	kilonun 1000 katıdır. Dolayısıyla milyan kat anlamına gelmektedir. Ancak bilgisayar bilimlerinde genel olarak mega kilonun 1024 katı olarak alınır. 
	Bu durumda 1 MB = 1020 * 1024 (2^20) KB'dir. Giga ise meganın 1024 katıdır. Bu durumda 1 GB = 1024 * 1024 * 1024 byte'tır ( 2^30). Giga'dan sonra tera, tera'dan sonra 
	peta, ondan sonra da exa gelmektedir. 

	1 byte içerisinde yazılabilecek en küçük ve en büyük sayılar şöyledir:

	0000 0000 ---> 0
	1111 1111 ---> 255

	1 byte içerisinde 1 ve 0'ların bütün permütasyonları 256 tanedir. 2 byte içerisinde en büyük sayıyı yazacak olsak şöyle olurdu:

	1111 1111 1111 1111 ---> 65535

	Biz burada ikilik sistemde tamsayıları ifade ettik. Ama bütün sayıları pozitif kabul ettik. Pekiyi negatif tamsayılar nasıl ifade edilmektedir?

	Bugün negatif sayıların ifade edilmesi için "ikiye tümleyeb (two's complement)" sistemi denilen bir sistem kullanılmaktadır. Bu sistemde pozitif ve 
	negatif sayılar birbirlerinin ikiye tümleyenidirler. ikiye tümleyen bire tümleyene bir eklenerek bulunmaktadır. Bir sayının bire tümleyeni sayıdaki
	o'ların 1, 1'lerin 0 yapılmasıyla bulunur. Bu durumda ikiye tümleyen şöyle hesaplanır. örneğin aşağıdaki sayının ikiye tümleyenini bulmaya çalışalım:

	0101 0110

	Sayının bire tümleyenine bir ekleyeceğiz:

	1010 1001
    0000 0001
    ---------
    1010 1010

	Aslında ikiye tümleyeni bulmanın kolay bir yolu da vardır: Sayıda sağdan sola ilk 1 görene ilk 1 dahil olmak üzere aynısı yazılarak ilerlenir. 
	Sonra 0'lar 1, 1'ler 0 yapılarak devam edilir. Örneğin:

	0101 0110

	sayının ikiye tümleyenini tek hamlede bulalım:

	10101010

	Negatif sayıları ifade edebilmek için kullanılan ikiye tümleme sisteminde en soldaki bit işaret bitidir. Bu bit 0 ise sayı pozitif, 1 ise negatiftir.
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidir. Örneğin bu sistemde +10 yazmak isteyelim. Bunu işaret 0 yaparak yazabiliriz:

	0 000 1010		---> +10

	Şimdi -10 yazmak isteyelim. Bunun için +10'un ikiye tümleyenini alalım:

	1 111 0110       ---> -10

	Bu sistemde +n ile -n toplandığında 0 elde edilir:

	0 000 1010   ---> +10
	1 111 0110   ---> -10
	---------------------
  1	0 000 0000   ---> 0

  	Bu sistemde tek bir sıfır vardır. O da tüm bitleri 0 olan sıfırdır. Bu sistemde 1 byte içerisinde yazılabilecek en büyük pozitif sayı şöyledir:

	0 111 1111    ---> +127

	Şimdi bunun ikiye tümleyenini alalım:

	1 000 0001    ---> -127

	Pekiyi en küçük negatif sayı nedir? Bu sistemde bir tane sıfır olduğuna göre 255 tane permütasyon eşit bölünemez. Demek ki ya pozitif sayılar ya negatif sayılar 
	bir tane daha fazla olmak zorundadır. Bu sistemde ikiye tümleyeni olmayan iki sayı vardır:

	0000 0000 
	1000 0000

	Birincisi 0'dır. İkinci sayı -127'den bir eksik olan sayıdır. O halde bu sayının -128 kabul edilmesi daha uygundur. 

	Demek ki bu sistemde n byte içerisinde yazılabilecek en büyük pozitif sayı ilk biti 0 olan diğer tüm birleri 1 olan sayıdır. En küçük 
	negatif sayı ise ilk biti 1 olan diğer tüm bitleri 0 olan sayıdır. Örneğin bu sistemde iki byte ile yazabileceğimiz en büyük pozitif sayı
	şöyledir:

	0111 1111 1111 1111		---> +32767

	En küçük negatif sayı ise şöyledir:

	1000 0000 0000 000   	---> -32768

	Bu sisteme ilişkin tipik sorular ve yanıtları şöyledir:

	SORU: Bu sistemde +n sayısını nasıl yazarsınız?
	CEVAP: En soldaki bit 0 yapılıp n sayısı 2'lik sistemde yazılır.

	SORU: Bu sistemde -n nasıl yazarsınız?
	CEVAP: Yazabiliyorsanız doğrudan yazın. Ancak doğrudan yazamıyorsanız önce +n değerini yazın ve ikiye tümleyenini alın. Örneğin bu sistemde -1 
	yazalım. Önce +1 yazalım:

	0000 0001   ---> +1

	Şimdi bunun ikiye tümleyenini alalım:

	1111 1111   ----> -1

	SORU: Bu sistemde bir sayının kaç olduğu bize sorulsa bunu nasıl yanıtlarız?
	CEVAP: Eğer en soldaki bit 0 ise sayının değeri doğrudan hesplanır. Eğer en soldaki bit 1 ise bu sayının negatif olduğunu gösterir. Bu durumda 
	sayının ikiye tümleyeni alınır. Pozitifinden hareketle negatifi bulunur. Örneğin 1110 1110 sayısı kaçtır? Burada işaret biti 1 olduğuna göre sayı negatiftir. 
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidirler. O zaman bu sayının ikiye tümleyenini alıp pozitifinden faydalanarak sayıyı bulalım:

	0001 0010  ---> +18

	o zaman bize sorulan sayı -18'dir.

	Bu sistemde örneğin 1 byte içerisinde yazılabilecek en büyük pozitif sayıya 1 toplayalım:

	0111 1111   ---> +127
	1000 0000   ---> -128

	Demek ki bu sistemde bir sayıyı üst limitten taşırırsak yüksek bir negatif sayıyla karşılaırız. Benzer şekilde alt limitten taşırırsak yüksek bir 
	pozitif sayı ile karşılaşırız	 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Tamsayılar ikilik sistemde "işaretsiz (unsigned)" ya da "işaretli (signed)" sistemde yorumlanabilirler. İşaretsiz sistemde sayının en soldaki biti
	olarak yorumlanmaz. Sayı herzaman sıfır ya da pozitiftir. İşaretli sistemde ise sayının en solundaki bit işaret bitidir. Sayı ikiye tümleyen aritmetiğine 
	göre yorumlanır.
	 
	İşlemciler aslında genellikle işaretli ve işaretsiz ayırımını yapmazlar. Çünkü bu tür de aslında aynı biçimde işleme sokulmaktadır. Sonucun yorumu değişmektedir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi noktalı sayılar ikilik sistemde nasıl ifade edilmektedir? İşte insanlar noktalı sayıları ifade etmek için iki format geliştirmişlerdir. Bunlardan birine
	"sabit noktalı formatlar (fixed point formats)" diğerine "kayan noktalı formatlar (floating point formats)" denilmektedir. Sabit noktalı formatlar eski 
	devirlerde basit bir mantıkla tasarlanmıştır. Bu formatlar bugün hala kullanılıyor olsa da büyük ölçüde artık bunların çağı kapanmıştır. Bugün kayan noktalı
	format denilen formatlar kullanılmaktadır. 

	Sabit noktalı formatlarda noktalı sayı için n byte yer ayrılır. Noktanın yeri önceden bellidir. Örneğin sayı 4 byte ile ifade edilsin. 
	Noktanın yeri de tam ortada olsun. Bu durumda syının tam kısmı 2 byte ile noktalı kısmı 2 byte ile ifade edilir. Ancak sayının noktalı kısmı 2'nin
	negatif kuvvetleriyle kodlanmaktadır. VBöylece iki sabit noktalı sayıyı paralel toplayıcılarla kolay bir biçimde toplayabiliriz: Örneğin bu sistemde 
	5.25 ile 6.25 sayılarını ifade edip toplayalım:

	0000 0000 0000 0101 . 0100 0000 0000 0000    ---> 5.25
	0000 0000 0000 0110 . 0100 0000 0000 0000    ---> 6.25
	-------------------------------------------------------
	0000 0000 0000 1011 . 1000 0000 0000 0000    ---> 11.5

	Pekiyi bu yöntemin ne dezavantajı vardır? Yöntemin en önemli dezavantajı dinamik olmamasıdır. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sabit noktalı formatların dinamik olmaması nedeniyle kayan noktalşı formatlar geliştirilmiştir. Bu formatlarda noktanın yeri sabit değildir. 
	Noktanın yeri format içerisinde ayrıca tutulmaktadır. Noktalı sayının noktası yokmuş gibi ifade edilmesi durumunda sayının bu haline "mantis (mantissa)" 
	denilmektedir. İşte kayan formatlarda sayı için ayrılan alanın bir bölümünde manris bir bölümünde de "noktanın yeri" tutulmaktadır. Noktanın yerini belirleyen
	kısma "üstel kısım (exponential part)" denilmektedir. Tabii bir de sayının başında işaret biti bulunur. Bu durumda kayan noktalı bir sayının format aşağıdakine benzerdir:

	[işaret biti] [mantis] [noktanın yeri (exponential)]

	Bugün ağırlıklı kullanılan kayan noktalı format IEEE 754 denilen formattır. Bu formatın üç farklı genişlikte biçimi vardır:

	IEEE 754 - Short Real Format (4 byte)
	IEEE 754 - Long Real Format (8 byte)
	IEEE 754 - Extended Real Format (10 byte)
	
	Bugün Intel, ARM, MIPS, Alpha, Power PC gibi yaygın işlemciler donanımsal olarak bu formatı desteklemektedir. Aynı zamanda bu format yaygın olarak Reel Sayı Ünitesi
	olmayan mikrodenetleyicilerdeki derleyiciler tarafından da kullanılmaktadır.

	Kayan noktalı formatların (örneğin IEEE 754 formatının) en ilginç ve problemli tarafı "yuvarlama hatası (rounding error)" denilen durumdur. Yuvarlama hatası
	noktalı sayının tam olarak ifade edilemeyip onun yerine ona yakın bir sayının ifade edilmesiyle oluşan hatadır. Yuvarlama hatası sayıyı ilk kez depolarken de 
	oluşabilir, aritmetik işlemlerin sonucunda da oluşabilir. Tabii noktalı sayıların bir bölümü bu formatta hiçbir yuvarlama hatasına maruz kalmadan ifade edilebilmektedir. 
	Ancak bazı sayılarda bu hata oluşabilmektedir. Bu hatayı ortadan kaldırmanın yolu yoktur. Tabii sayı için daha fazla bir ayrılırsa yuvarlama hatasının etkisi de 
	azalacaktır. 

	Yuvarlama hatalarından dolayı programlama dillerinde iki noktalı sayının tam eşitliğinin karşılaştırılması anlamlı değildir. Örneğin aşağıdaki işlemde
	yuvarlama hatasından dolayı sayılar sanki eşit değişmiş gibi ele alınacaktır.  

	0.2 + 0.1 == 0.3 (false)
	
	Pekiyi yuvarlama hatasının önemli olduüu ve bunun istenmediği tarzda uygulamalarda (örneğin finansal uygulamalarda, bilimsel birtakım uygulamalarda)
	ne yapak gerekir? İşte bunun tek yolu noktalı sayıları kayan noktalı formatta tutmamak olabilir. Bazı programlama dillerinde noktalı sayıyı 
	kayan noktalı formatta tutmayan böylece yuvarlama hatalarına maruz bırkmayan özel türler (örneğin C#'taki decimal) vardır. Ancak bu türler işlemciler tarafından 
	desteklenmediği için yapay türlerdir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Yazılar da aslında bilgisayar belleğinde 2'lik sistemde sayılar biçiminde tutulmaktadır. Bir yazıyı oluşturan elemanlara "karakter" denilmektedir. İşte
	bir yazıda her bir karakter 2'lik sistemde bir sayı ile ifade edilir. Böylece yazı aslında ikilik sistemde bir sayı dizisi gibi tutulmaktadır. İşte
	bir karakter için hangi sayının karşı geldiğini belirten tablolara "karakter tabloları" denilmektedir. Karakter tablosundaki karakter şekillerine "glyph"
	denilmektedir. Her karaktere tabloda bir sıra numarası verilmiştir. Buna da "code point" denilmektedir. Dünyanın ilk standart karakter tablosu "ASCII (American
	Standard Code Information Interchange)" denilen tablodur. ASCII tablosu aslında 7 bit bir tablodur. Dolayısıyla tabloda 128 tane glyph için code point
	bulundurulmuştur. ASCII dışında IBM EBCDIC tablosunu geliştirmiştir. Wang firması WISCII tablosunu kullanmıştır. ASCII tablosu Amerikalılar tarafından yalnızca İngilizce
	karakterleri ifade etmek için oluşturulmuştur. Bilgisayarlar yaygınlaşmaya başladığında farklı karakterlere sahip olan Türkiye gibi, Yunanistan gibi, Almanya gibi
	ülkeler bu ASCII tablosunu 8 bite çıkartıp elde edilen 128'lik yeni alanı kendi karakterlerini ifade etmek için kullanmışlardır. ASCII tablosunun ilk yarısı 
	(yani [0, 128] numaraları karakterleri) standarttır. Ancak ikinci yarısı "code page" adı altında farklı ülkeler tarafından farklı yerleşimler yapılarak kullanılmaktadır. 
	DOS zamanlarında Türkçe karakterler için OEM 857 denilen code page kullanılıyordu. Daha sonra Microsoft Windows sistemlerinde Türkçe karakterler için 1254 code page'i
	düzenledi. ISO, bu code page'leri standart hale getirmiştir. Bugün Türkçe karakterler ISO tarafından ASCII 8859-9 Code page'i ile düzenlenmiştir.

	ASCII tablosu ve onların code page'leri uzun süre kullanılmış ve hala kullanılmakta olsa da maalesef karışıklıklara yol açmaktadır. İşte son 20 yıldır
	artık karakterleri 2 byte içerisinde ifade ederek dünyanın bütün dillerinin ve ortak sembollerinin tek bir tabloya yerleştirilmesi ile ismine UNICODE 
	denilen bir tablo oluşturulmuştur (www-unicode.org). UNICODE tablo ISO tarafından 10646 ismiyle de bazı farklılıklarla standardize edilmiştir. UNICODE tablonun
	ilk 128 karakteri standart ASCII karakterleri, ikinci 128 karakteri ISO 8859-9 code page'indeki karakterlerdir. 

	Bir karakter tablosundaki code point'lerin ikilik sistemde ifade edilme biçimine "encoding" denilmektedir. ASCII code page'lerinde encoding doğrudan 
	code point'in 1 byte'lık sayı karşılığıdır. Ancak UNICODE tablonun değişik encoding'leri kullanılmaktadır. UNICODE tablonun klasik encoding'i UTF-16'dır. 
	Burada code point doğrudan 16 bir bir sayı biçiminde ifade edilir. UTF-32 encoding'inde ise code point 32 bitlik bir sayı biçiminde ifade edilmektedir. 
	Ancak UNICODE tablonun en yaygın kullanılan encoding'i UTF-8 encoding'idir. UTF-8 kodlamasında standart ASCII karakterler 1 byte ile, diğer karakterler 
	2 byte, 3 byte, 4 byte ve 5 byte kodlanabilmekedir. Türkçe karakterler UTF-8 encoding'inde 2 byte yer kaplamaktadr. UTF-8 encoding'i UNICODE bir yazının 
	adeta sıkıştırılmış bir hali gibi düşünülebilir. 

	Bugün pek çok programlama editörleri default durumda dosyayı UNICODE UTF-8 encoding'ine göre saklamaktadır.
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Bilgisayar dünyasında çok kullanılan diğer bir sayı sistemi de 16'lık sistemdir. 16'lık sisteme İngilizce "hexadecimal system" denilmektedir. 16'lık 
	sistemde syaıları ifade etmek için 16 sembol bulunmaktadır. İlk 10 sembol 10'luk sistemdeki sembollerden alınmıştır. Sonraki 6 sembol alfabetik karakterlerden alınmıştır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9
	A
	B
	C
	D
	E
	F

	16'lık sistemdeki her bir basamağa "hex digit" denilmektedir. Örneğin:

	1FC8

	Burada 4 hex digit'lik bir sayı vardır. 16'lık sistemdeki bir sayıyı 10'luk sisteme dönüştürmek için her hex digit 16'lık kuvvetleriyle çarpılıp toplanır. 
	Ancak 16'lık sistemdeki sayı kullanım gereği bakımından aslında 10'lu sisteme pek dönüştürülmez. 16'lık sistemdeki her bir hex digit 4 bit ile ifade edilebilmektedir:

	0		0000
	1		0001
	2		0010
	3		0011
	4		0100
	5		0101
	6		0110
	7		0111
	8		1000
	9		1001
	A		1010
	B 		1011
	C 		1100
	D 		1101
	E 		1110
	F       1111

	16'lık sistemden 2'lik sisteme dönüştürme yapmak çok kolaydır. Tek yapılacak şey bir hex digit'e karşılık yandaki tablodaki 4 biti getirmektir. Örneğin:

	1FC9  =  0001 1111 1100 1001
	FA3D  =  1111 1010 0011 1101

	2'lik sistemdeki bir sayı da 16'lık sisteme çok kolay dönüştürülür. Tek yapılacak şey sayıyı dörderli gruplayıp ona karşı gelen hex digit'i yazmaktır. Örneğin:

	1010 0001 1110 1000 0011 0101 = A1E835

	Bilgisayar dünyasında 162lık sistem aslında 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Yani 2'lik sistem çok yer kapladığı için kişiler
	2'lik sistem yerine 16'lık sistemi kullanırlar. Bu nedenle belleği, dosyayı gösteren programlar bunları 2'lik sistem yerine 16'lık sistemde gösterirler. 

	1 byte 2 hex digit ile ifade edilmektedir. Örneğin:

	1A 23 5C 78

	Burada 4 byte'lık bir bilgi vardır. Örneğin 2 byte içerisinde yazılabilecek en küçük negatif işaretli sayının hex karşılığı 8000 biçimindedir. Örneğin
	bir byte'lık işaretli sistemde yazılabilecek en büyük pozitif sayı 7F biçimindedir. İşareti tamsayı sisteminde 4 byte içerisinde -1 sayısı FFFFFFFF 
	biçimindedir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Eskiden daha fazla kullanılıyor olsa da toplamda oldukça seyrek kullanılan diğer bir sayı sistemi de 8'lik sayı sistemidir. Bu sisteme İngilizce 
	"octal system" denilmektedir. 8'lik sayı sistemindeki her bir basamağa "octal digit" denir. Octal digit sembolleri olarak 10'luk sistemin ilk 8 sembolü 
	kullanılmaktadır:

	0
	1
	2
	3
	4
	5
	6
	7

	Her octal digit 3 bir ile ifade edilebilir:

	0	000
	1	001
	2	010
	3	011
	4	100
	5	101
	6	110
	7	111

	Bu durumda bir octal sayı 2'lik sisteme kolay bir biçimde dönüştürülebilir:

	476		100 111 110
	741		111	100	001

	Benzer biçimde 2'lik sistemdeki bir sayı da sağdan sola üçer bir gruplandırılarak 8'lik sisteme dönüştürülebilmektedir. Örneğin:

	1011 1011	=  273
	0111 1110	=  176

	8'lik sistem de 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Ancak 8'i tam ortalayamadığı için kullanımı seyrektir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Tür (type): Bir değişkenin içerisindeki değerin hangi formatta tutulduğunu ve bellekte ne kadar uzunlukta (byte) yer
	ayrılacağını belirtir. Java'da türler temel türler (primitive/built-in/predefined types) ve programcının tanımladığı
	türler (user defined types) olmak üzere iki gruba ayrılabilir. Programcının tanımladığı türler ileride ele alınacaktır.
	Temel türler birer anahtar sözcük olarak temsil edilmektedir. Java'nın tamel türleri şunlardır:
	
	   Tür ismi            Uzunluk (byte)            Sınır Değerler
	   short                 2                    	[-32768, +32767]
	   int                   4                    	[-2147483648, +2147483647]  
	   long                  8                    	[-9223372036854775808, +9223372036854775807]
	   byte                  1                    	[-128, +127]
	
	   float                 4                    	[±3.6 * 10-38, ±3.6 * 10+38]
	   double                8                    	[±1.6 * 10-308, ±1.6 * 10+308]
	
	   char                  2                    	[0, 65535]
	   boolean               -                    	true, false
	
	Temel türlere ilişkin özellikler:
	- Temel türler genel olarak tamsayı türleri (integer/integral types), gerçek sayı türleri (real types) ve özel amaçlı
	türler olarak ayrılabilir. 
	
	- Tamsayı türlerinde işaretli (signed) sistemde, 2'ye yöntemi kullanılır.
	
	- Gerçek sayı türleri IEEE 754 formatına göre çalışırlar. Bu formatta yuvarlama hataları (rounding error) oluşabilir. 
	double türü "çift hassasiyetli (double precision)", float türü ise "tek hassasiyetli (single precision)" olarak çalışırlar.
	Bu kavramlar IEEE 754 standardına ilişkindir. Burada bilinmesi gereken yuvarlama hatalarının oluşabileceği ve double
	türünün, float türüne göre daha az yuvarlanacağıdır. Yani float türünün yuvarlamaya karşı direnci, double türüne göre daha
	zayıftır. Yuvarlama hataları, bir işlemin sonucunda oluşabileceği gibi bir değer yerleştirilirken de olabilir.
	
	- Gerçek sayılardaki yuvarlama hatası, IEEE 754 standardının yöntemidir. Hatalı bir çalışma değildir. Programcı 
	bu yuvarlama hatalarının problem oluşturabileceği (örneğin parasal ve finansal uygulamalar) uygulamalarda bu türleri
	kullanmaz. Böyle bir durumda hangi türün kullanılacağı ileride ele alınacaktır. Böylesi bir durum dışında yani yuvarlama
	hatalarının öneminin olmadığı uygulamalarda bu türler kullanılır. Çünkü, yuvarlama hatası yapılmamasını sağlayan
	yöntemlerde yüzlerce makine komutunun kullanıldığı yerde, IEEE 754 ile bu tek bir makine komutuyla yapılabilir.
	
	- char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türden 
	bir değişken içerisinde tutulan sayı UNICODE tabloda bir sıra numarası anlamına gelir. Dolayısıyla mantıksal olarak
	char türü içerisinde bir karakter tutulmuş olur.
	
	- boolean türünün alabileceği 2 tane değer vardır: true, false. boolean türünün uzunluğu JLS'de belirtilmemiştir.
	Sistemden sisteme değişebilir. Ancak bunu bir önemi yoktur.
	
	Anahtar Notlar: Java'da boolean türü dışında kalan temel türlerin uzunlukları her sistemde aynıdır.
	
	Anahtar Notlar: int türüne "integer" demek yanlış bir tanım kullanmak demektir. integer kavramı tam sayılara verilen
	genel bir isimdir. int ise 4 byte'lık bir tamsayı türüdür. Ayrıca JavaSE'de Integer isimli önemli bir sınıf da 
	bulunmaktadır
	
	Anahtar Notlar: Java'da en çok kullanılan tamsayı türü int'dir, en çok kullanılan gerçek sayı türü de double'dır. 
	Programcı öncelikle bu türleri düşünmeli. Bu türler gereksinimi karşılamıyorsa (ki karşılamadığı da bir çok senaryo
	mevcuttur) diğer türleri düşünmelidir. Bu anlamda int ve double türüne "default types" da denilmektedir	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatasını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);		
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatalarını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	20.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir değişken kullanılmadan önce bildirilmelidir. Değişken bildiriminin genel biçimi şu şekildedir:
		<tür> <ismi>;
	Örnek:
		int a;
		double b;
		
	Java'da 3 çeşit değişken vardır:
	1. Yerel değişken (local variable)
	2. Parametre değişkeni (parameter variable)
	3. Sınıf veri elemanı (class member variable)
	
	Değişkene ait için temel kavramlar:
	Tür (type): Bellekte ne kadar ayrılacağını ve o alanda bilginin hangi formatta tutulacağını belirtir.
	
	İsim (name): Belirli kurallara göre yazılabilen karakter topluluğudur.
	
	Faaliyet Alanı (scope): Değişken isminin görülebildiği (bilindiği) kod aralığıdır. Derleme zamanına ilişkin
	bir bilgidir.
	
	Ömür (storage duration): Bir değişkenin bellekte yaratılması ile yok edilmesi arasındaki süredir. Çalışma zamanına
	ilişkin bir bilgidir. İleride ele alınacaktır
	
	Anahtar Notlar: Değişken (variable) terimi değişken atomlar için de kullanılmaktadır. Burada değişken bellekte
	yer ayrılan ve içerisinde değer tutabilen atomlardır. Yani burada ele alından değişken de bir değişken atomdur. Ancak
	her değişken atom burada ele alınan değişken değildir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun içerisinde { ile } arasında kalan bölgeye bu küme parantezleri ile birlikte blok (block) denir. Aslında 
	metodun gövdesi de bir bloktur. Metot içerisinde istenildiği kadar içiçe veya ayrık bloklar olabilir. Bu anlamda 
	örneğin sınıf bildirimindeki {}'leri blok değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...
			{
				//...
			}
		}
		
		{
			//...
			{
				//...
				{
					//...
				}
			}
		}
	}
}

class Sample {
	public static void foo() 
	{
		{
			//...			
		}
		
		{
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		int a;
		double b;
		
		{
			boolean flag;
			//...
		}
	}
}

class Sample {
	public static void foo() 
	{
		int x;
		double y;
		
		{
			float z;
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yerel bir değişkenin faaliyet alanı (scope), bildirildiği yerden bildirildiği bloğun sonuna kadardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		{
			a = 10;
			int x;
			
			x = 10;
		}
		
		x = 20; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		boolean a; //error
		
		{			
			float a; //error			
			
		}		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
						
		}	
		
		{
			int a;
			
			a = 20;
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
		}
		
		int a;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir. Aşağıdaki örnekte her iki metotta da
	count isimde yerel değişken bildirimi olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int count;
		
		//...		
	}
	
	
	public static void bar()
	{
		int count;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aslında ekrana basmak ve klavyeden okuma kavramları JLS'de doğrudan bu şekilde belirtilmemiştir.
	print ve println metotları aslında "standard output (stdout)" denilen bir dosyaya yazma yaparlar. Bu anlamda klavyeden 
	bilgi okuyan metotlar da "standard input (stdin)" denilen bir dosyadan okuma yaparlar. Ancak, bu dosyalar çeşitli
	sistemlerde belli aygıtlara yönlendirilmiştir. Örneğin klasik masaüstü işletim sistemlerinde tipik olarak stdout ekrana,
	stdin de klavyeye yönlendirilmiştir. Biz kursumuzda ekran ve kalvye terimlerini kullanacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	print ve println metotları bir değişkenin değerini ekrana yazabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		a = 10;
		
		System.out.println(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir değişkene bildirim noktasında değer verilmesine "ilkdeğer verme (initialization)" denir. Bir değişkene bildirildikten
	sonra yapılan atama işlemi teknik olarak "initialization" ile aynı anlamda değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10; //initialization
		int b;
		
		b = 20; //assignment
		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamda, çeşitli sebeplerden dolayı artık kullanılması önerilmeyen durumlarda "deprecated"
	terimi kullanılır. Deprecated olmanın bir çok sebebi olabilir. Bu, neyin deprecated olduğu ile ilgilidir. Deprecated
	olan durumlar gerelçeleri ve yerine kullanılacakları ile birlikte dokümante edilir. Deprecated durumlarda derleyici
	uyarı mesajı verir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirme kuralları:
	Bu kurallar Java'da tüm değişken atomlar için geçerlidir.
	
	- Değişken isimleri sayısal bir karakter ile başlatılamaz. Uygun bir karakter ile başlatılıp istenildiği kadar 
	sayısal karakter kullanılabilir.
	
	- Değişken ismi alfabetik bir karakter ile başlatılabilir.
	
	- Değişken isminde _ karakteri kullanılabilir. Hatta değişken ismi _ karakteri ile başlatılabilir.
	
	- Java 8 ile birlikte _ karakterinin tek başına kullanılması deprecated olmuştur. Java 9 ile birlikte de artık 
	geçersiz duruma gelmiştir.
	
	- Anahtar sözcükler tek başına değişken ismi olarak kullanılamaz. Java'ya daha sonra eklenen ancak kullanımına göre
	anahtar sözcük gibi işlem gören bazı özel atomlar vardır. Bunlar doğrudan değişken ismi olarak kullanılabilirler. Bu
	tarz atomlara programlamada "contextual keyword" de denilmektedir.
	
	- Değişken isimlerinde whitespace karakterler kullanılamaz.
	
	- Değişken isimlendirmede UNICODE karakterler kullanılabilir. Örneğin, Türkçe karakterler geçerlidir. Her ne kadar 
	kullanılabiliyor olsa da, değişken isimlendirmede İngilizce alfabedeki karakter dışında karakter kullanmayacağız. Hatta
	değişken isimlerinde geçen kelimeleri de İngilizce dışında kelimeler olarak kullanmayacağız.
	
	- Değişken isimlendirmede $ karakteri kullanılabilir. Dolar karakteri tek başına kullanılabilir, değişken ismi $
	karakteri ile başlatılabilir. Ancak programcı hiç bir zaman değişken isimlendirmede $ karakterini kullanmamalıdır.
	Derleyici bazı durumlarda bir takım isimler vermek zorunda kalabilir. İşte $ karakteri bu tip durumlarda isim çakışmasını
	engellemek için düşünülmüştür. Programcı bu karakteri kullanmazsa, derleyici de ürettiği isimlerde bu karakteri için
	herhangi bir isim çakışması oluşmaz.
	
	- Değişken isimleri büyük-küçük harf duyarlıdır (case sensitive). Aslında Java case sensitive bir dildir.
	
	- JLS'de değişken isimlerinin uzunluğu (karakter sayısı) konusunda bir üst sınır belirtilmemiştir. Ancak pratikte
	kullanılan uzunluklar açısından bir problem yoktur. 
	
	- Değişken isimlerinde bazı teknikler kullanılabilir. Zaman içerisinde bu teknikler anlatılacak ve hangi durumlarda
	hangisinin kullanıldığı anlaşılacaktır. Örneğin programcı Java'da sınıf isimlerini büyük harf ile başlatır, birden 
	fazla kelimeden oluşuyorsa tüm kelimeler bitişik,  tüm kelimelerin baş harfleri büyük ve geri kalan karakterler
	küçük olacak şekilde isimlendirme yapılır. Bu stile "upper camel case veya pascal case" denilmektedir.
	
	- Değişken isimleri kolay telaffuz edilebilir, yeterince uzunlukta ve anlamlı olmalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da klavyeden (aslında stdin'den değil mi?) değer okumak için pek çok yöntem bulunmaktadır. Burada kullanacağımız
	yöntemde bazı ayrıntılar ileride anlaşılacaktır. Bu sebeple şu an bazı detaylar göz ardı edilmelidir. Bir kalıp
	biçiminde düşünülebilir. Ayrıca bu kalıpta bazı uyarı mesajları oluşabilir. Bunlar da şu aşamada önemsizdir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
				
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
				
		double total;
		
		total = a + b;
		
		System.out.println(total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();		
		double total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: double ve float türleri için klavyeden girişleride nokta veya virgül kullanımı sistemden sisteme ve 
	kullanılan kalıba göre değişiklik gösterebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());
				
		long total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		long a = kb.nextLong();
		long b = kb.nextLong();		
		long total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir geçerli dizilimdir. Değişkenler
	ve sabitler tek başına ifade olabilirken, operatörler tek başına ifade olamazlar. Her ifadenin bir değeri vardır. İfade
	hesaplandığında elde edilir. Bu durumun tek bir istisnası vardır. İleride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisi yerine bir tür ismi yazıldığında o metot o türe geri dönmüş olur. Bir metodun 
	geri dönüş değeri varsa çağrılan noktaya bir değer ile geri döner. Bu değer bir işleme sokulabilir. Bir metodun
	geri dönüş değeri return deyimi ile oluşturulur. return deyiminin genel biçimi şu şekildedir:
	
		return [ifade];
		
	return deyimi nasıl kullanılırsa kullanılsın temel görevi metodu sonlandırmaktır. Yani akış return deyimine geldiğinde
	metot sonlanır. Eğer return ifade ile kullanılırsa (ki geri dönüş değeri olan metotlarda bu zorunludur) ifadenin değerine
	geri döner
	
	Anahtar Notlar: ** ile belirtilen kodda önce add metodu çağrılır. Bu durum operatör önceliği (operator precedence)
	konusu ile ilgilidir. İleride detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		int total = a + b;
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Akış return deyimine geldiğinde önce return deyimine ilişkin ifade hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2;
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda return tek başına kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		if (a > b)
			return a + b;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java derleyicisi akışın herhangi bir noktaya kesinlikle gelemeyeceğini anladığında genel olarak 
	error oluşturur. Bu tip kod parçalarına "unreachable codes" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
		System.out.println("Unreachable code"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	26.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri geçici değişken (temporary variable) yaratılarak iletilir. Geçici değişken, metodun geri dönüş 
	değerinin türündendir. Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodunun geri dönüş değerinin iletimi 
	ve işleme sokuluşuna ilişkin yaklaşık kodlar şu şekildedir:
		int temp = a + b;
		
		result = temp * 2;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar, geri dönüş değeri yokmuş gibi çağrılabilir. Yani geri dönüş değeri bir işleme sokulmayabilir.
	Şüphesiz metodun da buna uygun olarak yazılmış olması gerekir. Aşağıdaki add metodu toplam değerini ekrana basmasaydı
	örnekteki çağrının bir anlamı olur muydu?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;
		
		System.out.println(result);
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri, başka bir metodun geri dönüş olabilir. Bu durum aslında şu kuralın bir sonucudur:
	akış return deyimine geldiğinde, return deyimine ilişkin ifade önce hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int total = Sample.getTotal();
		
		System.out.println(total);
	}
}

class Sample {
	public static int getTotal()
	{
		System.out.println("getTotal");
		
		return NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;		
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş olmayan metotların, geri dönüş değeri bilgisi void anahtar ile yazılır. Geri dönüş değeri bilgisi yerine
	hiç bir şey yazılmaması error oluşturur. Geri dönüş değeri olmayan metotlarda return deyimi zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		System.out.println(result);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Geri dönüş değeri olmayan metotlara "void metot (void method)" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına (yani ifade olmadan) kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return;
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyiminin ifade ile kullanımı error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return a + b; //error
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlar geri dönüş değeri varmış gibi çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result = NumberUtil.printAdd() * 2; //error
		
		//...
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;		
		
		//...
		
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Anımsanacağı gibi her ifadenin bir türü vardır. Yani her ifade hesaplandıktan sonra bir değer
	üretir. Ancak void bir ifadenin (void expression) değeri olmaz. void ifade, void metot çağrısına ilişkin ifadedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metoların parametre değişkenleri: Metot bildiriminde parantezler arasında bildirilen değişkenlere denir. Metot 
	parametre değişkenlerinin faaliyet alanı (scope) metot boyuncadır. Bu anlamda faaliyet alanı bakımından metodun 
	başında bildirilmiş yerel değişkenler gibidir. Metot çağrısında, metodun parametrelerine geçilen ifadelere 
	argüman (argument) denir. Bir metodun kaç tane parametresi varsa o kadar sayıda argüman ile çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		Sample.foo(a, b);
	}
}


class Sample {	
	public static void foo(int a, double b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Parametre değişkenleri aynı türden bile olsa bildirimde tür yazılmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {	
	public static void foo(int a, b) //error
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metoda geçilen argümanlara ilişkin ifadeler önce hesaplanır, elde edilen değerler ilgili parametre değişkenlerine
	aktarılarak metot çağrılır. Yani aslında aşağıdaki örnekte foo metoduna argüman olarak geçilen değerler ilgili ifadelerin
	değerleridir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		Sample.foo(a + 1, b * 3);		
	}
}


class Sample {	
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte add metodunun geri dönüş değeri println metoduna argüman olarak geçilmiştir. Bu da aslında bir önceki
	kuralın bir sonucudur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a + 2, b * 3));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki gibi ifadelerin yazımında okunabilirlik/algılanabilirlik olumsuz yönde etkileniyorsa,
	compact yazım tercih edilmemelidir. Ya da başka bir deyişle compact ifadeler okunabilir/algılanabilir olması 
	durumunda yazılmalıdır. 	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile *** arasındaki kodlarda a ve b değişkenlerinin değerleri değişmediğinden add metodu iki
	defa gereksiz yere çağrılmıştır. Çünkü her iki durumda da aynı sonuç elde edilecektir. Bu durumda metodun gereksiz
	yere çağrılması maliyeti dışında, kodun okunabilirliği açısından da olumsuz bir durum söz konusudur. Çünkü bu kodu 
	okuyan kişi, add çağrısını iki kere gördüğünde ** ve *** arasındaki kodlarda a ve/veya b değişkenlerinin değerlerinin
	değiştiğini algılar.  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo aşağıdaki gibi daha okunabilir/algılanabilir ve görece daha az maliyetli olarak yazılabilir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		int result = NumberUtil.add(a, b);
		
		System.out.println(result); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(result); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodu yeni a değeri için de çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();	
		
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... 
		
		a = a * 2;
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun parametre değişkenleri aslında o metodun girdileridi (input). Bu anlamda metot parametre
	değişkenleri ile aldığı girdilerin nasıl elde edildiğinden bağımsız çalışır. Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
		
	ve
		public static int add()
		{
			java.util.Scanner kb = new java.util.Scanner(System.in);
			System.out.println("İki sayı giriniz:");
			int a = kb.nextInt();
			int b = kb.nextInt();
			int result = a + b;		
			
			return result;
		}
	metotları için parametreli add metodu toplayacağı değerlerin nereden geldiğini ve nasıl elde edildiğini bilmez.
	parametresiz add metodu ise değerleri klavyeden elde eder. Bu anlamda parametreli add metodu daha genel yazılmıştır. 
	Bir metodun geri dönüş değeri de o metodun çıktısıdır (output). Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
	ve
		public static void printTotal(int a, int b)
		{
			System.out.println(a + b);
		} 
		
	metotları için add metodu elde edilen değeri çıktı olarak verdiğinden toplam değerinin kullanılması anlamında genel
	yazılmıştır. Buradaki örnekler karşılaştırma amaçlı yazılmıştır. Bir metot diğerinden daha iyidir anlamı çıkartılmamalıdır.
	Hangisinin gerekeceği yazılan uygulamaya göre şüphesiz değişebilir.
	
	Anahtar Notlar: Bir metodun geri dönüş değeri olması ya da olmaması ve parametre değişkeni olması ya da olmaması
	birbiriyle doğrundan doğrudan ilişkili değildir. Şüphesiz dolaylı bir ilişki vardır. Bu anlamda geri dönüş değeri ve 
	parametre değişkenleri anlamında bir metot aşağıdakilerden biri biçiminde olabilir:
		1. Geri dönüş değeri var, parametre veya parametreleri var
		2. Geri dönüş değeri var, parametresi yok
		3. Geri dönüş değeri yok, parametre veya parametreleri var
		4. Geri dönüş değeri yok, parametresi yok	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da atama işlemi 3 yerde yapılır:
	- Atama operatörü (işlemli atama operatörleri dahil) ile. Initialization işlemi de bu gruba sokulabilir.
	- Bir metodun geri dönüş değerinin geçici değişkene aktarılması
	- Metot çağrısında, argümanların parametre değişkenlerine aktarılması
	
	İstisna bazı durumlar dışında atama operatörü ile ilgili kuralların hepsi, diğer iki atama için de geçerlidir. İstisna
	durumlar konular içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	27.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Neden metot yazalım? Yani, programcının uygulamayı geliştirirken çeşitli metotları yazması ne gibi bir avatajlar 
	sağlar? Aslında bu sorulara tek bir cümle ile cevap verilemez. Bu avantajlar genel olarak şu şekilde belirtilebilir: 
	- Bir metodun yaptığı işin detayları yani kabaca nasıl yaptığı, çağıran tarafından bilinmek zorunda değildir. Bu anlamda
	metot aslında, metodu çağrıdan programcıdan detayları gizlemiş olur.
	
	- Bir metodun yaptığı iş başka konuları da bilmeyi gerektirebilir. Ancak kullanan açısından bu durum önemsiz olabilir. 
	Örneğin bir sayının asal olup olmadığının anlaşılması konusu, asal sayı üretirken kullanılır ancak birbirlerinden 
	algoritmik olarak bağımsızdır. Bu durumda asal sayı üreten bir programcı, elinde sayının asal olup olmadığını test 
	etmek için kullanılan bir metodu çağırarak, sayının asal olup olmadığının nasıl anlaşılacağından bağımsız kod yazabilir.
	
	- Metot çağrılması okunabilirliği/algılanabilirliği artırır
	
	- Bir algoritma akış içerisinde bir çok yerde yazılmak isteneblir. Örneğin, bir sayının faktoriyel değerini bulan
	bir kod akış içerisinde bir çok yerde gerekebilir. Programcı bu kodu gereken her yerde yazarsa bu durumda hata yapma
	olasılığı artar. Aynı zamanda kodunda bir hata yaptığını farkederse veya kodda değişiklik yapmak isterse bunu yazdığı
	her yerde yapmak zorunda kalır. Bu da görece karmaşık bir hale getirebilir. İşte bu durumda programcı bir metot yazar
	ve gereken her yerde o metodu çağırırsa hata yapma olasılığı azalır, hata yaptığını anladığında veya bir değişiklik 
	gerektiğinde sadece metotta bu değişiklik yapılır. Bu da daha kolay ve çabuk bir biçimde yapılmasını sağlar. 
	
	- Uzun bir kodu bir çok yerde yazmak byte code'u büyütebilir. Ancak metot yazılıp çağrıldığında bu durum oluşmaz
	
	- Bir kodu metot olarak yazmak, o koda ilişkin test işlemlerini yaparak olası programlama hatalarının daha kolay
	belirlenebilmesini ve dolayısıyla daha kolay düzeltilmesini sağlar
	
	Anahtar Notlar: Buradaki maddelerinin hiç birisi birbirinden daha az önemli değildir.
	
	Anahtar Notlar: Programlamada en temel prensip kod tekrarından mümkün olduğunca kaçınmaktır. Yani, aynı işi yapan bir 
	kodu tekrar yazmak ZORUNLU OLMADIKÇA iyi bir teknik değildir. Bu kavrama programlamada "DO NOT REPEAT YOURSELF (DRY)" de 
	denilmektedir. İşte bu tekrarlamanın en yalın yöntemi metot yazmaktır ve çağırmaktır. Ayrıca ileride Nesne Yönelimli
	Programlama tekniğine ilişkin kavramlarla birlikte DRY çok daha etkin bir biçimde yapılabilmektedir.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu formatlı yazdırmak için kullanılan çok temel bir metottur. Bu metodun birinci parametresine
	argüman olarak bir yazı (bir String literal olabilir) geçilmelidir. Bu metot değişken sayıda argüman ile (vararg) 
	çağrılabilen bir metottur. Bu metodun diğer parametrelerinde herhangi bir türden argüman geçilebilir. Birinci parametre
	geçilen argümana ilişkin yazıda % karakteri ile birlikte özel bazı karakterler (format characters/specifiers) 
	yer tutucu (placeholder) olarak kullanılır. Örneğin n format karakteri imleci bir sonraki satırın başına geçirir. Bu 
	metot ileride göreceğimiz bazı metotlarla da aynı sistematik ile çalışır. printf metodunda format karakterlerin yer 
	tutucu dışında anlamı vardır. Bu anlamda bu metodu tanımak programcı açısından önemlidir. Örnek bir kullanım aşağıda 
	verilmiştir. Detaylar şu an önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bugün ve yarınki tahmini hava sıcaklığını giriniz:");
		int today = kb.nextInt();
		int tomorrow = kb.nextInt();
		
		System.out.printf("Bugün hava %d derece. Yarın %d derece olacak%n", today, tomorrow);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türden bir değeri decimal olarak formatlamak için d format karakteri kullanılır, hexadecimal olarak formatlamak
	için x (küçük veya büyük) format karakteri kullanılır, octal formatlamak için o format karakteri kullanılır. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%na = %x%na = %X%na = %o%n", a, a, a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerinin formatlanmasında % ile format karakteri arasına sıfır dışında pozitif bir sayı hizalama (alignment)
	anlamına gelir. Eğer sayının başına sıfır da yazılırsa basılacak karakterler hizalanacak sayıdan küçükse başına sıfır
	eklenir. Eğer sıfır yazılmazsa space karakteri eklenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %02d%na = %08X%n", a, a);
		System.out.printf("a = %2d%na = %8X%n", a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Gün, Ay ve Yıl bilgilerini giriniz:");
		int day = kb.nextInt();
		int month = kb.nextInt();
		int year = kb.nextInt();
		
		System.out.printf("%02d/%02d/%04d%n", day, month, year);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayıların formatlanmasında f format karakteri kullanılır. f format karakteri noktadan sonraki basamak sayısını
	default olarak belirli bir sayıda basamak kadar alır. Bu sayı doğrudan belirtilmemiş olsa da pek çok sistemde 6 dır.
	Geri kalan basamaklar bilimsel yuvarlama yöntemiyle yuvarlanır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayılarda noktadan sonra istenilen sayıda basamağın formatlanması için % ile f karakteri arasında . (nokta)
	ve negatif olmayan bir sayı yazılır. Bu durumda sayı o kadar sayıda basamak olarak formatlanmış olur. Geri kalan
	basamaklar yine yuvarlanarak atılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %.2f, b = %.2f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türünün için c format karakteri kullanılır. Bu durumda char türü içerisinde tutulan sayıya karşılık gelen
	karakter formatlanmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = 68;
		
		System.out.printf("c = %c%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	boolean türünün için b format karakteri kullanılır. Bu durumda boolean türüne ilişkin değerin (true veya false) yazısal
	karşılığı ile formatlama yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		boolean flag1 = true;
		boolean flag2 = false;
		
		System.out.printf("flag1 = %b, flag2 = %b%n", flag1, flag2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda kullanılan format karakteri geçilen argümanın türünden farklı ise bu durumda genel olarak exception 
	oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda s format karakteri ile her tür formatlanabilir. Tabii bu durumda türe özgü bazı formatlama biçimleri
	kullanılamaz. s format karakteri ile bu işlemin nasıl yapıldığı ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.printf("a = %s, b = %s%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu ile tamamen aynı işi yapan System.out.format isimli bir metot da vardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.format("a = %d, b = %.20f%n", a, b);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: printf (ve format) metodu için başka format karakterleri ve format karakterlerine özgü başka 
	detaylar da vardır. Bunlar zaman içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden girilen iki tam sayının toplamını, çarpımını ve farkını açıklamalara göre ekrana bastıran
	programı yazınız: 
	Açıklamalar:
		- Girilen sayılar 10 ve 20 olsun. Ekran çıktısı şu şekilde olacaktır:
		  	10 + 20 = 30
		  	10 * 20 = 200
		  	10 - 20 = -10
		- Ekrana formatlı yazdırmak için printf metodunu kullanınız 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		OperationApp.run();
	}
}

class OperationApp {
	public static void printResult(int a, int b)
	{
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		System.out.printf("%d - %d = %d%n", a, b, NumberUtil.subtract(a, b));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		printResult(a, b);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
	
	public static int subtract(int a, int b)
	{
		return a - b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	JavaSE'de de bir çok sınıf ve bir çok metot vardır. Ayrıca programcı geliştirme sırasında kullandığı kütüphane ve 
	ortamlarda da (framework) pek çok sınıf ve metot bulunur. Peki programcı bir konuya ilişkin metodu ne zaman 
	yazmaya karar vermelidir? Yani başka bir deyişle JavaSE ya da diğer kullanılan ortam ve kütüphanelerde ilgili
	işlemi yapan sınıflar ya da metotlar programcı kendisi yazmalı mıdır? Programcı önce JavaSE'de ilgili işlemi yapan
	sınıfları ve metotları tercih etmelidir. Eğer işlemi yapan sınıf veya metot JavaSE'de yoksa, kullandığı kütüphane veya
	ortamda varsa onu tercih etmelidir. Eğer burada da yoksa kendisi yazmalı veya bu konuda yine iyi yazılmış olan bir 
	kütüphaneninkini varsa kullanmalıdır. Programcı kendi yazacağı metodu mutlaka test eder ve ona göre kodunu iyileştirir.
	Bununla birlikte Java programcısı zaman içerisinde (bu hemen olmayabilir) hepsini olmasa da kullandığı sınıfları ve
	metotları yazabilmeyi öğrenmelidir. Ancak, bir uygulama geliştirirken var olanları kullanmalıdır. Bu anlamda her şey
	de hazır değildir. Programcı da pek çok sınıf ve metot yazar.
	
	Peki, JavaSE'de ya da kullanılan ortamlar ve kütüphanelerdeki metotları kullanmanın avantajları nelerdir?
	- Okunabilirlik/algılanabilirlik
	
	- Kodun taşınabilirliğini sağlar. Özellikle JavaSE'deki bir metodun kod içerisinde çağrılması durumunda, o kod her ortama
	taşınabilir ve kodu derlenmesi için ektra bir işlem yapmaya gerek kalmaz
	
	- Bu metotlar zaman içerisinde test edildiği ve iyileştirildiği için uygun çalışması anlamında güvenilirdir
	 
	- JavaSE'den kullanılan bir metot veya sınıf için derleyici daha etkin kodlar üretebilir.
	
	- Programcının yalnızca kendi konusuna odaklanmasını sağlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının PI ve E veri elemanları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	02.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	İki tam sayı bölme işlemine sokulduğunda bölümün noktadan sonraki kısmı atılır. Ayrıca iki tamsayı bölme işlemine
	sokulduğunda bölen yani payda sıfır ise exception oluşur. Yani tamsayılar ile bölme işlemi paydanın sıfır olması
	durumunda yapılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki gerçek sayı bölme işlemine sokulduğunda bölünenin (payın) sıfır dışı bir değer, bölenin (paydanın) sıfır olması
	durumunda +-Infinity, payın da sıfır olması durumunda NaN (Not a number) değeri elde edilir. IEEE 754 standardına göre 
	gerçek sayılar kümesinde gerçek sayılar dışında özel bazı değerler vardır. İşte Infinity ve NaN değerleri de bunlardan
	ikisidir. Aşağıdaki örneği çeşitli değerler içinm çalıştırıp sonuc-çları gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);				
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Math sınıfının metotları matematiksel olarak geçersiz olan argümanlar için genel olarak exception
	oluşturmazlar. Duruma göre NaN, Infinity gibi özel değerlere geri dönerler 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının karakök alan sqrt metodu. Metot argümanın negatif olması durumunda NaN değerine geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının karakök alan sqrt metodu. Metot argümanın negatif olması durumunda NaN değerine geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının abs metotları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf içerisinde aynı isimde birden fazla metot bildirilmesi durumunda "method overloading"
	denir. Method overloading konusu ileride detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının pow metodu 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("pow(%f, %f) = %f%n", a, b, Math.pow(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı 2 noktanın koordinat bilgilerine göre aralarındaki uzaklığa geri dönen
	distance isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void printDistance(double x1, double y1, double x2, double y2)
	{
		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki noktanın koordinatlarını giriniz");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		printDistance(x1, y1, x2, y2);
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı 2 noktanın koordinat bilgilerine göre aralarındaki uzaklığa geri dönen
	distance isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void printDistance(double x1, double y1, double x2, double y2)
	{
		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki noktanın koordinatlarını giriniz");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		printDistance(x1, y1, x2, y2);
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("min(%f, %f) = %f%n", a, b, Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n", a, b, Math.max(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 3 tane sayının en büyüğü ve en küçüğü bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		System.out.printf("min(%f, %f, %f) = %f%n", a, b, c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n", a, b, c, Math.max(Math.max(a, b), c));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının logaritma işlemi yapan metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();	
		
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının yuvarlama işlemi yapan önemli metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();	
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));		
		System.out.printf("rint(%f) = %f%n", a, Math.rint(a));
		System.out.printf("ceil(%f) = %f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %f%n", a, Math.floor(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Math sınıfında yukarıdaki metotlar dışında da pek çok metot bulunmaktadır. Bunlar genel olarak
	spesifik durumlarda ihtiyaç olan metotlardır. Gerektiğinde dokümantasyondan öğrenilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sabit İfadesi (constant expression): Yalnızca sabitlerden ve operatörlerden oluşan ifadelere denir. Sabitler de 
	tek başına bir sabit ifadesidir. 
	
	Anahtar Notlar: İleride aslında bir sabit olarak ele alınan değişken bildirimleri de yapılabileceğini göreceğiz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sabitler (Literals/Constants): Program içerisinde doğrudan yazılan sayılara denir.  Sabitlerin de türleri vardır. 
	Yani derleyici yazılan sabitin türüne göre işlem yapar. Sabitlerin türlerine ilişkin detaylar şu şekildedir:
	- Sayı nokta içermiyorsa VE sonuna herhangi bir ek almamışsa VE int türü sınırları içerisindeyse int türdendir. int
	türü sınırları dışında ise error oluşur. Örneğin: 10, 20, 45
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa (bu ek sayıya bitişik olarak yazılmalıdır)
	long türdendir. Sayı long türü sınırları dışında ise error oluşur.. Örneğin: 10L, 20000L 
	Anahtar Notlar: Küçük harf L karakteri sayının sonuna getirildiğinde bazı yazı tiplerinde 1 (bir) rakamı ile 
	karıştırılabileceğinden okunabilirlik açısından küçük harf L son ekinin kullanımı tavsiye edilmez
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve herhangi bir sonek almamışsa ve sınırlar içerisindeyse double türdendir. Örneğin: 3.4, 9.28759
	
	- Sayı nokta içersinde ya da içermesin sonuna D (küçük veya büyük) ekini almışsa double türdendir. Örneğin: 10D, 3.45d
	
	- Sayı nokta içersin ya da içermesin sonuna F (küçük veya büyük) ekini almışsa float türden. Sayının ondalık kısmı
	varsa F eki ile yuvarlama hataları oluşabilir. Örneğin: 3.4F, 8f
	
	- boolean türden iki tane sabit vardır: true, false
	
	- Tek tırnak içerisinde yazılan bir karakter, o karakterin karakter tablosundaki sıra numarasına karşılık gelir.
	Örneğin, 'Ş', 'D' gibi. Tek tırnak içerisinde özel bazı durumlar dışında yalnızca bir tane karakter yazılabilir. Bazı
	karakterlerin doğrudan sembol karşılığı yoktur. Bu karakterlere "escape sequence" karakterler denir. Bu karakterler
	için karakter sabitleri ters bölü ile birlikte özel bir karakter kullanılarak yazılır. Java'da desteklenen escape
	sequence karakterler şunlardır:
	
	'\n' -> Line Feed (LF)
	'\r' -> Carriage Return (CR)
	'\t' -> Horizontal Tab
	'\'' -> Single quote	
	'\"' -> Double quote (optional)
	'\0' -> null character
	'\\' -> back slash
	'\f' -> form feed
	'\b' -> backspace
	
	Peki, klavyemizin desteklemediği bir karakteri karakter sabiti olarak yazmanın yolu var mıdır? Sıra numarası doğrudan
	yazılabilir ya da çok kullanılan bir teknik olarak ters bölü ve u ile birlikte yazılabilir. Örneğin: '\u00C6'. Burada
	hexadecimal değer kesinlikle iki byte olarak yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	LF karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c;
		
		c = '\n';
		
		System.out.print("Merhaba");
		System.out.print(c);
		System.out.print("Nasılsın");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Eclipse ve IntelliJ gibi bazı IDE'ler işletim sisteminin console'unu doğrudan kullanmazlar. Kendi 
	console'ları da vardır. Bazı durumlarda bu console programın çalıştırıldığı sistemin console'undan farklı davranabilirler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	CR karakter sabiti. Aşağıdaki örneği işletim sisteminizin console'unda çalıştırıp sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c;
		
		c = '\r';
		
		System.out.print("Merhaba");
		System.out.print(c);
		System.out.print("Ali");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Escape sequence karakterler string literal içerisinde kendi anlamlarında kullanılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Merhaba\rAli");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakterinin karakter sabiti ters bölü ile yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = '\'';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakteri string literal içerisinde iki şekilde kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("'Ankara'");
		System.out.println("\'Ankara\'");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakterinin sabiti iki şekilde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c1 = '\"';
		char c2 = '"';
		
		System.out.println(c1);
		System.out.println(c2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakteri string literal içerisinde ters bölü ile kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("\"Ankara\"");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü karakter sabiti de ters bölü ile kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = '\\';
		
		System.out.println(c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte escape sequence karakterler kullanıldığından çıktı C:\test\names.txt biçiminde olmaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\test\names.txt");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte ters bölü karakterinin çıkartılması için ili tane ters bölü kullanılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\\test\\names.txt");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ters bölü karakterinden sonra uygun bir karakter gelmediğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\deneme\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\\deneme\\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Backspace karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("Merhaba\bAli");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Backtick karakter sabiti. Bu karakterin çok özel bir anlamı yoktur. Tek tırnak karakterine benzerliği dolayısıyla
	burada örnek olarak gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char c = '`';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir karakterin sıra numarası ters bölü ve u ile birlikte hexadecimal olarak da verilebilmektedir. Bu durumda ilgili
	karakterin sıra numarası alınmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char c = '\u00C6';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	03.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir karakterin ters bölü u ile kullanımı string literal'larda da geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("Karakter:\u00C6");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aslında ters bölü u kullanımı değişken isimlendirmede de geçerlidir. Değişken isimlendirmede bir convention olarak
	hep İnglizce alfabedeki karakterleri kullandığımızdan böyle bir isimlendirmeye ihtiyacımız olmaz. Ancak bazı mülakatlarda
	sorulabildiği için bilmeniz önerilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int \u00c6x;
		
		\u00c6x = 10;
		
		System.out.println(\u00c6x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aslında ters bölü u kullanımı değişken isimlendirmede de geçerlidir. Değişken isimlendirmede bir convention olarak
	hep İnglizce alfabedeki karakterleri kullandığımızdan böyle bir isimlendirmeye ihtiyacımız olmaz. Ancak bazı mülakatlarda
	sorulabildiği için bilmeniz önerilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int \u0041\u0042\u0043;
		
		ABC = 10;
		
		System.out.println(ABC);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı sabitleri çeşitli sistemlerde gösterilebilirler. Tamsayı sabiti doğrudan yazıldığında decimal olarak 
	gösterilmiş olur. Sabitin başına 0x (x küçük veya büyük olabilir) bitişik olarak yazıldığında sabit artık hexadecimal
	olarak yazılabilir. Sabitin başına 0(sıfır) bitişik olarak yazıldığında artık octal olarak yazılabilir. Java 7 ile 
	birlikte sabitin başına 0b (b küçük veya büyük olabilir) bitişik olarak yazıldığında artık binary olarak yazılabilir.
	Sabit hangi sistemine göre yazılıyorsa, o sayı sisteminin dışında kalan basamak değerleri kullanımı error oluşturur.
	Octal sistem nadir kullanılsa da programcı sayının başına yanlışlıkla sıfır koymamalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10;
		int b = 0xA;
		int c = 012;
		int d = 0b1010; // Since Java 7
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
		System.out.printf("d = %d%n", d);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki out metodunu, pinlerden oluşan bir sistemin pinlerini aktif veya pasif (5 volt veya 0 colt) hale getirmek 
	için parametresi ile değerin bitlerine göre işlem yaptığını varsayınız. Bu durumda ilgili değeri sabit olarak vermek 
	istediğimizde hexadecimal veya binary gösterimin daha okunabilir/algılanabilir olduğuna dikkat ediniz. Örnek durumu
	göstermek için yazılmıştır. Burada binary gösterim daha anlaşılır olsa da bit sayısı arttığında hexadecimal gösterim 
	değeri daha basitleştirebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		PinIOUtil.out(8128);
		PinIOUtil.out(0x1FC0);
		PinIOUtil.out(0b0001111111000000);
	}
}

class PinIOUtil {
	public static void out(int val)
	{
		System.out.printf("val = %d%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02E23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02E+23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02e+23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double val = 6.02e-23;
		
		System.out.println(val);
		System.out.printf("%.30f%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte sabitlerin herhangi iki basamağı arasında istenildiği sayıda alttire karakteri kullanılabilmektedir.
	Sabitlerde _ kullanımı okunabilirliği artırmak amacıyla dile eklenmiştir. Programcı da mantıksal olarak uygun yere 
	alttire karakterini yerleştirmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		long a = 4_000_000_000L;
		double b = 2_567.234_567;
		int c = 0b0001_1111_1100_0000;
		int d = 0x1F_C0;
		
		System.out.println(a);
		System.out.println(b);
		System.out.println(c);
		System.out.println(d);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Alttire karakteri istenilen sayıda kullanılabilir. Şüphesiz okunabilirliğin olumsuz etkilenmemesine dikkat edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 1______________________________________________0;
		
		System.out.println(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Alttire karakteri yalnızca iki basamak arasında geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = 10._45; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurala istisna olarak octal sabitlerde sıfır ile sayının ilk basamağı arasında alttire kullanımı 
	geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0_12;
		
		System.out.println(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir gerçek sayı sabitinin noktadan önceki değeri (yani tamsayı kısmı) sıfır ise, sıfır yazılmayabilir. Benzer şekilde
	sayının noktadan sonraki değeri (yani ondalık kısmı) sıfır ise yine sıfır yazılmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = .2;
		double b = 2.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel Operatörler: Belirli bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör (operator) denir.
	Java'da çok fazla operatör vardır. Bu bölümde temel operatörler ele alınacaktır. Konular içerisinde diğer operatörler de
	incelenecektir. Bir operatör ile işleme giren ifadelere operand denir. Bir operatör için aşağıdakilerin bilinmesi gerekir:
	- Operatörün hangi sınıfta olduğu
		- İşlevlerine göre sınıflandırma
			- Aritmetik operatörler (arithmetic operators)			
			- Karşılaştırma operatörler (comparison operators)
			- Mantıksal operatörler (logical operators)
			- Bitsel operatörler (bitwise operators)
			- Özel amaçlı operatörler (special purpose operators)
		- Operand sayısına göre sınıflandırma
		  	- Tek operandlı (unary)
		  	- İki operandlı (binary)
		  	- Üç operandlı (ternary)
		- Operatörün operandına göre konumu
			- Ön ek (prefix)
			- Ara ek (infix)
			- Son ek (postfix)
			
	- Operatörün kısıtı (constraint): Bu operatörün kullanılabilmesi için özel şartlar var mı
	
	- Operatörün ürettiği değer (product value)
	
	- Operatörün önceliği (precedence): Operatörün genel olarak ifade içerisinde işleme girme sırası. Örneğin:
		a = b + c * d 
	ifadesinde derleyicinin ürettiği koda ilişkin işlem sırası şu şekildedir:
		i1: c * d
		i2: b + i1
		i3: a = i2
		
		a = (b + c) * d
	ifadesinde derleyicinin ürettiği koda ilişkin işlem sırası şu şekildedir:
		i1: b + c
		i2: i1 * d
		i3: a = i2
		
	- Operatörün yan etkisi (side effect) var mı? Operatör operandına ilişkin değeri değiştiriyor mu? 
	
	Anahtar Notlar: Bazı operatörler operatör önceliğine doğrudan uymazlar. Bu anlamda operatör önceliği ile işleme 
	girme sırası değişiklik gösterebilir. Bu tarz operatörler ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aritmetik 4 işlem operatörleri: +, -, *, /
	Bu operatörler iki operandlı (binary) ve araek (infix) durumda operatörlerdir. İlgili işleme sokulabilecek operandlar
	için geçerlidir. Operatörler operandlarına ilişkin değerlerin ilgili işleme sokulduktan sonraki değerini üretirler. 
	Bu operatörlerin yan etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Mod (%) aritmetik operatörü iki operandlı araek durumunda bir operatördür. Ürettiği değer mod işlemine ilişkin değerdir.
	Operatörün yan etkisi yoktur. Çarpma ve bölme operatörleri ile aynı öncelik seviyesindededir. Operatörün kısıtı 
	çarpma ve bölme operatörleri ile aynıdır. Bu operatörm gerçek sayı türleri için de kullanılabilir.
	
	Bu operatörün ikinci operandının negatif olmasının bir önemi yoktur. Pozitif olarak işlem yapılır. Birinci
	operandının işareti sonucun işaretini belirler. İşlem yapılırken birinci operand negatif ise pozitif olarak
	işlem yapılır ve elde edilen değerin ters işaretlisi üretilir. Örneğin 10 % 3 işleminin sonucu 1'dir, -10 % 3 
	işleminin sonucu -1'dir. Benzer şekilde 10 % -3 işleminin sonucu da 1, -10 % -3 işleminin sonucu da -1'dir. Yani
	negatif sayılar için Matematikteki mod işlemi ile aynı şekilde sonuç üretmez. Bu bu operatörün çalışma biçimidir.
	Yanlış çalıştığı anlamına gelmez. Bu şekilde çalışma pratikte programcının daha çok işine yarar. Örneklerle
	ele alacağız
	
	Anahtar Notlar: printf metodunda yazıda % karakterinin çıkartılabilmesi için iki tane % karakteri bitişik olarak
	kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d %%  %d = %d%n", a, b, a % b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 basamaklı bir sayının basamakları toplamına geri dönen 
	sum3DigitsNumber metodunu yazınız ve test ediniz.
	Açıklamalar: 
		- Metot sayının 3 basamaklı olup olmadığı kontrolünü yapmayacaktır
		- Sayı negatif ise basamakları toplamı pozitif olarak döndürülecektir  
		
	Aşağıdaki örnekte % operatörünün negatif sayılar için çalışma biçimi örnek açısından programcı için uygundur. % 
	operatörü Matematik'teki gibi çalışsaydı aşağıdaki metot negatif sayılar için yanlış çalışacaktı. Bu durumda programcı
	metodu farklı bir şekilde yazmak zorunda kalacaktı. / ve % operatörleri aynı seviyededir. O seviyedeki operatörlerin
	aynı ifadede bulunması durumunda işlem soldan sağa (left associative) olarak yapılır. Bu sebeple onlar basamağı
	bulunurken herhangi önceliklendirme yapılmazı yani parantez kullanılması gerekmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		Sum3DigitsTest.run();		
	}
}

class Sum3DigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", val, Util.sum3DigitsNumber(val));
	}
}

class Util {
	public static int sum3DigitsNumber(int val)
	{
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10; //val % 100 / 10;
		c = val % 10;
		
		return Math.abs(a + b + c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi 
	yoktur. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatör 2. seviyede bir operatördür. Bu 
	seviyedeki operatörler sağdan sola önceliklidir (right associative). Operatör operandına ilişkin ifadenin değerinin
	ters işaretlisini üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi 
	yoktur. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatör 2. seviyede bir operatördür. 
	Operatör operandına ilişkin ifadenin değerinin aynısını üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da negatif bir sabit doğrudan yoktur. Pozitif bir sabite işaret eksi operatörü uygulandığında negatif olur. Örneğin
	-2 yazıldığında 2 sabitine işaret - operatörü uygulandığında elde edilen değer üretilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a;
		
		a = -2;
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte işaret - operatörü sağdan sola öncelikli olduğundan herhangi bir problem oluşmaz. Örneği çalıştırıp
	sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a;
		
		a = - - - - - - - - - - - - - - - - - - -  -2;
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = - - - - - - - - - - - - - - - - -  - - - - - - - - - -a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c;
		
		c = a - - - - - - - - - - - - - - - - -  - - - - - - - - - -b;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ aritmetik operatörü tek operandlı, önek ve sonek durumunda kullanılabilen bir operatördür. Bu operatörün operandı
	bir değişken olmalıdır. Operatör operandı olan değişkenin değerini 1 artırır. Dolayısıyla operatörün yan etkisi
	vardır. Operatör 2. seviyede bir operatördür.  Operatör önek veya son olarak nasıl kullanılırsa kullanılsın operandına
	ilişkin değeri 1 artırır. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatörün ürettiği 
	değer yani işleme giren değer önek ve sonek kullanımına göre farklılık  gösterir. Bu durum ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü nasıl kullanılırsa kullanılsın operandına ilişkin değeri 1 artırır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%n", a);
		
		++a; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
		
		a++; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü prefix olarak kullanıldığında ürettiği değer yani işleme giren değer artırılmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = ++a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü postfix olarak kullanıldığında ürettiği değer yani işleme giren değer artırılMAmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a++;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- aritmetik operatörü tek operandlı, önek ve sonek durumunda kullanılabilen bir operatördür. Bu operatörün operandı
	bir değişken olmalıdır. Operatör operandı olan değişkenin değerini 1 azaltır. Dolayısıyla operatörün yan etkisi
	vardır. Operatör 2. seviyede bir operatördür.  Operatör önek veya son olarak nasıl kullanılırsa kullanılsın operandına
	ilişkin değeri 1 azaltır. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatörün ürettiği 
	değer yani işleme giren değer önek ve sonek kullanımına göre farklılık  gösterir. Bu durum ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü nasıl kullanılırsa kullanılsın operandına ilişkin değeri 1 azaltır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%n", a);
		
		--a; //a = a - 1;
		
		System.out.printf("a = %d%n", a);
		
		a--; //a = a - 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü prefix olarak kullanıldığında ürettiği değer yani işleme giren değer azaltılmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = --a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü postfix olarak kullanıldığında ürettiği değer yani işleme giren değer azaltılMAmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a--;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: İki operandlı operatörler için bazı özel operatörler dışında operanlar arasında bir ve yalnız bir tane
	space karakteri koyacağız. Tek operandlı operatörleri genel olarak operandına bitişik olarak yazacağız 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = ++a * 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a++ * 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	09.09.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici soldan sağa ve yukarıdan aşağıya doğru anlamlı en uzun ifadeyi ele alacak şekilde parsing işlemini yapar.
	Bu kurala "maximal munch" da denilmektedir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a+++b; //a++ + b		
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 3, b = 5, c = 7
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a++b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a++++b; //error		
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a+++-b;		
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 3, b = 5, c = -3
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;	
		
		a = a++;
		
		System.out.printf("a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;	
		
		a = ++a;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b;
		
		b = a++ + a;
		
		System.out.printf("a = %d, b = %d%n", a, b); //a = 3, b = 5
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++a + ++b * a--;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 15 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++b * a-- + ++a;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 10
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++b * a-- + ++a;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 10 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel karşılaştırma operatörleri 6 tanedir: <, >, <=, >=, ==, !=. Bu operatörler iki operandlı ve araek durumundadır.
	Bu operatörlerin yan etkisi yoktur. Bu operatörlerin temel türler açısından operandının boolean türünden olmaması 
	gerektiği dışında bir kısıtı yoktur. Bu operatörlerin ürettiği değer karşılaştırmanın sonucuna göre boolean türdendir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d < %d = %b%n", a, b, a < b);
		System.out.printf("%d > %d = %b%n", a, b, a > b);
		System.out.printf("%d <= %d = %b%n", a, b, a <= b);
		System.out.printf("%d >= %d = %b%n", a, b, a >= b);
		System.out.printf("%d == %d = %b%n", a, b, a == b);
		System.out.printf("%d != %d = %b%n", a, b, a != b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte boolean ile int türü karşılaştırması geçersiz olacağından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10, b = 20, c = 30;

		
		System.out.println(a < b < c);	//error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Mantıksal operatörler (logical operators) 3 tanedir: Logical AND (&&), logical OR (||), logical NOT (!).
	&& ve || operatörleri iki operandlı araek durumundadır, ! operatörü tek operandlı ve önek durumundadır. Mantıksal
	operatörlerin operandları boolean türden olmak zorundadır. Bu operatörlerin ürettiği değer işlemin sonucuna göre
	boolean türdendir. Bu operatörlerin yan etkisi yoktur.
	
	Mantıksal operatörlerin doğruluk tabloları (truth table):
	
	a 		b		a && b		a || b
	T		T		  T			  T
	T		F		  F			  T
	F		T		  F			  T
	F		F		  F			  F
	
	a		!a
	T		F
	F		T
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	&& operatörü. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() && Sample.bar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	|| operatörü. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() || Sample.foo();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	&& operatörünün kısa devre davranışı (short circuit behavior) . Aşağıdaki örnekte foo metodunun çağrılması sonucu
	etkilemediğinden çağrılmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() && Sample.foo();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	|| operatörünün kısa devre davranışı (short circuit behavior) . Aşağıdaki örnekte bar metodunun çağrılması sonucu
	etkilemediğinden çağrılmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() || Sample.bar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	&& ve || operatörleri doğru sonuca en kısa yoldan hesaplamak isterler. Bunu da kısa devre davranışı ile yaparlar. 
	Derleyici bu operatörlerin kullanıldığı ifadelerde buna yönelik kod üretir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	&& ve || operatörlerine ilişkin ifadelerde işlem önceliği düşünülmeksizin hep soldan başlanarak işlem yapılır. Yani
	bu operatörlerle işlem yapılırken operatör önceliğine uyulmaz. Ancak elde edilen sonuç operatör önceliğine uyulsa
	(yani Matematiksel olarak işlem yapılsa) elde edilecek sonucun aynısı olur. Aşağıdaki örneği inceleyiniz. Metotlar 
	durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte operatör önceliği, işlem yapılış önceliği aynıdır. Bu durumda ona yönelik kod üretilir. Örnekte 
	tar çağrılmadan sonuç elde edilemez. Ancak foo'nunn çağrılmasına gerek yoktur. Metotlar  durumu göstermek aşağıdaki 
	gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() && Sample.foo() || Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	! operatörü operandına ilişkin ifadenin mantıksal tersini üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean flag = false; //Buradaki değerin ne olduğu ve nereden elde edildiğini düşünmeyiniz
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bitwise AND (&) ve bitwise OR (|) operatörleri boolean türü ile kullanıldığında yani operandları boolean türden 
	olduğunda kısa devre davranışı dışında && ve || operatörleri ile aynı biçimde çalışırlar. Yani bu operatörler boolean
	türü ile kullanıldıklarında ne olursa olsun kısa devre olmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	& ve | operatörleri iki tamsayının karşılıklı bitlerini işleme sokarlar ve elde edilen sayıyı üretirler. Örnek durumu
	göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10; //00000000000000000000000000001010 -> 0000000A
		int b = 11; //00000000000000000000000000001011 -> 0000000B
		int c;
		
		c = a & b; //00000000000000000000000000001010 -> 0000000A
		
		System.out.printf("c = %d%n", c);
		
		c = a | b; //00000000000000000000000000001011 -> 0000000B
		
		System.out.printf("c = %d%n", c);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bitsel operatörlerin detayları burada ele alınmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atama operatörü (assignment operator) (=) iki operandlı araek durumundadır. Operatörün birinci operandı değişken
	olmalıdır. Operatörün yan etkisi vardır. Atama operatörü atanmış olan değeri üretir. Atama operatörü sağdan sola
	önceliklidir. Bu sebeple aşağıdaki işlem geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a, b, c;
		
		a = b = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Atama operatörü (assignment operator) (=) iki operandlı araek durumundadır. Operatörün birinci operandı değişken
	olmalıdır. Operatörün yan etkisi vardır. Atama operatörü atanmış olan değeri üretir. Atama operatörü sağdan sola
	önceliklidir. Bu sebeple aşağıdaki işlem geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a, b, c;
		
		a = b = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte, atama operatörünün birinci operandının değişken olması gerektiğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 10;
		
		(a = b) = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte, atama operatörünün birinci operandının değişken olması gerektiğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 34, c = 3;
		
		a = (b = c) = 3;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 34, c = 3;
		
		a = b = (c = 2);
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir grup işlemli atama (compound/augmented assignment) operatörü vardır. Bu operatörlerin genel biçimi şu 
	şekildedir:
	<değişken> <op>= <ifade>
	Örneğin 
	a += b;
	
	Bu operatöler iki operandlı ve araek durumundadır. Bu operatörlerin birinci operandları değişken olmalıdır. Bu 
	opetörlerin çalışme biçimi şu şekildedir:
	
	<değişken> <op>= <ifade> => <değişken> = <değişken> <op> <ifade>
	Örneğin: 
	a += b => a = a + b
	
	İşlemli atama operatörleri de atanmış değeri üretirler
	
	Anahtar Notlar: İşlemli atama operatörleri aslında <değişken> = <değişken> <op> <ifade> işlemini bu şekilde 
	yapmazlar. İleride asıl işlemi ele alacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörleri
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20;
		
		a += 10; //a = a + 10;
		
		System.out.printf("a = %d%n", a);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörleri ifadelerin daha basit yazılması için tercih edilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 20;
		
		a *= b + c; //a = a * (b + c); 
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 20;
		
		a += b += c;  
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	10.09.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metot çağırma operatörü özel amaçlı, iki operandlı araek durumunda bir operatördür. Operatör metot ismini ve metodun
	parametreleri varsa ilgili argümanları alır ve metodun çağrılmasına yol açar. Operatör operatör öncelik tablosunda 
	birinci seviyededir. Operatör eğer void bir metot değilse metodun geri dönüş değerini üretir. Bu anlamda değer
	üretmeyebilecek tek operatördür. void bir metodun çağrısı teknik olarak void bir ifadedir. Mantıksal olarak herhangi 
	bir değer üretmeyen bir ifadedir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Util.add(10, 20) * 2;
		
		System.out.printf("result = %d%n", result);
	}
}

class Util {
	public static int add(int a, int b)
	{
		return a + b;		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da etkisiz ifadeler genel olarak geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10, b = 20;
		
		a + b; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki metot çağrısı her ne kadar metot boş olsa da geçersiz değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		Util.foo();
	}
}

class Util {
	public static void foo()
	{
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Noktalı virgül Java'da sonlandırıcı (terminator) olarak kullanılır. İfadelerin veya bazı deyimlerin sonlandırılması
	için kullanılmaktadır. Java'da başka sonlandırıcı yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda anlatılan operatörler dışında pek çok operatör bulunmaktadır. Bu operatörler ilerdeki konularda ele
	alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Deyimler (Statements): Bir programın çalıştırılabilen parçalarına denir. Yani bir program deyimlerin çalıştırılmasıyla
	çalışır. Java'da deyimler şunlardır:
	1. Basit deyimler (simple statements): Bir ifadenin sonuna noktalı virgül konmasıyla oluşan deyimdir. 
	Örneğin:
		c = a + b;
		System.out.println("Merhaba");
	Basit deyim çalıştırıldığında ilgili ifade hesaplanır. 
	
	2. Bileşik deyimler (compound statments): Bir blok küme parantezleri ile birlikte bileşik deyimdir. Bu anlamda metot 
	gövdesi de bileşik deyimdir. 
	Örneğin:
		{
			int a = 10;
			
			++a;
			
			a += 2;
			{
				//...
			}
		}
	Bileşik deyim çalıştırıldığında blok içerisindeki tüm deyimler yukarıdan aşağıya ya da soldan sağa olmak üzere 
	çalıştırılır.
	
	3. Bildirim deyimleri (declaration stataments): Değişken bildirimine ilişkin deyimlerdir. 
	Örneğin:
		int a;
		int b = 20;
	Bildirim deyimi çalıştırıldığında bellekte yer ayrılır.
	 		
	4. Kontrol deyimleri (control statements): Akışa yön veren yani akışın yönlendirilmesini sağlayan deyimlerdir.
	Örneğin:
		if deyimi
		for döngü deyimi
		for-each döngü deyimi
	Her kontrol deyiminin çalıştırılması kendine özgüdür
	
	5. Boş deyim (empty/null statements): Noktalı virgülün tek başına kullanılmasıyla oluşan deyimdir. Boş deyim
	çalıştırıldığında hiç bir şey yapılmaz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 if deyimi (if statements): if deyimi en temel kontrol deyimlerindendir. if deyimi bir koşulun doğru ya da yanlış
	 olmasına göre akışın yönlendirilmesi için kullanılır. if deyiminin genel biçimi şu şekildedir:
	 if (<koşul ifadesi>)
	 	<deyim>
	 [
	 else
	 	<deyim>
	 ]
	 
	 Koşul ifadesi boolean türden olmak zorundadır. if deyiminin else kısmı olmayabilir. Ancak else bir if deyimine ait
	 olmalıdır. if deyimi varsa else kısmıyla birlikte tek bir deyimdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) 
			System.out.printf("%d çift bir sayıdır%n", a);		
		else
			System.out.printf("%d tek bir sayıdır%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte if deyiminde bileşik deyim kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) {
			System.out.printf("%d çift bir sayıdır%n", a);
			a /= 2;
		}
		else {
			System.out.printf("%d tek bir sayıdır%n", a);
			a *= 2;
		}
		
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) {
			System.out.printf("%d çift bir sayıdır%n", a);
			a /= 2;
		}
		else
			System.out.printf("%d tek bir sayıdır%n", a);
			
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 if deyiminin else kısmı olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0)			
			a /= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 if deyiminde yanlışlıkla noktalı virgül konması durumu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0);		
			a /= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte else'in ait olduğu bir if deyimi olmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0);		
			a /= 2;
		else //error
			a *= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte else ** ilem belirtilen if deyimine ait olur. Buna "dangling else" denir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			if (a % 2 == 0) //**
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);			
		else
			System.out.println("Pozitif sayı girmelisiniz!...");
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki örnek bileşik deyim kullanımı ile düzeltilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0) {
			if (a % 2 == 0)
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);
		}
		else
			System.out.println("Pozitif sayı girmelisiniz!...");
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte bileşik deyim kullanılmasına gerek yoktur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			if (a % 2 == 0) 
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);
			else
				System.out.printf("%d sayısı pozitif bir tek sayıdır%n", a);	
		else
			System.out.println("Pozitif sayı girmelisiniz!...");		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki örnek aşağıdaki gibi daha okunabilir/algılanabilir olarak yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif bir sayı girdiniz:%d%n", a);
		else if (a == 0)
			System.out.println("Sıfır girdiniz");
		else
			System.out.printf("Negatif bir sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte koşullar ayrık olmasına karşın programcı ayrık değilmiş gibi if deyimleri yazmıştır. Bu durumda
	 bir koşul gerçekleştiğinde geri kalan if deyimlerini de boşu boşuna kontrol edecektir. Aynı zamanda ayrık koşulların
	 ayrık değilmiş gibi yazılması okunabilirliği/algılanabilirliği azaltır. Yani aşağıdaki örneğin yukarıdaki gibi else-if
	 biçiminde yazılması iyi bir tekniktir. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif bir sayı girdiniz:%d%n", a);
		if (a == 0)
			System.out.println("Sıfır girdiniz");
		if (a < 0)
			System.out.printf("Negatif bir sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki koşullar ayrık değildir. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 6)
			System.out.printf("%d > 6%n", a);
		if (a > 8)
			System.out.printf("%d > 8%n", a);
		if (a > 11)
			System.out.printf("%d > 11%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 boolean türden ifadelerin if deyiminde == veya != operatörü ile kullanımı iyi bir teknik değildir. Örnek durumu 
	 göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printEvenStatus(a % 2 == 0);		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even) //if (even == true)
			System.out.println("Çift sayı girildi!...");
		else
			System.out.println("Tek sayı girildi!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 boolean türden ifadelerin if deyiminde == veya != operatörü ile kullanımı iyi bir teknik değildir. Örnek durumu 
	 göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printEvenStatus(a % 2 == 0);		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printEvenStatus(boolean even)
	{
		if (!even) //if (even != true)
			System.out.println("Tek sayı girildi!...");
		else
			System.out.println("Çift sayı girildi!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar Notlar: Programlamada bir kontrol işlemi yapan ve duruma göre kontrolün doğru ya da yanlış olduğunu
	 belirleyen yapılara "predicate" denir. Örneğin bir sayının asal olup olmadığını test eden bir metot predicate
	 bir metottur. Java'da bu tarz metotların geri dönüş değerleri boolean türden yapılır ve genel olarak isimlendirilmesinde
	 bir fiil söz konusu değilse is gibi yardımcı fiiller kullanılır. Bir sayının asal sayı olup olmadığını test eden
	 bir metodun ismi isPrime biçiminde belirlenebilir. Eğer işlem bir fiil olarak isimlendirilecekse fiil doğrudan
	 yazılır gerekirse s eki alır. Örneğin bir dosyanın var olup olmadığını test eden bir metodun ismi exists yapılır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki isEven metodunda yazılan if deyiminde else anahtar sözcüğüne gerek yoktur. Çünkü akış return deyimine
	 geldiğinde metot sonlanır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		else
			return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki isEven metodu if deyimiyle aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 isEven metodu % operatörü ile aşağıdaki gibi de yazılabilir. == operatörünün ürettiği değerin boolean türden 
	 olduğunu anımsayınız. isEven metodu % operatörü en iyi aşağıdaki gib yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (!Util.isOdd(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;		
	}
	
	public static boolean isOdd(int a)
	{
		return !isEven(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Sınıf Çalışması: Klavyeden katsayıları girilen ikinci dereceden bir denklemin köklerini bulan programı yazınız
	 Not: İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		QuadraticEquationApp.run();		
	}
}

class QuadraticEquationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Kaysayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		QuadraticEquation.findRoots(a, b, c);		
	}
}

class QuadraticEquation {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4  * a * c;
	}
	
	public static void findRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta > 0) 
			printDifferentRoots(a, b, delta);
		else if (delta == 0)
			printSameRoots(a, b);
		else
			System.out.println("Gerçek kök yok");		
	}
	
	public static void printDifferentRoots(double a, double b, double delta)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1 = (-b + sqrtDelta) / (2 * a);
		double x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		
	}
	
	public static void printSameRoots(double a, double b)
	{
		double x = -b / (2 * a);
		
		System.out.printf("x1 = x2 = %f%n", x);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Sınıf Çalışması: Klavyeden katsayıları girilen ikinci dereceden bir denklemin köklerini bulan programı yazınız
	 Not: İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		QuadraticEquationApp.run();		
	}
}

class QuadraticEquationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Kaysayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		QuadraticEquation.findRoots(a, b, c);		
	}
}

class QuadraticEquation {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4  * a * c;
	}
	
	public static void findRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta >= 0) 
			printRoots(a, b, delta);		
		else
			System.out.println("Gerçek kök yok");		
	}
	
	public static void printRoots(double a, double b, double delta)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1 = (-b + sqrtDelta) / (2 * a);
		double x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	16.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Döngüler (loops): Bir takım işlemlerin yinelemeli olarak yapılmasını sağlayan kontrol deyimleridir. Java'da döngü
	deyimleri şunlardır: 
	1. while döngü deyimleri
		- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
		- Kontrolün sonda yapıldığı whike döngü deyimi (do-while döngüsü)
	2. for döngü deyimi
	3. for-each döngü deyimi (enhanced for loop)
	
	Anahtar Notlar: while döngüsü dendiğinde ilk akla gelen kontrolün başta yapıldığı while döngü deyimidir.
	Biz de "while döngüsü" dediğimizde bunu anlayacağız. Kontrolün sonda yapıldığı while döngü deyimi için  
	"do-while döngüsü" diyeceğiz 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Kontrolün başta yapıldığı while döngü deyiminin (while döngüsü) genel biçimi şu şekildedir:
	
	while (<koşul ifadesi>)
		<deyim>
	
	Burada koşul ifadesi boolen türden olmalıdır. while döngü deyimi parantez içerisindeki koşul doğru olduğu sürece
	yani koşul ifadesi true olduğu sürece yinelenir. Akış while döngüsüne geldiğinde de koşul kontrol edilir, duruma
	göre döngüye hiç girmeyebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde yanlışlıkla noktalı virgül kullanılması durumu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n); {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 1;
		
		while (i <= n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez döngü kalıbı. Bu döngü bir kalıp olarak hatırlanmalıdır. Bazı programcolar bazı
	durumlarda bu döngüyü kullanılırlar. Bu döngü kullanılmasa da programcı tarafından görüldüğünde tanınmalıdır. Ayrıca 
	bu döngüde while parantezi içerisinde kullanılan değişkenin değerinin değiştiğine dikkat ediniz. Döngüden sonra bu
	değişkenin önceki değeri kullanılmak istenirse başka bir değişkende saklanmalıdır
	
	n = 4 olsun 
	Döngü içerisinde n	: 3 -> 2 -> 1 -> 0
	Yineleme sayısı		: 1 -> 2 -> 3 -> 4
	Döngü sonrası n		: -1
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		while (n-- > 0)
			System.out.printf("%d ", n);
		
		System.out.printf("%nn = %d%n", n);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde bir değişkene bir metodun geri dönüş değerinin atandıktan sonra kontrolüne ilişkin compact
	ifadeler kullanılabilir. Bu durumda atama işleminin öncelikli olarak yapılması için atama işlemi parantez içerisinde
	yazılmalıdır. Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int total = 0;
		int val;
		
		while ((val = kb.nextInt()) != 0)
			total += val;
		
		System.out.printf("Toplam:%d%n", total);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayılardan pozitif olanlarının ve negatif olanlarının ayrı
	ayrı toplamlarını ve kaçar tane olduklarını bulan programı yazınız.
	Açıklamalar:
		- Program hiç pozitif ve/veya negatif sayı girilmezse de uygun mesajı (örneğin: Hiç pozitif sayı girilmedi!...)
		 verecektir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegCountAndTotalApp.run();
	}
}


class FindPosNegCountAndTotalApp {
	public static void printPositiveResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet pozitif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}
	
	public static void printNegativeResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet negatif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}
	
	public static void printResult(int posTotal, int posCount, int negTotal, int negCount)
	{
		printPositiveResult(posTotal, posCount);
		printNegativeResult(negTotal, negCount);
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız");
		int posTotal = 0, negTotal = 0, posCount = 0, negCount = 0;
		
		int val;
		
		while ((val = kb.nextInt()) != 0)
			if (val > 0) {
				posTotal += val;
				++posCount;
			}
			else {
				negTotal += val;
				++negCount;
			}
		
		printResult(posTotal, posCount, negTotal, negCount);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayılardan pozitif olanlarının ve negatif olanlarının ayrı
	ayrı toplamlarını ve kaçar tane olduklarını bulan programı yazınız.
	Açıklamalar:
		- Program hiç pozitif ve/veya negatif sayı girilmezse de uygun mesajı (örneğin: Hiç pozitif sayı girilmedi!...)
		 verecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegCountAndTotalApp.run();
	}
}


class FindPosNegCountAndTotalApp {
	public static void printPositiveResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet pozitif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}
	
	public static void printNegativeResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet negatif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}
	
	public static void printResult(int posTotal, int posCount, int negTotal, int negCount)
	{
		printPositiveResult(posTotal, posCount);
		printNegativeResult(negTotal, negCount);
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız");
		int posTotal = 0, negTotal = 0, posCount = 0, negCount = 0;
		
		int val;
		
		System.out.print("Bir sayı giriniz:");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			if (val > 0) {
				posTotal += val;
				++posCount;
			}
			else {
				negTotal += val;
				++negCount;
			}
			
			System.out.print("Bir sayı giriniz:");
		}
		
		printResult(posTotal, posCount, negTotal, negCount);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sonsuz Döngü (Infinite loop): Koşul ifadesinden dolayı sonlanmayan döngüdür. Yani koşul ifadesinin hep true olduğu
	bir döngüdür. Bu anlamda hiç sonlanmayan bir döngü bir sonsuz döngüdür. Aynı zamanda örneğin bir metot içerisinde
	yazılan bir döngüde return deyimi kullanılırsa da metot sonlandığı için sonsuz döngüden de çıkılmış olur. 
	
	while döngüsü ile sonsuz döngü şu gibi oluşturulabilir:
	
	while (true)
		<deyim>
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısına geri dönen digitsCount isimli metodu
	NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsCountTest.run();
	}
}

class NumberUtilDigitsCountTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamak sayısı:%d%n", val, NumberUtil.digitCount(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitCount(int val)
	{
		if (val == 0)
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;
		}
		
		return count;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamına geri döenen digitsSum isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz 
	Açıklama: Sayı negatif ise basamaklar toplamı yine pozitif olacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsSumTest.run();
	}
}

class NumberUtilDigitsSumTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamakları toplamı:%d%n", val, NumberUtil.digitsSum(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitsSum(int val)
	{
		int total = 0;
		
		while (val != 0) {
			total += val % 10;
			val /= 10;
		}
		
		return Math.abs(total);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersine geri dönen reversed isimli metodu NumberUtil
	sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Algoritması için örnekler:
		123 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
		-123 -> -3 * 10 - 2 = -32 -> -32 * 10 - 1 = -321
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilReversedTest.run();
	}
}

class NumberUtilReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının tersi:%d%n", val, NumberUtil.reversed(val));
			
			if (val == 0)
				return;
		}		
	}
}

class NumberUtil {
	public static int reversed(int val)
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Kontrolün sonda yapıldığı while döngüsünün (do-while) genel biçimi şu şekildedir:
	do 
		<deyim>		
	while (<koşul ifadesi>);
	
	Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. Yani bu döngünün ilk adımı çalıştırılmış olur. Koşul
	kontrolü ilk adımdan sonra yapılır. Yani kısaca bu döngünün en az bir adımının çalıştırılacağı garanti altındadır.
	Bu döngü deyimi while döngüsü kadar yoğun kullanılmasa da bazı durumlarda okunabilirliği artırmak için tercih
	edilebilir. Bununla birlikte gereksiz yer kullanımı okunabilirliği azaltabilir. Kodu okuyan kişi do-while döngüsü
	gördüğünde kişinin azdığı algoritmada o döngünün ilk adımının kesin yapıldığı algısını oluşuturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < n);
		
		System.out.println("\n"
				+ "Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısına geri dönen digitsCount isimli metodu
	NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsCountTest.run();
	}
}

class NumberUtilDigitsCountTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamak sayısı:%d%n", val, NumberUtil.digitCount(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte val değişkeni yerel değişken olduğundan faaliyet alanı kuralları gereği while parantezi içerisinde
	kullanılamaz.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.println("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki örnek aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int val;
		
		do {
			System.out.println("Bir sayı giriniz:");
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	17.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyimi: for döngü deyimi Java'da en yetenekli döngü deyimidir. Aslında diğer döngü deyimlerini de 
	kapsamaktadır. Ancak şüphesiz her durumda for döngü kullanılması gerekmez. for döngü deyiminin genel biçimi
	şu şekildedir:
	
	for ([1.kısım]; [2.kısım]; [3.kısım])
		<deyim>
		
	Görüldüğü gibi for döngü deyiminin 3 kısmı da olmayabilir. Ancak iki tane noktalı virgül her zaman gerekir
	1.kısım: Akış for döngüsüne geldiğinde yapılır. 1.kısım yalnızca 1 kez yapılır.
	
	2.kısım: Koşul ifadesine ilişkin bölümdür. boolean türden bir ifade olmalıdır. for döngü deyimi 2.kısımdaki
	ifade true ise yinelenir. Bı döngü deyiminde 1.kısım yapıldıktan sonra da koşul kontrolü yapılır. Yani duruma
	göre döngüye hiç girmeyebilir.
	
	3.kısım: Döngünün bir adımı tamamlandığında, bir sonraki adıma geçip geçmeme kontrolünü yapmadan önce yapılan
	kısımdır.
	
	Anahtar Notlar: for döngü deyiminin bölümleri içerisinde kullanılan değişkenlere genel olarak döngü değişkeni 
	denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde 1.kısımda değişken bildirimi yapılabilir. Bu değişken bir yerel değişken olduğundan aynı faaliyet
	alanında aynı isimde başka bir yerel değişken olamaz. Aşağıdaki örnekte döngü değişkeni 1.kısımda bildirilmiş ve 
	ilkdeğerlenmiştir (initialization)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde 1.kısımda bildirilen değişken yalnızca döngü deyiminde kullanılabilir. Döngü deyiminden sonra 
	artık faaliyet alanı bitmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println(i); //error
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bildirilen döngü değişkenleri geçerlidir. Çünkü faaliyet alanları (scope) çakışmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde, döngü değişkeninin son değeri döngüden sonra kullanılmayacaksa, döngü içerisinde bildirimi tavsiye
	edilir. Çünkü bu durumda döngü değişkenin döngüden önce bildirildiği döngülerin okunabilirliği artar. Çünkü döngü 
	değişkenin döngüden önce bildirilmesi durumunda kodu okuyan programcı döngü değişkenin döngüden sonra son değerinin
	kullanıldığını anlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde yanlışıkla noktalı virgül kullanılması durumu. Aşağıdaki örnekte bir error durumu oluşmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i);
			System.out.printf("%d ", i);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte döngü değişkeni döngü içerisinde bildirilşdiği için error oluşur. Bu durumda programcı yanlışlıkla
	noktalı virgül koymasından dolayı böcekli (bug) bir kod yazmamış olur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i);
			System.out.printf("%d ", i);//error
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde birinci ve üçüncü kısımda virgül bir ayraç olarak ifadeleri ayırmak için kullanılabilir. Virgül 
	Java'da bir operatör değildir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0, System.out.println("Akış for döngüsünde"), System.out.println("1.Kısım"); i < n; 
				System.out.println("3.kısım"), ++i)
			System.out.println("Deyim");
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde birinci kısımda birden fazla değişken bildirimi yapılabilir. Bu durumda değişkenler aynı türden
	olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0, k = 20; i < 10 && k >= 0; ++i, --k)
			System.out.printf("(%d, %d)%n", i, k);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde birinci kısımda bir bildirim yapıldığında artık başka bir ifade yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0, System.out.println("1.kısım"); i < 10; ++i) //error
			System.out.printf("%d ", i);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnek geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;
		double k;
		
		for (i = 0, k = 2.34; i < 1000 && k > 1.456; ++i, k -= 0.01)
			System.out.printf("i = %d, k = %f%n", i, k);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmaktadır. Örnekte dikkat edilirse
	for döngü deyiminin her bir adımı için boş deyim kullanılmıştır. Çünkü zaten toplama işlemi 3.kısımda yapılmaktadır.
	Şüphesiz bu kod okunabilir değildir ancak Java programcısı for döngü deyiminin çalışma sistemini bilmeli ve böyle bir
	kodu yazabilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		int val;
		
		for (System.out.println("Sayıları girmeye başlayınız:"), System.out.print("Bir sayı giriniz:"); 
				(val = Integer.parseInt(kb.nextLine())) != 0; total += val, System.out.print("Bir sayı giriniz:"))
			;
		
		System.out.printf("Total = %d%n", total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir değerin faktoriyel değerine geri dönen factorial isimli 
	metodu NumberUtil sınıfı içerisinde yazınız ve [-1, 13) aralığındaki sayıların faktoriyelini ekrana bastırarak kodu 
	test ediniz:
	Açıklamalar:
		- Faktoriyel işlemi 
		0! = 1
		1! = 1
		2! = 1 * 2
		3! = 1 * 2 * 3
		...
		n! = 1 * 2 * ... * n- 1 * n
		
		- Negatif sayılar için faktoriyel değeri 1 olarak döndürülecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilFactorialTest.run();
	}
}

class NumberUtilFactorialTest {
	public static void run()
	{
		for (int n = -1; n < 13; ++n)
			System.out.printf("%d! = %d%n", n, NumberUtil.factorial(n));
	}
}

class NumberUtil {
	public static int factorial(int n)
	{
		int result = 1;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden taban ve üs bilgisine göre a'nın b-inci kuvvetini döndüren
	pow isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot üssün negatif olması durumunda 1 değerine geri dönecektir
		- Metot içerisinde Math sınıfının pow metodu kullanılmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilPowTest.run();
	}
}

class NumberUtilPowTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
		
			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
			
			if (b <= 0)
				return;
		}
		
	}
}

class NumberUtil {
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for (int i = 0; i < b; ++i)
			result *= a;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden taban ve üzs bilgisine göre a'nın b-inci kuvvetini döndüren
	pow isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot üssün negatif olması durumunda 1 değerine geri dönecektir
		- Metot içerisinde Math sınıfının pow metodu kullanılmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilPowTest.run();
	}
}

class NumberUtilPowTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
		
			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
			
			if (b <= 0)
				return;
		}
		
	}
}

class NumberUtil {
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		while (b-- > 0)
			result *= a;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir sayının basamaklarının basamak sayıncı kuvvetleri toplamının kendisine
	eşit olup olmadığını test eden isArmstrong isimli metodu yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- 153 sayısı 3 basamaklıdır ve 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153'dür.
		
		- Negatif sayılar için metot false değerine geri dönecektir.
		
		- Kuvvet alma işlemi için bir önceki örnekteki pow metodu kullanılacaktır.
		
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
	
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		while (b-- > 0)
			result *= a;
		
		return result;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	23.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 1.kısım boş bırakıldığında akış for döngüsüne geldiğinde yalnızca koşul kontrolü yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		for (; i < n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 3.kısım boş bırakıldığında her adım sonunda koşul kontrol edilmeden herhangi bir işlem yapılmamış
	olur. Şüphesiz programcı bu duruma göre kodunu düzenlemelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n;) { 
			System.out.printf("%d ", i);
			++i;			
		}
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 1. ve 3. kısımlar boş bırakıldığında while döngü deyimi gibidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		for (; i < n;) { //while (i < n) {  
			System.out.printf("%d ", i);
			++i;			
		}
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde ikinci kısmın boş bırakılması durumu true yazılmasıyla aynı anlamdadır. Yani sonsuz döngüdür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);	

		for (int i = 0; ; ++i)  
			System.out.printf("%d%n", i);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde sonsuz döngü oluşturmak için programcılar okunabilirlik açısından 3 kısmı da boş bırakırlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);	
	
		for (;;) {
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sonsuz döngü sanılan ancak olmayan bir döngü örneği
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int i;
		for (i = 0; i < 10; --i)
			;//System.out.println(i);
			
			
		System.out.printf("i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int i;
		for (i = 20; i >= 0; ++i)
			;//System.out.println(i);
			
		System.out.printf("i = %d%n", i);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli
	metodu yazınız
	Asal Sayı: Yalnızca 1'e ve kendisine bölünebilen pozitif sayılara asal sayı denir
	(Yavaş versiyon) 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{
		for (long i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));			 
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		for (long i = 2; i <= val / 2; ++i)
			if (val % i == 0)
				return false;
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli
	metodu yazınız
	Asal Sayı: Yalnızca 1'e ve kendisine bölünebilen pozitif sayılara asal sayı denir
	
	Kural: Bir sayı kare kökünden küçük olan asal sayıların hiç birisine bölünmüyorsa asaldır
	(Daha hızlı versiyon)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{			
		for (long i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte isPrime metotlarının demo bir counter testi yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{		
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		int count = 0;
		
		for (long i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("isPrime:count:%d%n", count);
		
		return true;		
	}
	
	public static boolean isPrimeSlow(long val)
	{
		if (val <= 1)
			return false;
		
		int count = 0;
		for (long i = 2; i <= val / 2; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("isPrimeSlow:count:%d%n", count);
		return true;
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki algoritmanın Matematiksel olarak daha hızlısı vardır. Ancak burada ele alınmayacaktır. Çoğu zaman
	bu algoritma yeterli olacaktır. Eğer çok büyük sayılarla çalışılmıyorsa sayının yarısına kadar dolaşan algoritma da
	yeterli olabilir. Yukarıdaki iki algoritmayı aşağıdaki asal sayılar ile çalıştırıp sonuçları gözlemleyebilirsiniz:
	
	6750161072220585911
	1603318868174368979
	6584583408148485263
	6245098347044246839
	6285871677077738093
	5697859706174583067
	710584055392819667
	4935060337471977161
	3728803592870153407
	4331452335614730577
	1386437196678024971
	1677990107453991593
	4765603950744460867
	4498306523077899307
	4434895834573449257	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		for (long i = 2; count < n; ++i)
			if (isPrime(i)) {
				++count;
				val = i;
			}
		
		return val;
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		while (true) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	24.09.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan büyük ilk asal sayıya geri dönen nextClosestPrime isimli metodu 
	yazınız ve aşağıdaki kod ile test ediniz
	
	Not: Aşağıdaki örnekte sayının üstten taşması (over flow) durumu kontrol edilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNextClosestPrimeTest.run();
	}
}

class NumberUtilNextClosestPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			long n = Long.parseLong(kb.nextLine());		
			
			
			System.out.printf("%d. sayısından büyük ilk asal sayı:%d%n", n, NumberUtil.nextClosestPrime(n));
			
			if (n == 0)
				return;
		}
	}
}

class NumberUtil {
	public static long nextClosestPrime(long val)
	{		
		while (!isPrime(++val))
			;
		
		return val;		
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan küçük en büyük asal sayıya geri dönen previousClosestPrime isimli metodu 
	yazınız ve aşağıdaki kod ile test ediniz
	
	Not: Aşağıdaki örnekte sayının alttan taşması (under flow) durumu kontrol edilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilPreviousClosestPrimeTest.run();
	}
}

class NumberUtilPreviousClosestPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			long n = Long.parseLong(kb.nextLine());		
			
			
			System.out.printf("%d. sayısından küçük en büyük asal sayı:%d%n", n, NumberUtil.previousClosestPrime(n));
			
			if (n == 0)
				return;
		}
	}
}

class NumberUtil {
	public static long previousClosestPrime(long val)
	{		
		while (!isPrime(--val))
			;
		
		return val;
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İçiçe döngülerde dıştaki döngünün bir adımı için içteki döngü tamamlanır. Bu durumda örneğin içiçe iki döngünün 
	toplam dönme sayısı "dıştaki döngünün adım sayısı * içteki döngünün adım sayısı" kadardır. Örnek durumu göstermek
	için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();
		
		for (int i = 0; i < m; ++i)
			for (int k = n - 1; k >= 0; --k)
				System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bazen programcı tek bir döngü yazsa bile, döngü içerisinde çağırmış olduğu bir metot da döngüye girdiğinde dolaylı
	olarak içiçe döngü kullanmış olur. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();
		
		for (int i = 0; i < m; ++i)
			Sample.doWork(i, n);
	}
}

class Sample {
	public static void doWork(int i, int n)
	{
		for (int k = n - 1; k >= 0; --k)
			System.out.printf("(%d, %d)%n", i, k);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Prtaikte içiçe döngüler için, 2 veya 3 döngü karşımıza çok fazla çıkabilir. Programcı özellikle 
	3'den fazla içiçe döngü ile bir algoritmayı gerçekleştirmişse, algoritmasını tekrar gözden geçirmesi tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içiçe döngü kullanılarak 3 basamaklı Armstrong sayıları bulunmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		for (int a = 1; a <= 9; ++a)
			for (int b = 0; b <= 9; ++b)
				for (int c = 0; c <= 9; ++c)
					if (100 * a + 10 * b + c == a * a * a + b * b * b + c * c * c)
						System.out.printf("%d%d%d ", a, b, c);
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	break deyimi: break deyimi döngüyü sonlandırmak için kullanılır. break deyiminin genel biçimi şu şekildedir:
	
		break [etiket ismi];
		
	break deyiminin tek başına kullanımına etiketsiz break ya da sadece break, etiket ile kullanımına ise etiketli break
	deyimi denilmektedir. break tek başına kullanıldığında, akış break deyimine geldiğinde ilgili döngü sonlanır ve akış
	döngü deyiminden sonraki deyimle devam eder. break deyimi ya bir döngü deyimi içerisinde ya da  ileride göreceğimiz 
	switch deyimi içerisinde kullanılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int total = 0;				
		
		while (true) {
			int val = kb.nextInt();
			
			if (val == 0)
				break;
			
			total += val;
		}
		
		System.out.printf("Toplam:%d%n", total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				break;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		while (true) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde dıştaki döngünün sonlanrılması için flag değişken 
	kullanılmıştır. Örnek durumu göstermek için yazılmıştır		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		boolean exitFlag = false;
		
		for (int i = 2; i <= 20; ++i) { 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0) {
					exitFlag = true;
					break;
				}
			}
			if (exitFlag)
				break;
		}
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Etiketli break deyimi, etiketin bildirildiği kontrol deyiminin (tipik olarak döngü deyimi) sonlanmasını sağlar. Etiket
	ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Ancak bir convention etiket isimlerinin
	tamamı büyük harf ile, birden fazla kelimeden oluşuyorsa kelimeler arasına alttire karakteri kullanılarak bildirim
	yapılır. Etiket bildirimi etiket isminden sonra : ile birlikte ilgili kontrol deyiminden önce yapılır. Etiket ismi
	bildirildiği döngü boyunca görülebilirdir. Yukarıdaki etiketli break kullanılarak aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		EXIT_LOOP:
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					break EXIT_LOOP;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyimiz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		EXIT_LOOP:
		for (int i = 2; i <= 20; ++i) 
			EXIT_INNER_LOOP:
			for (int j = 3; j <= 40; ++j) 
				for (int k = 30; k >= 3; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);
					
					if ((i +  j + k) % 11 == 0)
						break EXIT_LOOP;
					
					if ((i +  j + k) % 7 == 0)
						break EXIT_INNER_LOOP;
				}	
					
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	continue deyimi: Bu deyim döngünün bir adımını sonlandırmak için kullanılır. continue deyimi yalnızca döngü deyimlerinde
	kullanılabilir. continue deyimi, break deyimi kadar çok kullanılmasa da okunabilirliği artırmak için tercih edilebilir.
	Aşağıdaki örnek continue deyiminin nasıl çalıştığını göstermek için yazılmıştır. Şüphesiz başka yöntemlerle de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 1; i <= n; ++i) {
			if (i % 2 == 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aslında continue deyiminin de etiketli kullanımı söz konusudur. Ancak programlama tekniği açısından
	kullanımı tavsiye edilmez. Aşağıdaki kullanım tavsiye edilmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		CONTINUE_LOOP:
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					continue CONTINUE_LOOP;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek break deyimi ile hem daha okunabilir hem de daha basit bir biçimde yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					break;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		if (option == 1)
			doInsert();
		else if (option == 2)
			doUpdate();
		else if (option == 3)
			doSearch();
		else 
			doDelete();
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if (option < 1 || option > 5) {
				System.out.println("-------------------------------------");
				System.out.println("Geçersiz seçenek!...");
				System.out.println("-------------------------------------");
				continue;
			}
			
			if (option == 5)
				break;
			
			doOption(option);
		}
		
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Herhangi bir noktada (yani herhangi bir metot içerisinde) programı sonlandırmak için System.exit 
	metodu çağrılabilir. Bu metodun int türden bir parametresi vardır. Bu parametre "exit code" değeridir. Bu değer 
	teknik olarak program sonlandığında JVM'e oradan da işletim sistemine iletilen bir değerdir. Bu değerin çoğu zaman 
	önemi yoktur. Bu değerin anlamı uygulama kurslarında ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo menü uygulaması aşağıdaki gibi de yazılabilir
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		if (option == 1)
			doInsert();
		else if (option == 2)
			doUpdate();
		else if (option == 3)
			doSearch();
		else if (option == 4)
			doDelete();
		else if (option == 5)
			doExit();
		else
			doInvalidOption();		
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir n değeri için n-inci Fibonacci sayısına geri dönen nthFibonacciNumber 
	isimli metodu NumberUtil sınıfı içerisinde aşağıdaki açıklamalara göre yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrolü yapılmayacaktır
		- Fibonacci sayılarına ilişkin seri şu şekildedir
			0 1 1 2 3 5 8 13 21 ...	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		NumberUtilNthFibonacciNumberTest.run();
	}
}

class NumberUtilNthFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				break;
			
			System.out.printf("%d.Fibonacci sayısı:%d%n", n, NumberUtil.nthFibonacciNumber(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nthFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = prev1 + prev2;
		
		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}
		
		return val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan büyük ilk Fibonacci sayısına geri dönen nextFibonacciNumber
	metodunu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		NumberUtilNextFibonacciNumberTest.run();
	}
}

class NumberUtilNextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());			
			
			System.out.printf("%d sayısından büyük ilk Fibonacci sayısı:%d%n", val, NumberUtil.nextFibonacciNumber(val));
			
			if (val == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0;
		
		while (true) {
			int next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	30.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	switch deyimi: 	switch belirli koşullar altında, sabit olan değerleri eşitlik karşılaştırmasına sokmak ve duruma göre
	işlem yapmak için kullanılan bir kontrol deyimidir. Yani if deyimine alternatif olmasa da belirli koşullar altında
	if deyimi yerine kullanılabilen bir deyimdir. switch deyimi okunabilirliği artırmak için if deyimi yerine tercih
	edilebilir. switch deyiminin geneş biçimi şu şekildedir:
		switch (<ifade>) {
			case <sabit ifadesi>:
				<deyim>
			case <sabit ifadesi>:
				<deyim>
				
				...
			[
			default:
				<deyim>
			]
		}
		
	switch deyiminin parantezi içerisindeki ifadenin temel türlerden tamsayı türlerinden biri veya char türünden olması
	gerekir. Gerçek sayı türlerinden biri ve boolean türünden olamaz. switch deyiminin parantezi içerisindeki ifadenin
	değeri yukarıdan aşağıya doğru case bölümlerine ilişkin sabit ifadesi ile eşitlik karşılaştırmasına sokulur ve ilk
	doğru olan (yani eşitliğin sağlandığı) case bölümünden itibaren akış switch deyiminden çıkılana kadar devam eder. 
	Eğer hiç bir case bölümü doğru olmazsa (yani eşitlik sağlanmazsa) varsa default case bölümü çalıştırılır. Default 
	case yoksa akış switch deyiminden sonrasından devam eder  
	
	Anahtar Notlar: switch deyimi temel türler dışında String sınıfı ve enum sınıflar ile de kullanılmaktadır. Bunlar
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki switch deyiminin if deyimi karşılığı şu şekildedir:
	
	if (plate == 34)
		System.out.println("İstanbul");
	else if (plate == 67)
		System.out.println("Zonguldak");
	else if (plate == 6)
		System.out.println("Ankara");
	else if (plate == 35)
		System.out.println("İzmir");
	else
		System.out.println("Geçersiz şehir girdiniz!...");
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 67:
			System.out.println("Zonguldak");
			break;
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde gerçek sayı türleri kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		double plate = kb.nextDouble();
		
		switch (plate) { //error
		//...
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde boolean türü kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		
		boolean flag = true;
		
		switch (flag) { //error
		//...
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölüm olmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 67:
			System.out.println("Zonguldak");
			break;
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");
			break;		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall through) özelliği vardır. Akış bir bölümü çalıştırdıktan sonra bir sonraki
	bölüme geçmeyi engelleyen bir deyime kadar veya switch sonuna kadar tüm deyimleri çalıştırır. break deyimi switch
	deyimini de sonlandırır. Aşağıdaki örneği çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
		case 67:
			System.out.println("Zonguldak");			
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");			
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölüm sonda olmak zorunda değildir. Sonda olmasa bile default bölümün anlamı değişmez. Sonda
	olmaması durumunda default bölüm çalıştırıldıktan sonra yine aşağıda düşme olur bu sebeple engellenmesi gerekir. 
	Şüphesiz default bölümün sonda yazılması okunabilirlik açısından daha normal bir durumdur. Aşağıdaki örneği
	çeşitli değerler için çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
		case 67:
			System.out.println("Zonguldak");			
		case 6:
			System.out.println("Ankara");
			break;
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		case 35:
			System.out.println("İzmir");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte fall through özelliği kullanılarak kod tekrarı engellenmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212:
			System.out.print("Avrupa ");			
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212:						
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 12 ile birlikte preview olarak, Java 14 ile birlikte normal olacak şekilde case ifadesinde birden fazla sabit
	için aynı işlem yapılacaksa sabitler tek bir case içerisinde vigül ile listelebilir. Java programcısı bu sentaks 
	ticari olarak Java 17 ile birlikte kullanılabilir olarak düşünmelidir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: switch deyiminde case bölümlerinin özellikle çok uzun tutulmamasına dikkat edilmelidir. Yani switch
	deyimi tüm bölümleriyle okunabilir olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Derleyicinin yazılan kodun algoritmasını değiştirmeden daha hızlı veya daha az yer kaplayacak 
	şekilde bir kod üretmesine derleyicinin kod optimizasyonu (code optimization) denir. Bu anlamda derleyicilerin 
	optimizasyonu ikiye ayrılır: speed, size. Burada baskın olan genelde hızdır. Derleyicilerin çok fazla optimizasyonu
	vardır. Zaman içerisinde ele alınacaktır 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici sabit ifadelerinin değerlerini hesaplayıp arakoda yazar, yani akış o noktaya geldiğinde sabit ifadeleri
	hesaplanmaz. Buna "constant folding optimization" denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365;
		
		System.out.println(divider);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aynı değere sahip birden fazla case bölümü geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212: //error						
		case 216 - 4: //error
			System.out.println("İstanbul");
			break;
		case 212 - 2 + 2: //error
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde case bölüme ilişkin ifadenin sabit ifadesi olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		int c = 372;
		
		switch (code) {
		case 212: 						
		case 216:
			System.out.println("İstanbul");
			break;
		case c: //error
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		switch (option) {
		case 1:
			doInsert();
			break;
		case 2:
			doUpdate();
			break;
		case 3:
			doSearch();
			break;
		case 4:
			doDelete();
			break;
		case 5:
			doExit();
			break;
		default:
			doInvalidOption();		
		}				
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı yıl bilgisinin artık yıl olup olmadığını test eden isLeapYear isimli 
	metodu yazınız ve aşağıdaki kod ile test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsLeapYearTest.run();
	}
}

class DateUtilIsLeapYearTest {
	public static void run()
	{
		for (int year = 1999; year <= 2104; ++year)
			if (DateUtil.isLeapYear(year))
				System.out.println(year);
	}
}

class DateUtil {
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı gün, ay ve yıl bilgilerine ilişkin tarihin geçerli bir tarih olup olmadığını
	test eden isValidDate isimli metodu DateUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar: 
	 - Yıl 1900'den küçük olmamalıdır
	 
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsValidDateTest.run();
	}
}

class DateUtilIsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d geçerli bir tarihtir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih!...");
			
			if (day == 0 && month == 0 && year == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı gün, ay ve yıl bilgilerine ilişkin tarihin geçerli bir tarih olup olmadığını
	test eden isValidDate isimli metodu DateUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar: 
	 - Yıl 1900'den küçük olmamalıdır
	 
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsValidDateTest.run();
	}
}

class DateUtilIsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d geçerli bir tarihtir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih!...");
			
			if (day == 0 && month == 0 && year == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4, 6, 9, 11:		
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	01.10.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}
		
		switch (getDayOfWeek(day, month, year)) {
		case 0:
			System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;			
		case 1:
			System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 2:
			System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 3:
			System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 4:
			System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 5:
			System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 6:
			System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		}
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		 if (isValidDate(day, month, year))
			 return getDayOfYearValue(day, month, year);
		 
		 return -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += 28;
			if (isLeapYear(year))
				++dayOfYear;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}
		
	
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4, 6, 9, 11:		
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 12 ile birlikte preview olarak, ava 14 ile birlikte normal olacak şekilde switch expression dile eklenmiştir. 
	Java programcısı bu sentaksı ticari olarak Java 17 ile birlikte kullanılabilir olarak düşünmelidir. switch expression
	hem bir deyim olarak hem de bir ifade olarak kullanılabilmektedir. switch expression'ın genel biçimi şu şekildedir:
	switch (<ifade>) {
		case <si>[,<si>,...] -> <deyim>
		case <si>[,<si>,...] -> <deyim>
		
		...
		[
		default-> <deyim>
		]
	}
	
	switch expression'da da temel türlerden yalnızca tam sayı türleri ve char türü için kullanılabilir. switch expression'da 
	da case bölümlerinin sabit ifadesi olması zorunludur. switch expression'da aşağı düşme özelliği yoktur. switch
	expression'da break kullanımı geçersizdir
	
	Anahtar Notlar: Programlamada hem deyim hem de ifade biçiminde kullanılabilen araçlara "expression statement" da 
	denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34 -> System.out.println("İstanbul");		
		case 67 -> System.out.println("Zonguldak");
		case 6 -> System.out.println("Ankara");			
		case 35 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression'da da birden fazla değer case bölümünde virgül ile ayrılarak yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216 -> System.out.println("İstanbul");		
		case 372 -> System.out.println("Zonguldak");
		case 312-> System.out.println("Ankara");			
		case 232 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte "switch expression" bir expression olarak kullanılmıştır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> "İstanbul";		
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	"switch expression" bir expression olarak kullanıldığında default bölümü olmak zorundadır. Aksi durumda error
	oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> "İstanbul";		
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			//default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	"switch expression"'da birden fazla işlem yapılması durumunda bileşik deyim yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216 -> {
			System.out.print("Marmara Bölgesi -> ");
			System.out.println("İstanbul");
		}		
		case 372 -> System.out.println("Zonguldak");
		case 312-> System.out.println("Ankara");			
		case 232 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression'da bir case bölümünde bileşik deyim yazılmışsa ve değer üretilecekse yield anahtar sözcüğü
	kullanılmalıdır. Bileşik deyim yoksa yield kullanımı error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> {
				System.out.print("Marmara Bölgesi -> ");
				yield "İstanbul";				
			}
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression ile birlikte switch deyimi de expression olarak kullanılabilir duruma gelmiştir. Bu durumda 
	değer üretimi yield anahtar sözcüğü ile yapılır. Bu durumda her zaman case bölümünün bileşik deyim olarak
	yazılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216: {yield "İstanbul";}			
			case 372: {yield "Zonguldak";}
			case 312: {yield "Ankara";}
			case 232: {yield "İzmir";}
			default: {yield "Geçersiz şehir girdiniz!...";}		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		int a = switch (val) {
		case 0 -> 10;
		case 1 -> 30;
		case 2 -> 55;
		default -> -1;		
		} + 100;
		
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		int a = Sample.foo(val) + 100;
		
		System.out.printf("a = %d%n", a);
	}
}

class Sample {
	public static int foo(int val)
	{
		return switch (val) {
			case 0 -> 10;
			case 1 -> 30;
			case 2 -> 55;
			default -> -1;		
		};
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		switch (option) {
		case 1 -> doInsert();		
		case 2 -> doUpdate();			
		case 3 -> doSearch();		
		case 4 -> doDelete();			
		case 5 -> doExit();
		default -> doInvalidOption();		
		}				
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}	
	
		switch (getDayOfWeek(day, month, year)) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);						
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 2 -> System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		}
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		 if (isValidDate(day, month, year))
			 return getDayOfYearValue(day, month, year);
		 
		 return -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += 28;
			if (isLeapYear(year))
				++dayOfYear;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}
		
	
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{		
		return switch (month) {
			case 4, 6, 9, 11 -> 30;			
			case 2 -> {		
				if (isLeapYear(year))
					yield 29;
				yield 28;
			}
			default -> 31;
		};
		
		
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ne zaman klasik deyimi ne zaman switch expression kullanacağız? Buna nasıl karar vereceğiz? Zaten ticari olarak Java 17
	öncesinde ya da Java 12 veya Java 14 öncesinde çalışıyorsak zaten switch expression kullanamayız. Java 17 ile 
	çalışıyorsak aşağı düşme özelliğinden faydalanmıyorsak her zaman switch expression kullanılmalıdır.  
	
	Anahtar Notlar: switch'e, özellikle ticari olarak Java 21 ile kullanılabilecek bazı özellikler eklenmiştir. Bu özelliklerin
	bazılar preview biçimindedir. Bu özellikler başka konuları da gerektirdiğinden ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	08.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Type Conversions)
	Java'da farklı türlerin birbirine atanabilmesine (dönüşebilmesine) yönelik kurallar belirlenmiştir. T1 ve T2 birer
	tür ismi olmak üzere
		T1 t1;
		T2 t2;
		
		...
		
		t1 = t2; //**
	kodları için ** ile belirtilen ifadede T2 türünden T1 türüne doğrudan dönşüm/atama (implicit conversion) denir.
	Bu ifadede T2 türüne kaynak tür (source type), T1 türüne ise hedef tür (destination/target type) denir. Java'da 
	derleyici açısından hangi türün hangi türe doğrudan atanabileceği belirlidir. Bu anlamda atanamayan türler de 
	genel olarak ileride göreceğimiz tür dönüştürme operatörü (type cast operator) ile dönüştürülebilmektedir. Tür
	dönüştürme operatörü ile yapılan dönüşüme ise explicit conversion denir. Burada temel türler arasındaki tür 
	dönüştürme kuralları ele alınacaktır. Diğer türler arasındaki dönüşümler ileride konular içerisinde ele alınacaktır.
	
	Temel türler arasındaki doğrudan dönüşümlerde genel kural şu şekildedir: Genel olarak bilgi/veri kaybına yol açmayacak 
	dönüşümler doğrudan yapılabilir
	
	Derleyici kaynak türe ile ilişkin değerin hedef tür sınırları içerisinde olup olmadığına bakmaz ki çoğu zamanda bakamaz.
	Örneğin değer klavyeden okunsa zaten derleme zamanında hiç bir şekilde bilinemez. Bu durumda derleyici kaynak türden hedef
	türe doğrudan atamanın geçerli olup olmadığına göre kodu derler. Doğrudan dönüşüme ilişkin ayrıntılar ayrıca ele alınacaktır.
	
	Anahtar Notlar: Size olarak küçük türden size olarak büyük türe yapılan atamalara Java Language Specification'da (JLS)
	widening conversion, size olarak büyük türden size olarak küçük türe yapılan atamalar ise narrowing conversion 
	her ikisinin birden olduğu dönüşümlere ise widening and narrowing conversion denilmektedir. Buradaki terimler,
	dönüşümün geçerli ya da geçersiz olmasından bağımsızdır. Anlatım bu şekilde kullanılmıştır. Biz burada bu terimleri
	her zaman kullanmayarak konuyu daha anlaşılır hale getirmeye çalışacağız.
	
	Anahtar Notlar: Anımsanacağı gibi Java'da 3 yerde atama işlemi yapılmaktadır:
	1. Yalın atama işlemi
	2. Metot çağrısında argümanlardan parametrelere aktarım
	3. Metodun geri dönüş değerinin geçici değişkene atanması
	Tür dönüştürme kuralları istisna bir kaç kural dışında tüm atama durumlarında geçerlidir. İstisna kurallar ayrıca
	ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte long türünden int türüne yapılan dönüşüm geçersiz olduğundan error oluşur. Derleyici a değişkeni
	içerisindeki değer bilmesine rağmen atama durumunda bunu dikkate almaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;
		
		b = a;//error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte a değişkeninin değeri derleme zamanında kesinlikle bilinemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		long a = kb.nextLong();
		int b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Temel türler arasındaki implicit conversion detayları şunlardır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b;
		
		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Hiç bir türden char türüne doğrudan dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = 10;
		char b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Anımsanacağı gibi byte ve short türden sabit yoktur. Java'da int türden bir sabit sınırlar içerisinde kalması
	koşuluyla byte veya short türüne doğrudan atanabilir. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		int c = 10;
		
		a = 10;
		b = 20;
		
		b = c; //error
		b = 10L; //error
		a = 70000; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki istisna kural char türü için de geçerlidir. Yani sınırlar içerisinde kalması koşuluyla int türden 
	bir sabit char türüne doğrudan atanabilir. Ancak bu kural shot ve byte türleri kadar pratikte kullanılmaz. Çünkü
	char türden sabitler vardır ve bunlar kullanılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c;
		int a = 67;
		
		c = 67;
		c = a; //error
		c = 67L; //error
		c = -23; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	short, byte ve char türüne ilişkin yukarıdaki istisna kurallar, metodun geri dönüş değeri varsa return deyimine 
	ilişkin ifadeler için de geçerlidir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static short foo()
	{
		//...
	
		return 10;
	}
	
	public static byte bar()
	{
		//...
	
		return 127;
	}
	
	public static char tar()
	{
		//...
	
		return 67;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	short, byte ve char türüne ilişkin yukarıdaki istisna kurallar, argümalardan parametrelere aktarıma ilişkin atamada
	geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10); //error
		Sample.bar(127); //error
		Sample.tar(67); //error
	}
}

class Sample {
	public static void foo(short a)
	{
		//...
	}
	
	public static void bar(byte b)
	{
		//...
	}
	
	public static void tar(char c)
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir. Bu durumda sayının yüksek anlamlı bit
	değerleri sayı pozitifse sıfır ile, negatif ise 1 ile beslenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		long b;
		
		b = a;
		
		System.out.printf("a = %d, a = %08Xh%n", a, a);
		System.out.printf("b = %d, b = %016Xh%n", b, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir. Bu durumda sayının yüksek anlamlı bit
	değerleri sayı pozitifse sıfır ile, negatif ise 1 ile beslenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		short a = kb.nextShort();
		int b;
		
		b = a;
		
		System.out.printf("a = %d, a = %04Xh%n", a, a);
		System.out.printf("b = %d, b = %08Xh%n", b, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden kendisinden size olarak büyük herhangi bir türe doğrudan dönüşüm geçelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'D';
		int a;
		double b;
		
		a = c;
		b = c;
		
		System.out.printf("a = %d, b = %f%n", a, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne doğrudan dönüşüm geçersizdir. Çünkü char türü içerisinde short türü sınırlarından büyük
	değerler de tutulabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 40000;
		short a;
		
		a = c; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Tüm tamsayı türlerinden gerçek sayı türlerine doğrudan dönüşüm geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 10;
		float b;
		
		b = a; 
		
		System.out.printf("b = %f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türlerinden tamsayı türlerine doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 10;
		long b;
		
		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	float türünden double türüne doğrudan dönüşüm geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			float a = Float.parseFloat(kb.nextLine());
			
			if (Math.abs(a) < 0.00001)
				break;
			
			double b;
			
			b = a;
			
			System.out.printf("a = %.20f, b = %.20f%n", a, b);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 123;
		float b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte, double türünden float türüne doğrudan atama geçersiz olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 0.3; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte 0.3 sabit float olarak alınmıştır. Yuvarlama hatasına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 0.3F;
		
		System.out.printf("a = %.20f%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnek int türünden float türüne doğrudan atama yapılabileceği için geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 10;
		
		System.out.printf("a = %.20f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	bool türünden hiç bir türe, herhangi bir türden bool türüne doğrudan dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;
		
		b = a; //error
		
		b = true;
		
		a = b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Doğrudan dönüşüme ilişkin özet şu şekilde yazılabilir: 
	byte		-> short, int, long, float, double
	short		-> int, long, float, double
	int			-> long, float, double
	long		-> float, double
	float		-> double
	char		-> int, long, float, double
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem Öncesi Otomatik Tür Dönüşümleri: İki operandlı operatörlere ilişkin işlemler aşağı seviye farklı türlerle 
	yapılamaz. Örneğin farklı türden iki ifade doğrudan toplanamaz. Bu işlemler aynı türler ile yapılabilir. Bu durumda
	farklı türden işlemler için derleyici bir operandı ya da operandları farklı bir türden ele alacak kodu üretir ve işlem
	ortak tür ile yapılır. Buna işlem öncesi otomatik tür dönüşümü denir. Bu dönüşümler yukarıda anlatılan "implicit conversion"
	kurallarına uygun olarak yapılır. Otomatik tür dönüşümü bir ifadenin (örneğin bir değişkenin) türünün değişmesi
	demek değildir. O ifadenin değerinin dönüştürülmüş olan tür ile temsil edilmesidir. Bu işlemin aşağı seviyede nasıl
	yapıldığı ileride ele alınacaktır  
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümüne ilişkin ayrıntılar şunlardır (else if biçiminde değerlendiriniz):
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Bölme işleminde operandlar tam sayı türündense sonuç tamsayı türünden çıkar. Bölme işleminden  elde edilen değerin 
	noktadan sonraki kısmı atılır. Tam kısmı alınır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				break;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			int c;
			
			c = a / b;
			
			System.out.printf("%d / %d = %d%n", a, b, c);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				break;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			double c;
			
			c = a / b;
			
			System.out.printf("%d / %d = %f%n", a, b, c);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a, b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		char b;
		char c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	14.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki maddeye göre tamsayı türleri ile işlemler aşağı seviyde size olarak en az int türü yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türü ile küçük tamsayı türü işleme sokulduğunda küçük tamsayı türüne ilişkin değer büyük tamsayı türüne
	dönüştürülür, işlem büyük tamsayı türünden yapılır ve sonuç büyük tamsayı türünden çıkar 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 30;		
		int c;
		
		c = a + b; //error		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türü kendisinden size olarak olarak büyük bir tür ile işleme sokulduğunda char türüne ilişkin değer ilgili türe
	dönüştürülür ve sonuç o türden çıkar 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'A';
		double b = 4.5;
		double result;
		
		result = c + b;
		
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 Bir tamsayı türü ile gerçek sayı türü işleme sokulduğunda tamsayı türüne ilişkin değer gerçek sayı türüne 
	 dönüştürülür ve işlem o gerçek sayı türünden çıkar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		long b = 345;
		float c;
		
		c = a + b;
		
		//...				
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 float türü ile double türü işleme sokulduğunda float türüne ilişkin değer double türüne dönüştürülür ve sonuç
	 double türünden elde edilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		double b = 345.89;
		float c;
		
		c = a + b; //error

	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 boolean türü hiç bir tür ile işleme sokulamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 1;	
		
		System.out.println(a == b); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratılan 
	kodu üretir. Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu 
	şekildedir:
		long temp;
		
		temp = a;
		
		c = temp + b;	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 345;		
		long c;
		
		c = a + b;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu şekildedir:
		int temp1, temp2;
		
		temp1 = a;
		temp2 = b;
		
		c = temp1 + temp2;	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		short b = 345;		
		int c;
		
		c = a + b;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu şekildedir:
		double temp1;
		double temp2;		
		long temp3;
		
		temp1 = Math.sqrt(a);
		temp3 = Math.round(b);
		temp2 = temp3;
		
		c = temp1 + temp2;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;
		
		c = Math.sqrt(a) + Math.round(b);
	
		System.out.printf("c = %f%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Yukarıdaki üç örnek için yazılan kodların yaklaşık olduğuna yani derleyicinin birebir aynı kodlar
	üretmeyebileceğine, hatta bazılarında o kadar sayıda geçici değişken yaratmayabileceğine dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Tür Dönüştürme (type cast) Operatörü: Tür dönüştürme operatörü özel amaçlı, tek operandlı ve önek durumunda bir 
	operatördür. Operatörün genel biçimi şu şekildedir:
	
		(<hedef tür>)<ifade>
		
	Operatör operandı olarak aldığı ifadenin değerini hedef türe dönüştürür ve o değeri üretir. Operatörün yan etkisi 
	yoktur. Tür dönüştürme operatörü ile yapılan dönüştürme işlemine "explicit conversion", "type casting" ya da kısaca
	"casting" denilmektedir. Tür dönüştürme operatörü operatör öncelik tablosunun ikinci seviyesinde ve sağdan sola
	önceliklidir. Implicit olarak yapılamayan dönüşümler genel olarak explicit olarak yani tür dönüştürme operatörü
	ile yapılabilir. implicit dönüşümlerde de tür dönüştürme operatörü kullanılabilir 
	
	Anahtar Notlar: Tür dönüştürme operatörünün sentaks olarak zorunlu olması durumu yani bu operatör kullanılmamasının
	error olması durumu şu şekilde özetlenebilir: Ortada bir problem olabilir. Derleyici programcının bunu doğrudan
	yapmasına izin vermiyor çünkü yanlışlıkla yapılabilir. Bu durumda programcı da bunu explicit olarak yaparak
	derleyiciye ben durumun farkındayım demiş olur. Bazı dönüşümler explicit olarak bile yapılamaz. Bunlar Java açısından
	anlamsız durumlardır ve derleyici buna hiç vermez.
	
	Anahtar Notlar: Bir dönüşüm implicit olarak yapılamıyor ise explicit olarak yapılıyor olabilir. Ancak explicit olarak
	yapılamıyorsa implicit olarak zaten yapılamaz
	
	Tür dönüştürme operatörü ile yapılan işlem de geçici değişkenyaratılarak yapılır. Yani tür dönüştürme operatörünün
	operandına ilişkin ifadenin türü değişmez. Aşağıdaki örnekte değişken a'nın türü değildir. Çünkü bir değişkenin 
	faaliyet alanı boyunca aynıdır. ** ile belirtilen basit deyime ilişkin ifade için derleyicinin ürettiği yaklaşık
	kod şu şekildedir:
	
		double temp1 = a;
		double temp2 = b;
		
		c = temp1 / temp2;	 	
	
	Örnekte bölme operatörünün birinci operandı double olarak işleme sokulduğundan ikinci operandına ilişkin
	değer de double türüne dönüştürülür, işlem double olarak yapılır ve sonuç da double olarak elde edilir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;
		
		c = (double)a / b; //**
		
		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme operatörüne yönelik detaylar şunlardır: 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne veya char türüne yapılan explicit dönüşümde değerin yüksek anlamlı
	byte değerleri atılır, elde edilen sonuç hedef türe atanır. Bu durumda değer hedef türün sınırları içerisindeyse
	bilgi kaybı oluşmaz, sınırları dışında ise bilgi kaybı oluşur. Aşağıdaki örneği çeşitli değerler ile çalıştırıp
	sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			short b;
			
			b = (short)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %04X%n", b, b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			byte b;
			
			b = (byte)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %02X%n", b, b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			char b;
			
			b = (char)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %02X%n", (int)b, (int)b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10, b = -10;
		char c1, c2;
		
		c1 = (char)a;
		c2 = (char)b;
		
		System.out.printf("a = %d, a = %04X%n", a, a);
		System.out.printf("c1 = %d, c1 = %04X%n", (int)c1, (int)c1);
		System.out.printf("b = %d, b = %04X%n", b, b);
		System.out.printf("c2 = %d, c2 = %04X%n", (int)c2, (int)c2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c1 = 'D', c2 = '\uFFF6';
		short a, b;
		
		a = (short)c1;
		b = (short)c2;
		
		
		System.out.printf("c1 = %d, c1 = %04X%n", (int)c1, (int)c1);
		System.out.printf("a = %d, a = %04X%n", a, a);
		System.out.printf("c2 = %d, c2 = %04X%n", (int)c2, (int)c2);
		System.out.printf("b = %d, b = %04X%n", b, b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden byte türüne dönüşümde sayının yük anlamlı byte'ı atılır ve elde edilen değer byte türüne atanır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\uFFF6';
		byte b;		
		
		b = (byte)c;
		
		
		System.out.printf("c = %d, c = %04X%n", (int)c, (int)c);		
		System.out.printf("b = %d, b = %02X%n", b, b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada yapılır. Önce byte türüne ilişkin değer int türüne 
	dönüştürülür sonra elde edilen değerin yüksek anlamlı iki byte'ı atılır ve char türüne atılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			byte a = Byte.parseByte(kb.nextLine());			
			char c;
			
			c = (char)a;
			
			System.out.printf("a = %d, a = %02X%n", a, a);
			System.out.printf("a = %d, a = %08X%n", (int)a, (int)a);
			System.out.printf("c = %d, c = %04X%n", (int)c, (int)c);
			
			if (a == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne yapılan explicit dönüşümde double türüne ilişkin değerin IEEE 754 formatına göre 
	float türüne en yakın değeri elde edilir. Bu durumda yuvarlama hataları oluşabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			double a = Double.parseDouble(kb.nextLine());			
			float b;
			
			b = (float)a;
			
			System.out.printf("a = %.20f%n", a);
			System.out.printf("b = %.20f%n", b);
			
			if (a == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden hiç bir türe ve hiç bir türden boolean türüne explicit dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 1;
		int c;
		boolean d;
		
		c = (int)a; //error	
		d = (boolean)b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	15.10.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	int, short, long ve byte türlerine ilişkin en küçük ve en büyük değerler ilgili sınıfların MIN_VALUE ve MAX_VALUE
	elemanları ile elde edilebilir:
	
	Tür				En küçük Değer					En büyük değer
	int				Integer.MIN_VALUE				Integer.MAX_VALUE
	short			Short.MIN_VALUE					Short.MAX_VALUE
	long			Long.MIN_VALUE					Long.MAX_VALUE
	byte			Byte.MIN_VALUE					Byte.MAX_VALUE
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("byte:[%d, %d]%n", Byte.MIN_VALUE, Byte.MAX_VALUE);		
		System.out.printf("short:[%d, %d]%n", Short.MIN_VALUE, Short.MAX_VALUE);
		System.out.printf("int:[%d, %d]%n", Integer.MIN_VALUE, Integer.MAX_VALUE);
		System.out.printf("long:[%d, %d]%n", Long.MIN_VALUE, Long.MAX_VALUE);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir gerçek sayı türünden bir tamsayı türüne veya char türüne yapılan explicit dönüşüm şu şekilde gerçekleşir:
	- Sayının noktadan sonraki kısmı atılır
	
	- Elde edilen sayı hedef türün sınırları içerisindeyse hedef türe atanır
	
	- Elde edilen sayı hedef türün sınırları içerisinde değilse	
		- Hedef tür int, short, byte ve char türlerinden biriyse
			- Elde edilmiş olan değer int türü sınırları içerisindeyse tam sayılar arasındaki tür dönüşümü kuralları
			uygulanır. Yani int'den küçük türler için yüksek anlamlı byte değerleri atılır ve elde edilen değer hedef türe 
			atanır. Hedef tür int ise değer doğrudan atanır
			
			- Elde edilmiş olan değer int türü sınırları içerisinde değilse sayının pozitif ya da negatif olması 
			durumuna göre int türünün en büyük ve en küçük değeri alınır ve hedef türe dönüştürülür. Hedef tür int 
			ise int'in en büyük veya en küçük değeri atanır
			
		- Hedef tür long ise
			- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanır
			
			- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif ya da negatif olması durumuna
			göre long türünün en büyük ve en küçük değeri alınır atanır
			
	Aşağıdaki örnekleri inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 123.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 1236.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("1236 = %08X%n", 1236);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %02X%n", b);		
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 40000.45;
		short b;
		
		b = (short)a;
		
		System.out.printf("40000 = %08X%n", 40000);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %04X%n", b);		
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.45;
		int b;
		
		b = (int)a;
		
		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %08X%n", Integer.MAX_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);		
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_000.45;
		int b;
		
		b = (int)a;
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)-5_000_000_000L);
		System.out.printf("-2147483648 = %08X%n", Integer.MIN_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("5_000_000_000 = %02X%n", (byte)5_000_000_000L);
		System.out.printf("(byte)2147483647 = %08X%n", (byte)Integer.MAX_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %02X%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir. Aşağıdaki örneği tür dönüştürme operatörünü de
	kaldırarak çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			long c;
			
			c = (long)a + b;
			System.out.printf("%d + %d = %d%n", a, b, c);
			
			if (a == 0 && b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir. Aşağıdaki örneği tür dönüştürme operatörünü de
	kaldırarak çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int count = 0;
		int total = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			total += val;
			++count;			
		}
		
		double average = (double)total / count;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		
		for (int i = 0; i < 5; ++i) {
			System.out.print("Bir sayı giriniz:");
			total += Integer.parseInt(kb.nextLine());
		}
		
		double average = total / 5.;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		
		for (int i = 0; i < 5; ++i) {
			System.out.print("Bir sayı giriniz:");
			total += Integer.parseInt(kb.nextLine());
		}
		
		double average = total / 5D;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörlerinin genel biçimi aslında şu şekildedir:
		T1 ve T2 tür isimleri olmak üzere
		T1 a;
		T2 b;
		
	için
		a <op>= b;
	işlemi
		a = (T1)(a <op> b)
	Örneğin:
		int a;
		double b;
		
		//...
		
		a += b; 
	ifadesinin karşılığı
		a = (int)(a + b)	
		
	Aşağıdaki örneği inceleyiniz	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sayının basamak sayısını bulan metot aşağıdaki gibi döngü kullanmadan yazılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		if (val == 0)
			return 1;
		
		return (int)Math.log10(Math.abs(val)) + 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul Operatörü (Conditional/Ternary Operator): Bu operatör özel amaçlı, üç operandlı (ternary) ve araek (infix) 
	durumundadır. Operatörün genel biçimi şu şekildedir:
		<ifade1> ? <ifade2> : <ifade3>
	Burada ifade1'in yani birinci operandın boolean türden olması zorunludur.  Bu operatör birinci operandının değeri
	true ise ikinci operandının değerini, false ise üçüncü operandının değerini üretir. Bu operatörün yan etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen deyimin if deyimi ile yapılışı şu şekildedir:
		if (a > b)
			max = a;
		else 
			max = b;
	Şüphesiz şu şekilde de yapılabilir:
		max = a;
		if (a < b)
			max = b;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int max;
		
		max = a > b ? a : b; //**
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün üçüncü operandı b - 200 ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a > b ? a + 100 : b - 200;
		
		System.out.printf("result = %d%n", result);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün üçüncü operandı b ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = (a > b ? a + 100 : b) - 200; 
		
		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	21.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı a + a > b ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a + a > b ? a : b;
		
		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün ürettiği değer a ile toplama işlemine sokulmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a + (a > b ? a : b);
		
		System.out.printf("result = %d%n", result);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörü if deyimine alternatif gibi görünse de doğrudan değildir. Bu anlamda koşul operarörü okunabilirlik
	açısından tercih edilebilir. Aslında koşul operatörünün okunabilirlik açısından tercih edilebileceği durumlar
	tipik atama işlemleridir:
		- Yalın atama operatörü ile yapılan atama işlemi
		- Metot çağrısında argümanlardan parametrelere yapılan atama işlemi
		- Metodun geri dönüş değerinin geçici değişkene yapılan atama işlemi
	Bazen de ifadeyi karmaşıklaştırmamak koşuluyla (yine okunabilirlik açısından karmaşık olmaması) ürettiği
	değerin işleme sokulması durumunda da tercih edilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte yalın atama işleminde if deyimi yerine koşul operatörü kullanmak okunabilirliği artırır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int max;
		
		max = a > b ? a : b;
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörüne ilişkin ifade argüman olarak printf metoduna geçirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("max(%d, %d) = %d%n", a, b, a > b ? a : b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü return deyiminde kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("max(%d, %d) = %d%n", a, b, Util.max(a, b));
	}
}

class Util {
	public static int max(int a, int b)
	{
		return a > b ? a : b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü return deyiminde kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		
		System.out.printf("result = %d%n", Util.addWithMax(a, b, c));
	}
}

class Util {
	public static int addWithMax(int a, int b, int c)
	{
		return (a > b ? a : b) + c;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}	
	
		switch (getDayOfWeek(day, month, year)) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);						
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 2 -> System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		}
	}
	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? getDayOfYearValue(day, month, year) : -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += isLeapYear(year) ? 29 : 28;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{		
		return switch (month) {
			case 4, 6, 9, 11 -> 30;			
			case 2 -> isLeapYear(year) ? 29 : 28;
			default -> 31;
		};
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte void metotlar dolayısıyla error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a > 0 ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü işleme sokulmadığı için error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a > 0 ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		
		return 10;
	}
	
	public static void bar()
	{
		System.out.println("bar");
		
		return 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek if deyimi ile yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		if (a > 0)
			Sample.foo();
		else 
			Sample.bar();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 3 tane sayının en büyüğü bulunmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = a > b ? a > c ? a : c : b > c ? b : c;
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki koşul operatörüne ilişkin ifadenin daha okunabilir hale getirilmesi için sentaks olarak gerekmese de
	parantezler konulabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = (a > b) ? (a > c ? a : c) : (b > c ? b : c);
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = NumberUtil.max(a, b, c);
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

class NumberUtil {
	public static int max(int a, int b, int c)
	{
		return (a > b) ? (a > c ? a : c) : (b > c ? b : c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde aynı isimde birden fazla metot bildirilmesi durumu (method overloading): Bir sınıf içerisinde
	aynı isimde birden fazla metot bildirilebilir. Buna method overloading denir. Farklı sınıflarda aynı isimde metotların
	olması method overloading değildir. Method overloading için şu iki sorunun cevaplarını ele alacağız:
		- Method overloading kuralları nelerdir?
		- Derleyici bir metot çağrıldığında hangi metodun çağrılacağına nasıl karar verecektir? (method overload resolution)
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte method overloading yapılmamıştır. Çünkü foo metotları ayrı sınıflardadır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
		Mample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}
}

class Mample {
	public static void foo()
	{
		System.out.println("Mample.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde birden fazla AYNI metottan bildirilemez. Yani bir sınıf içerisinde metotların FARKLI olması
	gerekir. Bu durumda iki metodun AYNI ya da FARKLI olması durumlarının incelenmesi gerekir. İşte burada iki metodun
	AYNI ya da FARKLı olması durumlarına yönelik detaylar ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İki metodun erişim belirleyicilerinin farklı olması o iki metodu farklı yapmaz. Yani overload işlemine etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}
	
	private static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki metodun static veya non-static olması durumu metotları farklı yapmaz. Bu durumda overload'a etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}
	
	public void foo() //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İki metodun geri dönüş değerlerinin farklı olması da metotları farklı yapmaz. Yani overload'a etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo() //error
	{
		//...
	}
	
	public static int foo() //error
	{
		//...
		
		return 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İki metodun parametre değişkenlerinin isimlerinin farklı olması da metotları farklı yapmaz. Yani parametre değişken
	isimlerinin overload işlemine etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a) //error
	{
		//...
	}
	
	public static void foo(int b) //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun overload edilebilmesi için parametrelerin türlerinin ve dizilimlerinin farklı olması gerekir. Bu anlamda
	bir metodun parametrelerinin türlerine ve dizilimlerine parametrik yapısı diyebiliriz. Yani bu durumda bir metodun
	overload edilebilmesi için parametrik yapısının diğer aynı isimde olan metotlardan farklı olması gerekir. Aşağıdaki
	metotları inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{
		//...
	}
	
	public static void foo(int a)
	{
		//...
	}
	
	public static void foo(double a)
	{
		//...
	}
	
	public static void foo(double a, int b)
	{
		//...
	}
	
	public static void foo(int a, double b)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun imzası (signature) o metodun ismi ve parametrik yapı kombinasyonudur. Bir sınıf içerisinde aynı imzaya
	sahip birden fazla metot bildirimi geçersizdir. Aslında method overloading bu kavramın özel bir durumudur. İki
	metodun ismi aynı olacağına göre, imzaların farklı olması için parametrik yapısının farklı olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //imza: foo
	{
		//...
	}
	
	public static void foo(int a) //imza: foo, int
	{
		//...
	}
	
	public static void foo(double a) //imza: foo, double
	{
		//...
	}
	
	public static void foo(double a, int b) //imza: foo, double, int
	{
		//...
	}
	
	public static void foo(int b, double a) //imza: foo, int, double
	{
		//...
	}
	
	public static void bar(int b, double a) //imza:bar, int, double
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir metot çağrısı gördüğünde hangi metodu çağrılacağına nasıl karar verecektir? Bu durumun ayrıntıları 
	vardır ve bu bölümde ele alınacaktır. Bu kavrama "method overload resolution" ya da kısaca "overload resolution"
	denir.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Overload resolution işleminde derleyici ismini en uygun metot (the most applicable) denilen metodu bulmaya çalışır. 
	Bunun için derleyici birazdan ele alacağımız sırayla metotları seçer. Ancak bu seçimin özel bir durumu olarak 
	çağrılan metoda geçilen argümanlar ile karşılık gelen parametrelerinin tür bakımından birebir uyumlu olduğu bir
	metot varsa o çağrılır. Bu kavrama "tam uyum (best match)" denir. 
	
	Derleyici overload resolution işlemini şu adımlardan geçerek yapar:
	1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır. 
	
	2. Uygun metotlar (applicable methods) belirlenir: Çağrı sırasında geçilen argüman sayı ile parametre sayısı olan
	VE argümanların türünden karşılık geldikleri parametrenin türüne otomatik (implicit) tür dönüşümünün geçerli olduğu
	metotlardır. 
	
	3. En uygun metot (the most applicable method) belirlenir: En uygun metot öyle bir metottur ki, uygun metotlar
	arasında argümanlar ile parametreler kalite yarışına sokulduğunda toplamda daha iyi olan veya daha kötü olmayan
	metottur. Dönüşümün kalitesi şu şekilde belirlenir:
	T1 argümanın, T2 ve T3'de yarışa sokulan parametrelerin türleri ise:
	1. T1 -> T2 ve T1 -> T3 çağrıları yarışa sokulduğunda T2 veya T3'den birisi T1 ile aynı ise daha kalitelidir.
	Örneğin:
	int -> double
	int -> int *
	
	2. T1 -> T2 ve T1 -> T3 çağrıları yarışa sokulduğunda T2'den T3' otomatik dönüşüm var, T3'den T2'ye yoksa
	T2 daha kalitelidir. 
	Örneğin:
 	int -> long *
 	int -> float
	
	Bu adımlardan herhangi birisinde bir metot bulunamazsa error oluşur. Yani aday metot bulunamazsa VEYA aday
	metotlar var fakat uygun metot bulunamazsa VEYA uygun metotlar var en uygun metot bulunamazsa error oluşur. 
	  
	Anahtar Notlar: Aslında best match de yukarıda anlatılan biçimde yapılır. Ancak kolay anlaşılır olması açısından
	bu şekilde anlatılmıştır.
	
	Anahtar Notlar: Şüphesiz tam uyumlu çağrılar en idealidir. Ancak her zaman bu şekilde olmayabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki çağrıda tam uyum vardır. Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 5, 6
	3. En uygun metot: 5
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 4;
		
		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}
	
	public static void foo(double a, int b) //4
	{
		System.out.println("foo, double, int");
	}
	
	public static void foo(int b, double a) //5
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //6
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //7
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: 4
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //5
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: Yok
	
	Örnekte en uygun metot olmadığından yani "uygun metotlar arasında toplamda daha iyi ya da ya da daha kötü olmayan
	dönüşümü sunan" bir tane metot bulunmadığından error oluşur. Bu duruma iki anlamlılık (ambiguity) denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, b); //error: ambiguity
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	28.10.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: Yok
	
	Örnekte uygun metot bulunamadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 4;
		
		Sample.foo(a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: Yok
	Örnekte aday metot bulunamadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 4;
		
		Sample.fo(a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4
	3. En uygun metot: 4
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, (double)b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: 5
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo((int)a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a,  float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki çağrıda tam uyum vardır. Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4
	3. En uygun metot: 4
	
	Örnekte best match olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 4;
		
		Sample.foo((double)a, (int)b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}
	
	public static void foo(double a, int b) //4
	{
		System.out.println("foo, double, int");
	}
	
	public static void foo(int b, double a) //5
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //6
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Method overload resolution kavramının temel türler dışındaki bazı ayrıntıları konular içerisinde
	ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yönelimli Programalama Tekniği (Object Oriented Programming): Nesne yönelimli programlama tekniğini (NYPT) tek
	bir cümle ifade etmek etmek pek mümkün değildir. Ancak bu tekniği bilen veya belirli ölçüde fikri olan birisine
	"sınıflar kullanarak program yazma tekniğidir" denebilir. NYPT aslında anahtar kavramların birleşiminden oluşur. Bu 
	anahtar kavramlar içiçe geçmiş daireler biçiminde düşünülebilir. Tüm bu anahtar kavramların temelinde kodun
	okunabilir/algılanabilir olması ve iyi yönetilmesi vardır. Örneğin, benzer işi yapan metotlara aynı ismin verilmesi
	(method overloading) programcıyı "çok şey var" duygusundan uzaklaştırıp, "az şey var" gibi bir algı oluşuturur. Bu
	da hatırlamayı kolaylaştırır ve kodun okunabilirliğini/algılanabilirliğini artırır
	
	NYPT insanının doğayı algılama biçimini model alır. İnsanlar her şeyi nesne biçiminde ele alıp kullanırlar. Örneğin
	herkesin bilgisayarı olabilse de konuşurken bunu bilgisayar olarak konuşuruz. Yani aslında bilgisayar soyut bir
	kavramdır, örneğin bize ait olan bir bilgisayar somutlaşmıştır. Bu anlamda, herkesin sahip olduğu şey (thing) 
	bilgisayardır. 
	
	NYPT'de artık fonksiyonlarla (Java'da metot) değil sınıflarla konuşulur. Böylece yine "çok şey var" duygusundan 
	uzakkaşıp, "az şey var" algısı oluşur. Bu anlamda sınıf ve nesne seviyesinde detaylar programcıdan gizlenmiş olur.
	Bu da yine algıyı kolaylaştırır.
	
	Burada anlatıların pek çok detayı vardır. Burada bir özet biçiminde ele alınmıştır. Bu kavramlar ve burada anlatılmayanlar
	Konular içerisinde detaylandırılacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	29.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi bir değişkenin bellekte yaratılmasıyla yani yer ayrılmasıyla, yok edilmesi yani o bellek alanının 
	o değişken içi artık kullanılmaması arasındaki süreye değişkenin ömrü (storage duration) denir. Peki, bir değişken
	için ayrılan bellek bölgesi neresidir? İşte bir Java uygulaması çalıştırıldığında o uygulama için iki tane
	bellek alanı ayrılır: stack, heap. Şüphesiz aşağı seviyede başka bir alanlar da söz konusudur. Stack ve heap, Java 
	seviyesinde ayrılan alanlar olarak düşünülebilir. Stack ve heap RAM'de organize edilir. Program çalıştırılırken bu 
	alanların uzunlukları ayarlanabilir. Herhangi bir belirleme yapılmazsa default uzunluklar kullanılır.
	
	
	Anahtar Notlar: Veri Yapıları (Data Structure): Birbiriyile genel olarak ilişkili olan verilerin belirli bir takım
	algoritmalara göre bir arada tutulmasını sağlayan ve gerektiğinde bu verilere erişilebilen yapılara denir. Stack 
	Last In First Out (LIFO) kuyruk biçiminde çalışan bir veri yapısıdır. Bu veri yapısında eleman ekleme işlemine "push",
	son eklenen elemanı silme işlemine ise "pop" denilmektedir. Bu veri yapısı örneğin editörlerin "undo-redo"
	işlemlerinde kullanılır. Örneğin undo yapıldığında undo stack'den pop yapılır ve redo stack'e push yapılır. Redo 
	yapıldığında ise redo stack'ten pop yapılır, undo stack'e push yapılır. Stack alanında yaratma ve yok etme işlemleri 
	stack veri yapısındaki gibi olduğundan bu alana stack alanı denir. Aslında stack alanı donanımsal olarak da 
	desteklenen bir yapıdır.
	
	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılır. Stack doldur boşalt biçiminde çalışan bir
	bellek alanıdır. Böylece toplamda uzunluğundan daha fazla değişken için yer ayrılabilir.     
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenler akış kod bakımından bildirim noktasına geldiğinde yaratılırlar, bildirildikleri blok sonunda yok 
	edilirler. Bu durumda bir yerel değişkeninin yaratılması push komutuyla, yok edilmesi ise pop komutuyla yapılır. Bu 
	durumda peşpeşe bildirilen yerel değişkenler sırasıyla push edilir, ters sırada pop edilir. Bu durumda faaliyet alanı (scope)
	ve ömür (storage duration) arasında dolaylı bir ilişki de vardır. Anımsanacağı gibi compile time ve runtime'a ilişkin
	ayrı kavramlardır   
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			int a; //a yaratılır
			int b; //b yaratılır
			
			//...
		} // b yok edilir, a yok edilir
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Parametre değişkenleri metot çağrıldığında yaratılır, metot çağrısı bittiğinde yok edilir   
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10, 20); //Parametre değişkenleri a ve b yaratılır, x yaratılır ...
		//x yok edilir, b ve a yok edilir
		
		//...
		
		Sample.foo(10, 20); //Parametre değişkenleri a ve b yaratılır, x yaratılır ...
		//x yok edilir, b ve a yok edilir
	}
}

class Sample {
	public static void foo(int a, double b)
	{
		int x;
		
		x = a++;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf içerisinde, tüm metotların dışında bildirilen değişkenlere sınıf veri elemanı (class data member) denir. 
	Bu anlamda sınıf veri elemanları sınıf içerisinde bildirilen değişkenler olarak düşünülmelidir. Veri elemanları
	şu erişim belirleyicilere sahip olabililr: public, no-modifier, protected, private. İlgili konuya gelene kadar
	tüm veri elemanlarını public olarak bildireceğiz. Bir veri elemanı static veya non-static olabilir. static anahtar
	sözcüğü ile bildirildiğinde static olur. 
	
	Anahtar Notlar: Sınıf içerisindeki bildirimlere sınıfın elemanları (member) denir. Bu anlamda sınıfın elemanı bir
	değişken ise buna veri elemanı (data member, member variable, field) denir. Sınıfın elemanı bir alt program ise
	buna metot (method) denir. Sınıfın ilerideki konularda ele alacağımız başka elemanları da (member) olabilmektedir
	
	Bir veri elemanının faaliyet alanı ve ömrü ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	private static int x;
	public static void foo()
	{
		
	}
	
	public double y;
	protected static float z;
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da sınıf dışında değişken bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

int a; //error

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf bildirimi aslında bir tür bildirimidir. Bu anlamda Java'da sınıf dışında da çeşitli tür bildirimleri 
	yapılabilmektedir. Bu şekilde yapılan tür bildirimlerine user defined types (UDT) denilmektedir. Bu durumda bir 
	sınıf da bir UDT'dir. Aşağıdaki sınıfların her biri bir UDT'dir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Madem ki sınıf bildirimi bir tür bildirimidir, bu durumda sınıf türünden değişkenler bildirilebilir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s;
		SerialPort sp;
		Device d;
		
		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da türler kategoriye ikiye ayrılır: değer türleri (value types), referans türleri (reference types)
	T bir tür ismi olmak üzere T türden bir değişken içerisinde adres tutuluyorsa T bir referans türüdür, tutulmuyorsa
	değer türüdür. Java'da tüm temel türler değer türüdür. Yani temel türden bir değişken içerisinde adres tutulamaz.
	Sınıflar Java'da referans türleridir. Yani bir sınıf türünden değişken içerisinde adres tutulur. Aslında genel olarak
	temel türler dışında tüm türler (UDT'ler) Java'da referans türleridir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf türünden bir değişkene referans değişken ya da kısaca referans denir. Java seviyesinde referans terimi
	adres (address) terimi yerine de kullanılmaktadır. Bu anlamda referans dendiğinde ya bir adres kastedilmiş olur
	ya da adres tutabilen referans değişken kastedilmiş olur. Örneğin bir cümle içerisinde "reference of an object"
	dendiğinde nesnenin adresi kastedilir. Ya da örneğin, "address of an object is assigned to a reference" dendiğinde
	nesnenin adresini tutan referans kastedilmiş olur
	
	Peki bu referanslara nasıl değer atanacak?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s; //s referans (değişkeni)
		SerialPort sp; //sp referans (değişkeni)
		Device d; //d referans (değişkeni)
	
		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	- Sınıf türünden bellekte ayrılan bir alana nesne (object) denir.
	
	- Nesneler heap alanında yaratılırlar. Java'da stack'de nesne yaratılamaz.
	
	- Java'da nesnelerin kendileri tutulamaz, adresleri tutulabilir. Bu adresler de aynı türden referans değişkenlerde 
	tutulabilir
	
	- Bir nesne new operatörü ile yaratılabilir. new operatörünün genel biçimi şu şekildedir:
	
	 	new <sınıf ismi>([argümanlar]);
	 	
	 Bu operatör özel amaçlı, tek operandlı ve önek durumundadır. bu operatör bellekte ilgili türden nesnenin yaratılmasını
	 sağlar ve yarattığı nesnenin adresini (referansını) üretir. Bir nesne için bellekte ne kadar uzunlukta yer ayrıldığı
	 ileride ele alınacaktır. Aşağıdaki örnekte s, sp ve d birer nesne DEĞİLDİR. Nesnelerin adreslerini tutan değişkenlerdir.
	 Örnekte *, ** ve *** ilem belirtilen deyimlerde ilgili referanslara, yaratılmış olan nesnelerin adresleri atanmıştır.
	 Bu durumda artık ilgili referanslar nesneleri gösteriyor (reference to) duruma gelir. 
	 
	 - Bir nesne ilgili sınıf türünden bir örnektir. Buna ingilizce olarak "instance" terimi de kullanılır. Bu anlamda
	 nesne yaratma içinde "create" ile birlikte "instantiate" fiili de kullanılmaktadır.
	 
	 - Referans ve nesne birbirlerinden farklı kavramlardır. Referans bir nesneyi gösterir ya da adres anlamında 
	 kullanıldığında nesnenin adresidir
	 
	 - Her new işlemi yeni bir nesne yaratmak demektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s; //s referans (değişkeni)
		SerialPort sp; //sp referans (değişkeni)
		Device d; //d referans (değişkeni)
		
		s = new Student(); //*
		sp = new SerialPort(); //**
		d = new Device(); //***

		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static veri elemanları her nesne için ayrıca yaratılır. Yani sınıfın non-static bir veri elemanı o sınıf
	türünden bir nesnenin içerisinde bulunur. Yani o nesneye özeldir. Sınıfın non-static bir veri elemanına sınıf dışından 
	referans ve nokta operatörü ile erişilebilir. Nokta operatörü özel amaçlı iki operandlı ve araek durumundadır. Nokta
	operatörünün referans ile kullanımında ikinci operandı sınıfın veri elemanı ise o veri elemanına ilişkin değişkeni 
	üretir. Bu durumda referans ile erişim hangi nesneye ait olduğunu belirtmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.x = 10;
		s.y = true;
		k.x = 20;
		k.y = false;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir nesne yaratıldığında o nesnenin non-static veri elemanlarına default değerler atanır. Default değer türe özgü
	mantıksal sıfır değeridir (zero value or default value). Örneğin, int türü için sıfır değeriyken boolean türü için 
	false değeridir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s;
		
		s = new Sample();
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		
		s.x = 10;
		s.y = true;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içerisine değer atanmamış bir değişken kullanıldığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s;
		
		s.x = 10;
		s.y = true;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	04.11.2023	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	İki tane aynı türden referansın birbirine atanması durumunda artık her iki referans da aynı nesneyi gösterir duruma
	gelir. Bu durumda hangi referans ile nesneye erişilmesinin önemi yoktur. Çünkü her iki referans ile de aynı nesneye
	erişilir. Aşağıdaki örnekte k = s atama işleminden sonra k ve s aynı nesneyi gösterir duruma gelmiştir. Bu durumda
	herhangi bir referans üzerinden yapılan bir değişiklik diğer referans ile erişilerek de görülebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k;
		
		s.x = 10;
		s.y = true;
		
		k = s;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		
		++k.x;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
	}
}


class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte adres ataması yapılmadığı için, yani atanan "ŞEY" bir adres olmadığı için b'nin değişmesi a'yı 
	 etkilemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b;
		
		b = a;
		
		System.out.printf("a = %d, b = %d%n", a, b);
		
		++b;
		
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir nesnenin uzunluğu en az non-static veri elemanlarının toplam uzunluğu kadarıdır. Aynı türden nesnelerin uzunlukları
	aynıdır. Yani başka bir deyişle aynı türden her nesne için bellekte aynı uzunlukta yer ayrılır. Ancak nesneler farklı
	türdense aynı uzunlukta olmaları gerekmez. Bir referansın uzunluğu sistemden sisteme farklılık gösterir. Örneğin 
	64 bit sistemlerde 8 byte iken, 32 bit sistemlerde 4 byte'dır. Türü ne olursa olsun tüm referansların uzunluğu o 
	sistem için aynıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Farklı türden referanslar birbirine explicit olarak bile atanamazlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Mample m;
		
		m = (Mample)s; //error
	}
}


class Sample {
	public int x;
	public boolean y;
	
	//...
}

class Mample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi Java'da 3 yerde atama yapılabilir. İstisna bir takım kurallar dışında atama işlemlerine ilişkin
	kurallar hepsi için geçerlidir. Bir metodun parametre değişkeni bir referans olabilir. Bu durumda metot aynı türden
	bir referans ile çağrılabilir. Bu durumda metot içerisinde argüman olarak geçilen referansa ilişkin nesneye 
	erişilebilir. Bir metodun parametre geri dönüş değeri bir referans olabilir. Bu durumda return deyimine ilişkin
	ifadenin de aynı türden bir referans olması gerekir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Date d = DateUtil.createDate(11, 7, 1983);
		
		DateUtil.printDate(d);		
		DateUtil.changeDate(d, 6, 9, 2021);
		DateUtil.printDate(d);
	}
}

class DateUtil {
	public static Date createDate(int day, int month, int year)
	{
		//...
		Date date = new Date();
		
		date.day = day;
		date.month = month;
		date.year = year;
		
		return date;
	}
	
	public static void changeDate(Date date, int day, int month, int year)
	{
		//...
		date.day = day;
		date.month = month;
		date.year = year;
	}
	
	public static void printDate(Date date)
	{
		System.out.printf("%02d/%02d/%04d%n", date.day, date.month, date.year);
	}
}

class Date {
	public int day, month, year;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	05.11.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte adres ataması yapılmadığı için, yani atanan "ŞEY" bir adres olmadığı için a'nın değişmesi b'yi 
	etkilemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int b = 10;
		
		Sample.foo(b);
		
		System.out.printf("b = %d%n", b);
	}
}

class Sample {
	public static void foo(int a)
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen deyimden sonra s artık yeni nesneyi gösterir durumdadır. Her new işleminin yeni
	bir nesne yaratmak anlamına geldiğini anımsayınız
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k;
		
		s.x = 10;
		s.y = true;
		
		k = s;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
		
		++k.x;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
		
		s = new Sample(); //**
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static veri elemanları nesneye ait değildir. Yani static veri elemanlarına erişim için nesne yaratılması
	gerekmez. Sınıfın static veri elemanı sınıfın bir elemanı (member) ilk kez kullanıldığında yaratılır ve program
	sonuna kadar yaşar. Sınıfın bir elemanı ilk kez kullanıldığından tüm static veri elemanları yaratılırlar. Bu durumda
	sınıfın static bir veri elemanı toplamda bir tanedir. Sınıfın static bir veri elemanına sınıf dışından sınıf ismi ve
	nokta operatörü ile erişilir. Sınıfın static bir veri elemanı yaratıldığında default değer verilir. Sınıfın static
	bir veri elemanı stack'de yaratılamaz. Aşağı seviyede değişebilse de Java programcısı açısından "dolaylı olarak 
	heap'de yaratılır" olarak düşünülebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
		Sample.x = 10;
		Sample.y = true;
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
	}
}

class Sample {
	public static int x;
	public static boolean y;
	
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilemez. Çünkü non-static
	veri elemanları nesneye aittir ve referans olmadan hangi nesneye ait olduğu bilinemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.x = 10; //error
		Sample.y = true; //error
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir veri elemanına sınıf dışından referans ve nokta operatörü ile de erişilebilir. Ancak bunun sınıf
	ismi ile erişmekten hiç bir farkı yoktur. Bu dilin garamerinin bir sonucudur. Ancak programcı açısından bu tercih
	edilmemesi gereken bir kullanımdır. Çünkü okunabililirliği/algılanabilirliği olumsuz etkiler. Bu anlamda programcı
	açısından bu adeta geçersiz gibi düşünülmelidir (gönlümüzün error'u).
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
	
		s.x = 10;
		s.y = true;
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
	}
}

class Sample {
	public static int x;
	public static boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte yaratıkların sayısı ve askerlerin sayısı sınıfları kullanan programcı tarafından tutulmaktadır
	Bu durumda diğer türler için de sayaçlar tutulacaksa programcı açısından iki temel sorun oluşabilecektir:
	1. İlgili değişkenlere isim bulma zahmeti oluşacaktır
	2. Programcı sayaçları artırma ve azaltma işlemlerinde hata yapabilir
	
	Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DemoGameApp.run();
	}
}

class DemoGameApp {
	public static void run()
	{
		int soldierCount = 0;
		int alienCount = 0;
		
		for (int i = 0; i < 10; ++i) {
			Alien a = new Alien();
			
			++alienCount;
			
			//...
		}
		
		for (int i = 0; i < 20; ++i) {
			Soldier s = new Soldier();
			
			++soldierCount;
			
			//...
		}
		
		System.out.printf("Number of aliens:%d%n", alienCount);
		System.out.printf("Number of soldiers:%d%n", soldierCount);
		//...
	}
}

class Alien {
	public int armCount;
	public int color;
	//...
}

class Soldier {
	public int title;
	public int gunCount;
	//...
}

class Building {
	//...
}

class Animal {
	//...
}

class Citizen {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problemler, sayaç sınıf içerisinde static bir veri elemanı olarak bildirilirse çözülebilir. Aşağıdaki
	örnekte sayacın artırılması noktası şu an için önemsizdir. Static ve non-static veri elemanının kullanımına 
	odaklanınız. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DemoGameApp.run();
	}
}

class DemoGameApp {
	public static void run()
	{
		for (int i = 0; i < 10; ++i) {
			Alien a = new Alien();
	
			//...
		}
		
		for (int i = 0; i < 20; ++i) {
			Soldier s = new Soldier();
			
			//...
		}
		
		System.out.printf("Number of aliens:%d%n", Alien.count);
		System.out.printf("Number of soldiers:%d%n", Soldier.count);
		//...
	}
}

class Alien {
	public static int count;
	public int armCount;
	public int color;
	//...
	
	public Alien()
	{
		++count;
	}
	//...
}

class Soldier {
	public static int count;
	public int title;
	public int gunCount;
	//...
	
	public Soldier()
	{
		++count;
	}
	//...
}

class Building {
	public static int count;
	//...
}

class Animal {
	public static int count;
	//...
}

class Citizen {
	public static int count;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.foo();
		k.foo();
	}
}

class Sample {
	public void foo()
	{
		System.out.println("foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu sınıf dışından sınıf ismi ile çağrılamaz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample {
	public void foo()
	{
		System.out.println("foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılabilir. Bunu zaten kursun ilk 
	günlerinden beri kullanıyoruz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu sınıf dışından referans ve nokta operatörü ile de çağrılabilir. Ancak sınıf ismi ile 
	çağırmaktan farkı yoktur. Programcı static metotları her zaman sınıf ismi ile çağırmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo(); //gönlümüzün error'u
	}
}

class Sample {
	//...
	public static void foo()
	{
		System.out.println("foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Static ve non-static metotların çağrılma biçimine bakıldığında non-static metotların nesne ile
	ilişkili olduğu, static metotların ise nesne ile ilişkili olmadığı anlaşılmaktadır. Bu ilişki ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki erişimlerin hepsinin ilgili sınıfın dışından yapılan erişimler olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde, aynı sınıfın non-static bir veri elemanına doğrudan (nokta operatörü kullanmadan)
	erişilebilir. Bu durumda erişilen non-static veri elemanı non-static metodun çağrısında kullanılan referansın 
	gösterdiği nesneye ait olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.set(10);
		k.set(20);
		s.print();
		k.print();
	}
}

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public void print()
	{
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde, aynı sınıfın non-static bir metodu doğrudan çağrılabilir. Bu durumda
	çağrılan non-static metot, onu çağıran non-static metodun çağrılmasında kullanılan referans ile çağrılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.setAndPrint(10);
		k.setAndPrint(20);
	}
}

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public void setAndPrint(int a)
	{
		set(a);
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın non-static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	11.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde aynı sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.y = %d%n", Sample.y);
		Sample s = new Sample();
		
		s.set(20);
		System.out.printf("Sample.y = %d%n", Sample.y);
	}
}

class Sample {
	public int x;
	public static int y;
	 
	public void set(int a)
	{
		x = a;
		y = ++a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde aynı sınıfın static bir metodu doğrudan çağrılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.y = %d%n", Sample.y);
		Sample s = new Sample();
		
		s.set(20);
		System.out.printf("Sample.y = %d%n", Sample.y);
	}
}

class Sample {
	public int x;
	public static int y;
	 
	public void set(int a)
	{
		x = a;
		setY(++x);
	}
	
	public static void setY(int b)
	{
		y = b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki dört kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın tüm elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir veri elemanına doğrudan erişilemez 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public static void set(int a)
	{
		x = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir metodu doğrudan çağrılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public static void setAndPrint(int a)
	{
		set(a); //error
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın static bir metodu içerisinde aynı sınıfın non-static elemanlarına doğrudan
	erişilemez
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın static bir veri elemanına doğrudan erişilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d%n", Sample.x);
		Sample.set(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	 
	public static void set(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın static bir metodu doğrudan çağrılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d%n", Sample.x);
		Sample.setAndPrint(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	 
	public static void set(int a)
	{
		x = a;
	}
	
	public static void setAndPrint(int a)
	{
		set(a);
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın static bir metodu içerisinde aynı sınıfın static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki dört kurala göre sınıfın static bir metodu içerisinde aynı sınıfın yalnızca static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki sekiz kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın tüm elemanlarına doğrudan
	erişilebilirken, static bir metodu içerisinde yalnızca static elemanlarına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programcı bir metodu static mi non-static mi yazacağına nasıl karar verecektir? Bir metot non-static bir elemana
	doğrudan erişmeyecekse static yapılmalıdır. Yani bir metodun çağrılması için ortada bir nesnenin olması gerekmiyorsa
	metot static yapılmalıdır. Böylelikle, bir metodun static yapılması, non-static bir metodun okunabilirliğini 
	artırır. Çünkü, bu convention ile kodu okuyan kişi non-static bir metot gördüğünde metodun sınıfın non-static bir
	elemanına erişitiğini yani ortada bir nesnenin olması gerektiğini anlar 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dorğudan erişim yapılmadığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public static void set(int a)
	{
		Sample s = new Sample();
		
		s.x = 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.print();
		p2.print();
		
		p1.x = 3.456;
		p1.y = 567.89;
		p2.x = 400;
		p2.y = -345;
		
		p1.print();
		p2.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 10;
		p1.y = 20;
		p2.x = -345;
		p2.y = 400;
		
		p1.print();
		p2.print();
		
		p1.offset(-10, 20);
		p2.offset(-20);
		
		p1.print();
		p2.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 100;
		p1.y = 200;
		p2.x = 103;
		p2.y = 196;
		
		p1.print();
		p2.print();
		
		double dist = p1.distance(p2);
		
		System.out.printf("Distance:%f%n", dist);
		
		dist = p1.distance(103, 196);
		
		System.out.printf("Distance:%f%n", dist);
		
		dist = p1.distance();
		
		System.out.printf("Distance:%f%n", dist);
	}
}

class Point {
	public double x, y;
	
	//...
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	12.11.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yaratılması Adımları: Nesne yaratılması 3 tane adımın sonunda tamamlanmaktadır. Yani akış new operatörüne 
	geldiğinde aşağıdaki 3 adım tamamlanınca nesne yaratılmış olur yani başka bir deyişle nesnenin adresi elde edilmiş
	olur. Adımlar şunlardır:
	1. Bellekte yer ayrılır.
	2. non-static olan ve final olmayan veri elemanlarına default değerler verilir.
	3. Constructor (ctor) çağrılır.
	
	Bu 3 adımdan herhangi bir tanesinde bir problem olursa örneğin ctor içerisinde exception oluşursa nesnenin
	yaratılması tamamlanmamış olur ve adres elde edilemez. Yine örneğn heap de yer kalmaması durumunda 1. adımda yer 
	ayrılamayacağından nesne yaratılamaz. Yani nesnenin yaratılması için kesinlikle bu 3 adımın da tamamlanmış olması 
	gerekir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı herhangi bir ctor yazmazsa derleyici tarafından parametresiz ctor public ve içi boş olarak
	yazılır. Parametresiz ctor'a default ctor denilmektedir. Programcı sınıfa herhangi ctor yazarsa derleyici artık
	default ctor'u yazmaz. Artık default ctor gerekirse sınıfı yazan programcı tarafından yazılmalıdır. 

	- Ctor sınıf ismi ile aynı isimde olan ve geri dönüş değeri kavramı olmayan (void da yazılmayan) bir metottur. 
	Sınıf ismi ile aynı isimde olan bir metoda geri dönüş değeri bilgisi yazıldığında error oluşmaz ancak bu artık ctor 
	değildir. Şüphesiz sınıf ismi ile aynı isimde olan ancak ctor olmayan bir metot yazılmamalıdır.
	
	- Ctor'un da metotlarda olduğu gibi erişim belirleyicisi olabilir.
	
	- Ctor overload edilebilir.
	
	- Hangi ctor'un çağrılacağı ne operatöründe geçilen argümanlara göre method overload resolution kurallarına göre
	belirlenir. 
	
	- Ctor non-static bir metottur. Bu anlamda sınıfın non-static elemanlarına (tabii ki static elemanları da) doğrudan
	erişilebilir.
	
	- Ctor'dan önce non-static olan ve final olmayan veri elemanlarına default değerler verilir.
	
	- Ctor içerisinde istenirse sonlandırmak için void bir metot gibi return deyimi tek başına kullanılabilir. Bu sonlandırma
	normal bir sonlandırmadır yani nesnenin yaratılması tamamlanmış olur.
	
	- Programcı ctor'u çağıramaz. Programcı ctor'un çağrılmasına yol açan kodu yazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(); //default ctor
		
		System.out.println("------------------------------------------");
		Sample s2 = new Sample(10); //Sample, int
		
		System.out.println("------------------------------------------");
		Sample s3 = new Sample('a'); //Sample, int
		
		System.out.println("------------------------------------------");
		
		Sample s4 = new Sample(10, 2.3); //Sample, int, double
		
		System.out.println("------------------------------------------");
		Sample s5 = new Sample(10, 20); //Sample, int, double
	}
}

class Sample {
	public Sample()
	{
		System.out.println("I am a default ctor of Sample");
	}
	
	public Sample(int a)
	{
		System.out.println("I am a ctor of Sample with parameter type int");
	}
	
	public Sample(int a, double b)
	{
		System.out.println("I am a ctor of Sample with parameters type int and double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte programcı Sample sınıfına int parametreli bir ctor eklediği için derleyici artık default ctor'u
	yazmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error
	}
}

class Sample {
	public Sample(int a)
	{
		System.out.println("I am a ctor of Sample with parameter type int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun gövdesinin boş olması genel olarak anlamsızdır. Yani çağrılsa da çağrılmasa da aynı 
	etkidedir. Şüphesiz programcı metodu bildirip daha sonra kodlarını yazmak üzere gövdesini boş bırakabilir. Bu başka
	bir durumdur. Ancak ctor'un gövdesinin boş olması anlamlıdır. Çünkü bu durumda nesne, non-static veri elemanlarınde
	default değerleri olacak şekilde yaratılmış olur. Eğer ilgili ctor yazılmazsa nesne o şekilde yaratılamaz. Yani 
	ctor'un gövdesinin boş olması ile bir metodun gövdesinin boş olması aynı şey değildir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(10, true);
		Sample s2 = new Sample(-10, true);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample(int a, boolean b)
	{
		if (a < 0)
			return;
		
		x = a;
		y = b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ctor içerisinde, adından ve yapısından da anlaşılabileceği gibi bir nesnenin yaratılma adımlarında ilk işlemler 
	yapılır. Tipik olarak non-static veri elemanlarına değerler verilebilir. Ayrıca, örneğin bir nesnenin yaratılması
	işleminde bir bağlantının sağlanması (connect) gerekiyorsa bu işlem tipik olarak ctor içerisinde yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(10, true);
		Sample s2 = new Sample();
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample()
	{
		
	}
	
	public Sample(int a, boolean b)
	{
		x = a;
		y = b;
	}
	
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point(100, 200);
		Point p2 = new Point();
		Point p3 = new Point(2.345);
		
		p1.print();
		p2.print();
		p3.print();
	}
}

class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Rassal (Random) Sayı Üretimi: Bilgisayarlar ile gerçek hayattaki rassallık sağlanamaz. Çünkü gerçek hayatta rassallığı
	etkileyen pek çok durum vardır ve bunların bazıları henüz öngörülememektedir. Dolayısıyla bilgisayar programlarıyla
	belirlenemez. Bilgisayarlarda kullanılan rassallığa "pseudo random" denilmektedir. Java'da özellike Java 17'den 
	itibaren rassal sayı üretimine ilişkin pek çok algoritma kullanılabilmektedir. java.util.Random isimli bir sınıf 
	genek olarak eskiden beri kullanılmaktadır. Bu sınıfın rassal sayı üretimi orta kalitededir. Random sayı üretimine
	ilişkin diğer algoritmalar burada kullanılmayacaktır. Java 17'den itibaren Random sınıfına ilişkin rassal sayı 
	üretimine "legacy random" denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının default ctor'u ile her nesne yaratıldığında auynı koddan farklı dizilim elde edilir. Bunun detayı 
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Ranom sınıfının parametresiz nextInt metodu her çağrıda int türü sınırları içerisinde üretilmiş rassal sayıya
	geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.println(r.nextInt());
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının parametresiz nextInt metodu her çağrıda int türü sınırları içerisinde üretilmiş rassal sayıya
	geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.println(r.nextInt());	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının int türden bound parametreli overload'u [0, bound) aralığında üretilmiş rassal sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(100)); //[0, 100)
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextInt metodunun int türden origin ve bound parametreli bir overload'u vardır
	
	Anahtar Notlar: İki parametreli nextInt metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(1, 100)); //[1, 100)
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextDouble metodu [0, 1) aralığında double türden rassal olarak üretilmiş sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble()); //[1, 100)

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextDouble metodunun double türden origin ve bound parametreli bir overload'u 
	vardır
	
	Anahtar Notlar: İki parametreli nextDouble metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(2.345, 2.346));

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextDouble metodunun double türden bound parametreli bir overload'u 
	vardır
	
	Anahtar Notlar: İki parametreli nextDouble metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(0.0001)); //[0, 0.0001)

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Benzer şekilde nextLong metotları da long türden sayı üretmek için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong());
		
		System.out.println("-----------------------------------------------------------");
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(-40_000_000_000L, 40_000_000_001L));
		
		System.out.println("-----------------------------------------------------------");
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(40_000_000_001L));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextBoolean metodu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i) 
			System.out.printf("%b%n", r.nextBoolean());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında int türden rassal sayı üretimi aşağıdaki gibi yapılabilir. Şüphesiz
	pek çok yöntem olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		while (true) {
			System.out.print("Kaç tane sayı üretmek istersiniz?");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());
			
			System.out.print("Sınır değerini giriniz:");
			int bound = Integer.parseInt(kb.nextLine());
			
			for (int i = 0; i < count; ++i)
				System.out.printf("%d ", r.nextInt(bound - min) + min); //r.nextInt(min, bound); -> Since Java 17
			
			System.out.println();
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında double türden rassal sayı üretimi aşağıdaki gibi yapılabilir. Şüphesiz
	pek çok yöntem olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		while (true) {
			System.out.print("Kaç tane sayı üretmek istersiniz?");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			System.out.print("Minimum değeri giriniz:");
			double min = Double.parseDouble(kb.nextLine());
			
			System.out.print("Sınır değerini giriniz:");
			double bound = Double.parseDouble(kb.nextLine());
			
			for (int i = 0; i < count; ++i)
				System.out.printf("%f%n", r.nextDouble() * (bound - min) + min); //r.nextDouble(min, bound); -> Since Java 17
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın atılması deneyinde yazı gelme olasılığını yaklaşık olarak hesaplayan basit bir 
	simülasyon programı yazınız
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinTailProbabilitySimulationApp.run();
	}
}


class CoinTailProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			CoinTailProbabilitySimulation simulation = new CoinTailProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class CoinTailProbabilitySimulation {
	public double p;
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			count += r.nextInt(2);
		
		p = (double)count / n;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın atılması deneyinde yazı gelme olasılığını yaklaşık olarak hesaplayan basit bir 
	simülasyon programı yazınız
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinTailProbabilitySimulationApp.run();
	}
}


class CoinTailProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			CoinTailProbabilitySimulation simulation = new CoinTailProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class CoinTailProbabilitySimulation {
	public double p;
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			if (r.nextBoolean())
				++count;
		
		p = (double)count / n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	18.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: İki zar atıldığında zarların çift (ikisinin de aynı) gelme olasılığını yaklaşık olarak hesaplayan
	basit bir simülasyon programını yazınız
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceProbabilitySimulationApp.run();
	}
}


class DiceProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			DiceProbabilitySimulation simulation = new DiceProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class DiceProbabilitySimulation {
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(1, 7) == r.nextInt(1, 7);
	}
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			if (areSame(r))
				++count;
		
		p = (double)count / n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Algoritması ne olursa olsun "pseudo random" sayı üretimi genel olarak bir tohum (seed) değerinden başlar. Bu anlamda
	aslında her sayı üretiminde tohum değeri ilgili yömteme göre güncellenir. Bu durumda tohum değeri bir nesne için
	hep aynı verildiğinde aynı çağrılarda aynı dizilim elde edilir.  Bu durumda tohum değeri her yaratılan Random
	nesnesi için mümkün olduğunca farklı verilirse bu durumda örneğin program her çalıştırıldığında farklı dizilim
	elde edilir. İşte Random sınıfının default ctor'u ile nesne yartıldığında ilgili tohum değeri önceki nesnelerden 
	mümkün olduğunca farklı verilir. Random sınıfının long türden seed parametreli ctor'u ile nesne tohum değeri
	verilerek de yaratılabilmektedir. Ayrıca setSeed metodu ile de yaratılmış olan bir Random nesnesi için o anki
	tohum değeri değiştirilebilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek her çalıştırıldığında farklı bir dizilim elde edilecektir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 11; ++i)
			System.out.printf("%d ", r.nextInt(1, 11));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek her çalıştırıldığında aynı dizilim elde edilecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(1000);
		
		for (int i = 0; i < 11; ++i)
			System.out.printf("%d ", r.nextInt(1, 11));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olacaktır. Üretilen ikinci 10 sayının
	dizilimi her çalıştırmada girilen tohum değerine bağlı olacağından aynı tohum değerleri için aynı olacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Her ne kadar nasıl yaptığını söylemese de tohum değerinin farklı verilebilmesi için zamana bağlı değerler kullanılır.
	System sınıfının currentMillis metodu 01.01.1970 gece yarısından (00:00:00.000) çağrılan zamana kadar geçen milisaniye
	sayısına geri döner. Bu durumda programcı tohum değeri olarak bu değeri verirse yine her defasında farklı tohum
	değeri elde edilmiş olur. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(System.currentTimeMillis());
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Benzer şekilde JVM'in yüksek çözünürlüklü zaman kaynağına (high resolution time source) ilişkin milisaniye değerine
	geri döner. Genel olarak bu değer surrentMillis metodundan elde edilen değerden daha hassastır. Bu detayların
	önemi yoktur. Ancak bu metot da her defasında farklı tohum değeri belirlemede kullanılabilir. Hatta Random sınıfının
	pek çok implementasyonunda default ctor'da bu metot çağrılarak tohım değeri belirlenir. Şüphesiz böyle olmak zorunda
	değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(System.nanoTime());
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	System.currentMillis ve System.nanoTime metotlarının detaylarının şu an için önemi yoktur. Aslında bu metotların 
	programcı tarafından kullanım amacı çoğu zaman tohumm değeri belirlemek değildir. Zaten default ctor tohum değerini 
	her çağrıldığında farklı olacak şekilde belirlediğinden yukarıdaki örnekte bu metotların çağrılması gerekmez. Ancak 
	şöyle spesifik bir örnekte gerekebilir: Tohum değeri bir nesne için o an akış her oraya geldiğinde farklı dizilim 
	elde edilmek istenirse kullanılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		java.util.Random r = new java.util.Random(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(System.nanoTime());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tohum değerini giriniz:");
			long seed = kb.nextLong();
			
			java.util.Random r = new java.util.Random(seed);
			
	 		
			for (int i = 0; i < 10; ++i)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			r.setSeed(System.nanoTime());
			
			for (int i = 0; i < 10; ++i)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
		
			if (seed == 0)
				break;
		}	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		java.util.Random r = new java.util.Random(seed);
			
		for (int i = 0; i < 10; ++i) {
			System.out.println("---------------------------------");
			for (int k = 0; k < 10; ++k)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			r.setSeed(System.nanoTime());
			
			for (int k = 0; k < 10; ++k)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			System.out.println("---------------------------------");
	
		}	
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		GenerateRandomPointsApp.run();	
	}
}

class GenerateRandomPointsApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Input width, height, code and count:");
		int width = kb.nextInt();
		int height = kb.nextInt();
		long code = kb.nextLong();
		int count = kb.nextInt();
		java.util.Random r = new java.util.Random(code);
		
		for (int i = 0; i < count; ++i) {
			Point pixel = PointUtil.createRandomnPoint(r, 0, width, 0, height);
			
			//...
			
			pixel.print();
		}
	}
}


class PointUtil {
	public static Point createRandomnPoint(java.util.Random r, int minX, int boundX, int minY, int boundY)
	{
		return new Point(r.nextInt(minX, boundX), r.nextInt(minY, boundY));
	}
}

class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex();
		Complex z3 = new Complex(5.6);
		
		z1.print();
		z2.print();
		z3.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfını ve örnek kodlarını inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.add(z2); //Mantıksal: z1 + z2
		z.print();
		
		z = z1.add(3.6); // Mantıksal: z1 + 3.6
		z.print();
		
		z = Complex.add(3.6, z1); //Mantıksal: 3.6 + z1
		z.print();
		
		z = z1.subtract(z2); //Mantıksal: z1 - z2
		z.print();
		
		z = z1.subtract(3.6); // Mantıksal: z1 - 3.6
		z.print();
		
		z = Complex.subtract(3.6, z1); //Mantıksal: 3.6 - z1
		z.print();
	}
}


package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.add(z2); //Mantıksal: z1 + z2
		z.print();
		
		z = z1.add(3.6); // Mantıksal: z1 + 3.6
		z.print();
		
		z = Complex.add(3.6, z1); //Mantıksal: 3.6 + z1
		z.print();
		
		z = z1.subtract(z2); //Mantıksal: z1 - z2
		z.print();
		
		z = z1.subtract(3.6); // Mantıksal: z1 - 3.6
		z.print();
		
		z = Complex.subtract(3.6, z1); //Mantıksal: 3.6 - z1
		z.print();
	}
}

package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.multiply(z2); //Mantıksal: z1 * z2
		z.print();
		
		z = z1.multiply(3.6); // Mantıksal: z1 * 3.6
		z.print();
		
		z = Complex.multiply(3.6, z1); //Mantıksal: 3.6 * z1
		z.print();
	}
}

package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z = new Complex(3.4, 7.8);
		
		z.print();
		z.inc();
		z.print();
		z.dec();
		z.print();
	}
}

class Complex {
	public double real, imag;
	
	public static Complex add(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return new Complex(re1 + re2, im1 + im2);
	}
	
	public static Complex subtract(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return add(re1, im1, -re2, -im2);
	}
	
	public static Complex multiply(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}
	
	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}
	
	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}
	
	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex conjugate()
	{
		return new Complex(real, -imag);
	}
	
	public Complex negate()
	{
		return new Complex(-real, -imag);
	}
	
	public void inc()
	{
		++real;
	}
	
	public void dec()
	{
		--real;
	}
	
	public void print()
	{
		System.out.printf("%f + %f * i%n", real, imag);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	19.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Paketler (Packages) ve İsim Arama (Name Lookup):
	Anımsanacağı gibi bir Java programı genel olarak paketlerden oluşur demiştik.  
	Aşağıdaki maddelerde "user defined type (UDT)" olarak belirtilen kavram için şu ana kadar ki bilgilerimizle sınıf 
	düşünülebilir. Ancak ileride başka UDT'ler de göreceğiz.
	
	Java kodlarını içeren ve genellikle ".java" uzantılı dosyalara yani derlenen dosyalara "derleme birimi (compilation/translation unit)"
	denir. Java'da eğer birden fazla UDT varsa, her bir UDT ayrı bir derleme birimi olarak düşünülebilir.
	
	Paketlere ilişkin detaylar:
	- javac her bir UDT için ayrı bir ".class" uzantılı dosya üretir. Bu dosyalara "byte code" dendiğini anımsayınız. UDT'ler
	aynı derleme biriminde bile olsalar her biri için ayrı byte code üretilir.
	
	- Bir UDT herhangi bir pakette olabilir. Bir proje içerisindeki UDT'lerin aynı paket altında olması zorunluluğu yoktur.
	
	- Bir ".class" uzantılı dosyanın, byte code'a ilişkin UDT'nin ait olduğu paketle aynı isimde bir dizinde (directory) olması
	gerekir. Bunu IDE programlar otomatik olarak uygun dizinlerde üretirler. Derleme birimleri için böyle bir zorunluluk
	yoktur. Yani bir .java uzantılı dosya herhangi bir yerde derlenebilir. Ancak Java'da kullanılan IDE'lerin neredeyse hepsi
	derleme birimleri için de pakete ilişkin directory'yi zorunlu tutar.
	
	- Bir UDT'nin ismine bulunduğu paket dışından paket ismi ve nokta operatörü ile erişilebilir. Bir UDT'ye bulunduğu
	paket dışında erişilebilmesi için o UDT'nin public olarak bildirilmesi gerekir. public olarak bildirilmeyen yani yalnızca
	kendi paketi içerisindeki diğer UDT'ler erişilebilen UDT'lere "friendly" terimi kullanılır. Bazı kaynaklar friendly
	terimi yerine "internal" terimini de kullanırlar.
	
	- Farklı paketlerde bulunan UDT'lerin byte code'larının bulunduğu pakete ilişkin dizinlerin yani aslında paketi belirten 
	dizinin uygulamanın çalışmaya başladığı yerde olması gerekir. Bu durumda tüm paketler burada konuşlandırılmalıdır.
	
	- Uygulamada kullanılan sınıflar içerisinde bir tane main metodu olmak zorunda değildir. java programına verilen sınıfın
	uygun main metodu çalıştırılır. main metodunun yapısı aşağıdaki gibi olmalıdır:
	
		public static void main(String [] args)
	
	Bu yapıda değişebilecek tek şey args ismidir. java programına verilen sınıfın main metoduna yani akışın başladığı metoda
	"entry point" denir. Entry point olarak kullanılan main'in ait olduğu UDT'nin kesinlikle bir sınıf olması gerekir.
	
	- public olarak bildirilen bir UDT, ismi ile aynı isimde bir .java dosyasında bildirilmesi gerekir. Aksi durumda error 
	oluşur. Bu durumda bir java dosyası içerisinde, dosya ile aynı isimde olan bir sınıf public olabilir.
	
	- Bir java dosyasında public bir sınıf olmak zorunda değildir. Bu durumda bildirilen sınıfların friendly olması gerekir.
	
	- Bir java dosyasında dosya ismi ile aynı isimde bir sınıfa da olmak zorunda değildir. Ancak bu durum pratikte pek
	tercih edilmez.
	
	- Bir java dosyasında public olmayan istenildiği kadar sınıf bildirilebilir. Bu UDT'lerin hepsi aynı pakette bildirilmiş olur.xx
	
	- Bir java dosyasında yalnızca bir paket bildirimi yapılabilir. Paket bildirimi tüm diğer kodlardan önce yazılmalıdır.
	
	- Birden fazla java dosyasında aynı paket bildirimi yapılabilir. Bu durumda bu dosyalardaki tüm UDT'ler aynı pakette
	bildirilmiş olur. 
	
	- Aynı paket içerisinde aynı isimde birden fazka UDT bildirimi geçersizdir.
	
	- Farklı paketler içerisinde aynı isimde UDT'lerin bildirimi yapılabilir.  
	
	- Bir paketin alt paketleri olabilir. Alt paket bildiriminin genel biçimi şu şekildedir:
		package <paket ismi>[.<alt paket ismi>.<alt paket ismi> ...]
	Alt paket içerisindeki UDT'lerin byte code'ları paket hiyerarşisi içerisinde uygun alt dizinde bulunmak zorundadır.
	Yine IDE programlar bunu otomatik olarak yaparlar.
	
	- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin csd.util paketi içerisinde Point isimli bir sınıf varsa
	csd içerisinde de Point isimli bir sınıf olabilir. Çünkü paketler farklıdır, isim çakışması oluşmaz
	
	- Paketler isim çakışmasını engellemek için düşünülmüştür. Paketler ile farklı firmalar kendi paket isimleriyle UDT'leri 
	yazdıklarında UDT'lerin isimleri aynı olsa bile diğerleriyle birlikte aynı uygulamada kullanılabilirler.
	
	- Paket isimleri genelde firmaya özgü tekil (unique) olan domain isminden üretilir. Örneğin CSD'nin paketleri, 
	domain'i "csystem.org" olduğundan "org.csystem" paketi altında yazılabilir. Bu bir convention'dır ve firmalar özellikle
	genel UDT'ler için buna mutlaka uyarlar. Pratikte domain ismi altında doğrudan UDT bildirilmez, en az bir tane paket 
	altında bildirilir. Yani bu convention'da domain ismi paket hiyerarşisinin taban paketini temsil eder. Programcı
	sınıfları koyacağı paketleri okunabilir ve isim çakışması olasılığının çok çok aza indirecek şekilde bildirmelidir. Bu 
	anlamda alt paketlerin fazla olması sorun oluşturmaz. Paket isimlendirmede programcının anlamlı olacak şekilde cömert
	olması gerekir. Paketler, yine bir convention olarak tamamı küük harf olacak şekilde isimlendirilir. Birden fazla 
	kelimeden oluşan paket isimleri bitişik yazılır.
	
	- Java'nın standart tüm paketleri ve UDT'leri java isimli bir paketin altında bildirilmiştir. Bu anlamda programcının
	java paketi altında bir bildirim yapması tavsiye edilmez. Zaten yukarıdaki convention'a uyan programcı böyle bir bildirim
	yapmaz. 
	
	- java.lang paketi altındaki tüm UDT'ler her yerden görülebilirdir. Yani bu paket altındaki tüm UDT isimlerine doğrudan
	erişilebilir. Ayrıca belirtilmesi gerekmez. İleride göreceğimiz "import bildirimi" yapılmasına da gerek olmaz. Örneğin
	String sınıfı, System sınıfı, Integer sınıfı, Character sınıfı gibi sınıflar java.lang paketi altında bildirilmiştir.   
	
	- Hiç bir paket altında bildirilmeyen UDT'ler "isimsiz paket (unnamed package)" içerisinde bildirilmiş olur. Pratikte
	bir uygulama içerisinde isimsiz paket altında UDT bildirimi yapılmaz. Bunun nedeni ileride anlaşılacaktır  
-----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: Complex.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 19th November 2023
	
	Complex class that represents a complex number
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math;

public class Complex {
	public double real, imag;
	
	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}
	
	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}
	
	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}
	
	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}
	
	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}
	
	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex conjugate()
	{
		return new Complex(real, -imag);
	}
	
	public Complex negate()
	{
		return new Complex(-real, -imag);
	}
	
	public void inc()
	{
		++real;
	}
	
	public void dec()
	{
		--real;
	}
	
	public void print()
	{
		System.out.printf("%f + %f * i%n", real, imag);
	}
}


/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 19th November 2023
	
	Point class that represents a 2 dimensional point
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: NumberUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 19th November 2023
	
	Utility class for numeric operations
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.numeric;

public class NumberUtil {
	public static int digitsCount(int val)
	{
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}

	
	public static int digitsSum(int val)
	{
		int total = 0;
		
		while (val != 0) {
			total += val % 10;
			val /= 10;
		}
		
		return Math.abs(total);
	}
	

	public static int factorial(int n)
	{
		int result = 1;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}

	
	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;
		
		if (b <= a && a <= c || c <= a && a <= b)
			return a;
		
		return c;
	}
	
	public static long nextClosestPrime(long val)
	{		
		while (!isPrime(++val))
			;
		
		return val;		
	}
	

	public static int nextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0;
		
		while (true) {
			int next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}

	public static int nthFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = prev1 + prev2;
		
		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}
		
		return val;
	}
	
	
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		while (true) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}


	public static long previousClosestPrime(long val)
	{		
		while (!isPrime(--val))
			;
		
		return val;
	}

	
	public static int reversed(int val)
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir isim iki biçimde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	
	Bir isim nokta operatörünün sağında kalıyorsa nitelikli kullanılmış olur. Kalmıyorsa niteliksiz kullanılmış olur.
	
	Anahtar Notlar: Burada nitelikli (qualified) ve niteliksiz (unqualified) terimleri olumlu ya da olumsuz anlamda 
	değildir. Burada kullanım biçimini belirtir.
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{	
		Sample s; //Sample niteliksiz kullanılmıştır
		
		s = new Sample(); //s ve Sample niteliksiz kullanılmıştır
		s.foo(10); //s niteliksiz, foo nitelikli kullanılmıştır
		
		System.out.printf("s.x = %d%n", s.x); //System niteliksiz, out nitelikli, printf nitelikli, s niteliksiz ve x niteklikli kullanılmıştır		
	}
}

class Sample {
	public int x;
	
	public void foo(int a)
	{
		x = a; //x ve a niteliksiz kullanılmıştır
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Derleyici kullanılan bir ismi önce arar, bulursa doğru kullanılıp kullanılmadığına bakar. Eğer bulamazsa veya bulur
	ancak yanlış kullanıldığını anlarsa error oluşur. Derleyici bildirilen isimleri doğal olarak aramaz. Derleyici
	ismin kullanımına göre ismi nitelikli veya niteliksiz olarak arar. İşte nitelikli ve niteliksiz isim arama (name lookup)
	kuralları burada ele alınacaktır
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { //App aranmaz
	public static void main(String [] args) //main aranmaz, String niteliksiz aaranır, args aranmaz
	{	
		Sample s; //Sample niteliksiz aranız, s aranmaz
		
		s = new Sample(); //s ve Sample niteliksiz aranır
		s.foo(10); //s niteliksiz, foo nitelikli aranız
		
		System.out.printf("s.x = %d%n", s.x); //System niteliksiz, out nitelikli, printf nitelikli, s niteliksiz ve x niteklikli aranır		
	}
}

class Sample { //Sample aranmaz
	public int x; //x aranmaz
	
	public void foo(int a) //foo ve a aranmaz
	{
		x = a; //x ve a niteliksiz aranır
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bu bölümde nitelikli ve niteliksiz isim arama kuralları anlatılacaktır. Bu kuralların her birisinin
	genel ve özel durumları vardır. Özel durumlar ayrıca ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	25.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici kullanılan bir ismi önce arar, bulursa ismin doğru olarak kullanılıp kullanılmadığına bakar. Eğer doğru
	kullanılmıyorsa error oluşur. Bu durumda ismin bulunanamasından dolayı oluşan error ile ismin doğru kullanılmamasından
	dolayı oluşan error aynı değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public static void foo(double a)
	{
		int x;
		
		x = a; //error: İsim bulunda ancak geçersiz olarak kullanıldı
		x = y; //error: isim bulunamadı
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	1. İsim bir metot içerisinde kullanılmışsa kullanıldığı yerden yukarıya doğru aranır. Bu aramaya yerel değişkenler 
	ve metot parametre değişkenleri de dahildir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public void foo(int a)
	{
		int x;
		
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	2. İsim kullanıldığı metodun ait olduğu sınıf içerisinde tüm metotların dışında her yerde aranır. Eğer sınıf
	içerisinde bulunamazsa doğrudan ve dolaylı taban sınıflara (direct and indirect super classes) da sırasıyla bakılır
	ve ilk bulduğu seçilir. Taban sınıf kavramı ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);				
				
	}
}


class Sample {
	public int x;
	public void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre bir sınıfın bir metodunun parametre değişken ismi veya bir yerel değişken ismi ait olduğu
	sınıfın bir veri elemanı ile aynı olabilir. Bu durumda yerel değişken (veya parametre değişkeni) ismi veri elemanı
	ismini maskeler (shadowing/masking).  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);	
		s.bar(30);
		System.out.printf("s.x = %d%n", s.x);
		s.tar(45);
		System.out.printf("s.x = %d%n", s.x);
	}
}


class Sample {
	public int x;
	
	public void foo(int a)
	{	
		int x;
		
		x = a;
	}
	
	public void bar(int x)
	{
		x = x; //self assignment
	}
	
	public void tar(int a)
	{
		x = a;
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Mample {
	//...
}

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Mample {
	//...
}

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır. Eğer bulunamazsa üst paketlere bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}

package org.csystem;

public class Mample {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır. Eğer bulunamazsa alt paketlere bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}


package org.csystem.app.mest;

public class Mample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kural gereği isimsiz bir paket altında bulunan sınıfa başka bir paketten erişmenin bir yolu yoktur. İşte
	bu sebeple bir proje içerisinde isimsiz paket altında UDT bildirimi yapılmaz. Ancak küçük bazı denemeler için
	kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}


public class Mample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	4. İsim "import on demand" olarak bildirilmiş "import bildirimlerine" ilişkin paketler içerisinde aranır. Bu durum 
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kurallarına göre aranan bir isim yukarıdaki maddelerin hiç birisinde bulunamazsa error 
	oluşur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	1. İsmin solunda bir sınıf ismi varsa isim o sınıf içerisinde aranır. Bulunamazsa yine doğrudan ya da dolaylı
	sınıflara da sırasıyla bakılır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo(20);
		
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}


class Sample {
	public static int x;
	public static void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	2. İsmin solunda bir referans ismi varsa isim referansın türüne ilişkin sınıf içerisinde aranır. Bulunamazsa yine
	doğrudan ya da dolaylı taban sınıflara da sırasıyla bakılır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
	}
}


class Sample {
	public int x;
	public void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsmin solunda bir paket ismi varsa bu durumda ilgili paket içerisinde aranır. Bulunamazsa alt ya da üst paketlere
	bakılmaz 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		csd.Sample s;
		
		
	}
}


package csd;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz isim aramaya dahil edilmez. Başka bir deyişle, bir paket ismi niteliksiz isim aramada
	görmezden gelinir. Bir paket isminin niteliksiz olarak kullanılabilmesi için onun paket hiyerarşisinde en üstte 
	olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		company.hr.Staff s; //error
	}
}



package org.csystem.app.company.hr;

public class Staff {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	import bildirimleri (import declarations): import bildirimleri niteliklendirmeyi azaltmak ve dolaysıyla kodu daha
	yalın yazmak amacıyla kullanılır. import bildirimlerinin UDT ismi bakımından iki kullanım biçimi vardır:
	1. Yıldızlı import bildirimi (import on demand declaration):
	2. Yıldızsız import bildirimi (import single type declaration):
	
	import bildirimleri paket bildiriminden sonra ve tüm diğer bildirimlerden önce olmalıdır. Birden fazla import bildirimi
	geçerlidir ve bildirim sırasının önemi yoktur. import bildirimleri niteliksiz aramalar için geçerlidir. import
	bildirimleri yalnızca bildirildikleri derleme biriminde geçerlidir. Bu nedenle import bildirimleri geçişli de değildir.
	
	Anahtar Notlar: import bildirimleri bir kütüphaneyi projeye dahil etmek demek DEĞİLDİR. Bir kütüphaneyi projeye dahil
	etmek için başka yöntemler kullanılmaktadır. 
	
	Anahtar Notlar: Yukarıdaki yıldızlı ve yıldızsız terimleri tamamen Oğuz Karan tarafından uydurulmuştur. Bunlar
	gerçek terimlerin gerçek tercümeleri değildir. Kolay algılanması açısında bu şekilde Türkçeleştirilmiştir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildirimi (import on demand declaration): Yıldızlı import bildiriminin genel biçimi şu şekildedir:
		import <paket ismi>[.<alt paket ismi>].*;
	Niteliksiz arama genel kurallarına göre paket içerisinde bulunamayan bir isim yıldızlı import bildirimlerine ilişkin
	paketlerde aranır. Burada tüm yıldızlı import bildirimlerine bakılır ancak alt ve üst paketlere yine bakılmaz. Yani 
	bu bildirim isim arama genel kurallarına göre, paket içerisine isim aarama anlamında başka bir paketi adeta enjekte 
	etmektir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.math.geometry.*;
import org.csystem.math.*;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		
		System.out.print("Bir sayı giriniz:");
		
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i) {
			Complex z = new Complex(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			Point p = new Point(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			
			System.out.println("------------------------");
			z.print();
			p.print();
			System.out.println("------------------------");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	26.11.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Arama tüm yıldızlı import bildirimleriyle belirtilen paketlerin hepsinde yapılır. Eğer isim birden fazla yerde 
	bulunursa error oluşur (ambiguity).  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


import csd.*;
import msd.*;

class App { 
	public static void main(String [] args) 
	{	
		Mample m;
		Sample s; //error:ambiguous
	}
}



package msd;

public class Sample {

}

package msd;

public class Mample {

}

package csd;

public class Sample {

}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızsız import bildirimi (import single type declaration): Yıldızsz import bildiriminin genel biçimi şu şekildedir:
		import <paket ismi>[.<alt paket ismi>].<UDT ismi>;
	Bu bildirimde belirtilen UDT ismi artık derleme birimi boyunca doğrudan kullanılabilir. Ya da başka bir deyişle 
	buradakiş bildirim, bu ismin doğrudan kullanıldığını gördüğünde artık bu pakettekini anla demektir. Yani bu isim
	için niteliksiz isim arama genel kuralları uygulanmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;
import org.csystem.math.geometry.Point;
import org.csystem.math.Complex;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		
		System.out.print("Bir sayı giriniz:");
		
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i) {
			Complex z = new Complex(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			Point p = new Point(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			
			System.out.println("------------------------");
			z.print();
			p.print();
			System.out.println("------------------------");
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızsız import bildiriminde farklı paketlerdeki aynı isimler birden fazla kez bildirilemez. Bu şekilde bir bildirimde
	isimin kullanılmasına da gerek yoktur. Bildirim doğrudan hatalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import csd.Sample;
import msd.Sample; //error
import msd.*;

class App { 
	public static void main(String [] args) 
	{
		Mample s;
	}
}


package msd;

public class Sample {

}

package msd;

public class Mample {

}

package csd;

public class Sample {

}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programcı mümkün olduğunca yıldızsız import bildirimini tercih etmelidir. Aslında doğru kullanıldıktan
	sonra bunun hiç bir önemi yoktur. IDE'ler de genel olarak yıldızsız import bildirimine yönlendirir. Örneğin Eclipse
	tüm yıldızlı import bildirimlerini yıldızsız olacak şekilde optimize eder. IntelliJ IDEA ise aynı paketten belirli
	sayıda yıldızsız import bildirimini yıldızlı yapacak şekilde optimize eder. Bu kullanım programcıdan programcıya
	değişebilse de genel olarak IDE'nin default yaklaşımı uygulanır. Şüphesiz yıldızsız import bildirimi ile isim 
	çakışması olasılığı çok daha azdır ve daha kolay düzenlenebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte niteliksiz isim arama genel kuralları uygulandığından org.csystem.app paketeindeki Sample sınıfının
	foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import csd.*;

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo();
	}
}

package csd;

public class Sample {
	public static void foo()
	{
		System.out.println("csd.foo");
	}
}

package org.csystem.app;

public class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte niteliksiz isim arama genel kuralları uygulanmadığından csd paketeindeki Sample sınıfının foo
	metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import csd.Sample;

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo();
	}
}

package csd;

public class Sample {
	public static void foo()
	{
		System.out.println("csd.foo");
	}
}

package org.csystem.app;

public class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte niteliksiz isim arama genel kuralları uygulandığından org.csystem.app paketeindeki Sample sınıfının
	foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import csd.*;

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.foo");
	}
}


package csd;

public class Sample {
	public static void foo()
	{
		System.out.println("csd.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Sample sınıfı aynı derleme biriminde bildirildiğinden Sample ismi için yıldızsız import bildirimi
	geçersizdir  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import csd.Sample; //error

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("org.csystem.app.foo");
	}
}

package csd;

public class Sample {
	public static void foo()
	{
		System.out.println("csd.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	import static bildirimleri (import static declarations): Bu bildirim Java 5 ile birlikte dile eklenmiştir. Bu bildirim
	static elemanların niteliklendirilmesinin azaltılması için kullanılmaktadır. Diğer import bildirimleri ile aynı yerde 
	bulunmalıdır. Yine sıralamanın bir önemi yoktur. import static bildiriminin de genel olarak iki kullanım biçimi vardır:
	1. Yıldızlı import static bildirimi (import static on demand declaration)
	2. Yıldızsız import static bildirimi (import static single member declaration) 
	
	Bu bildirimlerde niteliksiz kullanılan static elemanın algı açısından, kullanılan UDT'ye ait olduğu durumu oluşmamalıdır. Yani 
	okunabilirliği etkilemediği sürece kullanılması tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 Yıldızlı import static bildiriminin genel biçimi şu şekildedir:
	 	import static <paket ismi>[.<alt paket ismi>].<UDT ismi>.*
	 Bu bildirimle derleyici bir ismi import bildirimlerinde arama noktasına geldiğinde, ilgili UDT içerisindeki static
	 elemanlara da bakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.*;

import java.util.Scanner;


class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log(%f) = %f%n", a, log10(a));
	}
}

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 26th November 2023
	
	Point class that represents a 2 dimensional point
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.*;

public class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return sqrt(pow(x - a, 2) + pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Yıldızsız import static bildiriminin genel biçimi şu şekildedir:
	 	import static <paket ismi>[.<alt paket ismi>].<UDT ismi>.<static eleman ismi>
	 Bu bildirimle yine niteliksiz isim arama genel kuralları uygulanmaz ve bildirilen static eleman ismi o derleme 
	 biriminde niteliksiz olarak kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.sqrt;
import static java.lang.Math.log10;

import java.util.Scanner;


class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log(%f) = %f%n", a, log10(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte App sınıfının sqrt metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.sqrt;
import static java.lang.Math.log10;

import java.util.Scanner;


class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a));
		System.out.printf("log(%f) = %f%n", a, log10(a));
	}
	
	public static double sqrt(double a)
	{
		System.out.println("App.sqrt");
		
		return Math.sqrt(a);
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte uygun (applicable) bir sqrt metodu App sınıfı içerisinde bulunmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static java.lang.Math.sqrt;
import static java.lang.Math.log10;

import java.util.Scanner;


class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, sqrt(a)); //error
		System.out.printf("log(%f) = %f%n", a, log10(a));
	}
	
	public static double sqrt(int a)
	{
		System.out.println("App.sqrt");
		
		return Math.sqrt(a);
	}
	
	public static double sqrt(long a)
	{
		System.out.println("App.sqrt");
		
		return Math.sqrt(a);
	}
}

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 26th November 2023
	
	Point class that represents a 2 dimensional point
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.sqrt;
import static java.lang.Math.pow;

public class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return sqrt(pow(x - a, 2) + pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıda anlatılan isim arama ve paketlere ilişkin kuralların dışında da bazı ayrıntılar bulunmaktadır.
	Bu ayrıntılar pratikte kullanılmadığından burada ele alınmamıştır. Bu ayrıntılar genel olarak dilin matematiğinden 
	doğan ayrıntılardır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfı ve yazılarla işlemler:
	Neredeyse her uygulamada yazılarla işlemler yapılmaktadır. Programlamada yazı dendiğinde akla string terimi gelir. 
	Java'da yazılarla işlemlerde kullanılan en temel sınıf java.lang paketi içerisindeki String sınıfıdır. String sınıfının
	yararlı pek çok metodu bulunmaktadır. Programcı açısından bu sınıf yazılarla bir işlem gerektiğinde ilk tercih edilecek
	sınıf olmalıdır. Yani programcı yazılarla yapılan bir işlem için bu sınıfta ilgili metodun olup olmadığına bakmalı
	yoksa diğer sınıflara bakmalı veya kendi yazmalıdır. String sınıfına zaman içerisinde pek çok metot da eklenmiştir.
	Özellikle Java 11 ile eklenen bir grup metot ile String sınıfı daha da yetenekli hale gelmiştir. String sınıfı
	immutable bir sınıftır. Bir sınıf türünden nesnenin içeriği yani veri elemanları sınıf dışında değiştirilemiyorsa 
	bu tarz sınıflara immutable sınıflar denir. Bu anlamda String sınıfı ile tutulan bir yazı değiştirilemez. Bu durumda
	yazı üzerinde değişiklik yapan metotlar var mıdır? Eğer varsa bunlar nasıl işlem yapmaktadır? Bu sınıfın yazı üzerinde
	değişiklik yapan metotları vardır. Bu metotlar nesnenin içeriğini değiştiremeyeceğine göre değiştirilmiş yazıyı 
	tutan yeni String referansına geri dönerler. String sınıfı yazının içsel olarak nasıl tutulduğu ayrıca ele alınacaktır. 
	Ancak şu kesindir ki, String nesnesi içerisinde yazının kendisi tutulamaz. Çünkü Java'da aynı türden nesnelerin
	uzunlukları (bellekte kapladığı alan) aynıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir string literal gördüğünde ve özdeş string sabitini daha önce görmemişse şu şekilde bir kod üretir: 
	"Çalışma zamanında String türden ilgili karakterleri tutacak bir nesne yarat ve o nesnenin referansını ver". Bu 
	durumda bir string literal bir String referansı olarak kullanılabilir. print ve println metotlarının String 
	parametreli overload'ları vardır ve bunlar aldıkları String referansına ilişkin yazıyı ekrana basarlar. printf 
	metodu ile s format karakter kullanıldığında bir String formatlanabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		String s = "ankara";
		
		System.out.println(s);
		System.out.printf("Yazı:%s%n", s);
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Scanner sınıfının nextLine metodu, klavyeden enter basılıncaya kadar (enter hariç) girilen yazının karakterlerinden 
	oluşan bir yazıya ilişkin String referansına geri döner
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
	
		System.out.printf("Girilen Yazı:(%s)%n", s);
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının toUpperCase metodu bir yazının tamamını büyük harfe çevirir. Benzer şekilde toLowerCase metodu
	yazının tamamnın küçük harfe çevirir. Şüphesiz bu metotlar yazıyı değiştiremez. Değiştirilmiş yazıya ilişkin yeni bir
	String referansına geri döner
	
	Anahtar Notlar: toLowerCase ve toUpperCase metotları büyük harf küçük harf çevrimini dil desteğine göre yaparlar. Buna
	"localization" ya da "locale" denir. Bu metotlarının parametresiz overload'ları uygulamanın çalıştığı sistemin
	localization'ına bakarak işlem yaparlar. Localization kavramı "Java ile Uygulama 1" kursunda ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
	
		String upper = s.toUpperCase();
		String lower = s.toLowerCase();
		
		System.out.printf("s = %s%n", s);
		System.out.printf("upper = %s%n", upper);
		System.out.printf("lower = %s%n", lower);
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazı durumlarda aynı referans ile yeni nesne gösterilerek devam edilebilir. Bu durumda mantıksal olarak yazı değiştirilmiş
	gibi işlem yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
	
		s = s.toUpperCase();
		
		System.out.printf("s = %s%n", s);
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının length isimli metodu ile yazının kaç tane karakterden oluştuğu bilgisi elde edilebilir. charAt
	metodu parametresi ile aldığı indeks numarasındaki karaktere geri döner. İndeks numarası sıfırdan başlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
	
		int len = s.length();
		
		for (int i = 0; i < len; ++i)
			System.out.printf("%c ", s.charAt(i));
		
		System.out.println();
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	charAt metoduna pozitif ya da negatif bakımdan sınırlar dışında değer verildiğinde exception oluşur. Verilecek 
	indeks değerleri [0, length()) aralığında olmalıdır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		System.out.printf("ch = %c%n", s.charAt(5));
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	02.12.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Uzunluğu sıfır olan yani içerisinde hiç bir karalkterin bulunmadığı string'lere boş string (empty string) denir ve 
	en kolay iki tane çift tırnağın yanyana yazılması biçiminde elde elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		String s = "";
		
		System.out.printf("Length:%d%n", s.length());
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı türden iki referansın == veya != operatörü ile karşılaştırılması, iki referansın da aynı nesneyi gösterip
	göstermediğinin karaşılaştırılması yani adres karşılaştırması demektir 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Sample s1 = new Sample(10);
		Sample s2 = new Sample(10);
		
		
		System.out.printf("s1.x = %d%n", s1.x);
		System.out.printf("s2.x = %d%n", s2.x);
		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(s1 != s2 ? "Farklı nesneler" : "Aynı nesne");
	}	
}

class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı türden referanslar zaten == veya != operatörleri ile işleme sokulamazlar 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample(10);
		Mample m = new Mample(10);
		
	
		System.out.println(s == m ? "Aynı nesne" : "Farklı nesneler"); //error
		System.out.println(s != m ? "Farklı nesneler" : "Aynı nesne"); //error
	}	
}

class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;
	}
}

class Mample {
	public int x;
	
	public Mample(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Referanslar aynı türden olsa bile >, <=, <, >= operatörleri ile işleme sokulamazlar 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Sample s1 = new Sample(10);
		Sample s2 = new Sample(10);
	

		System.out.println(s1 < s2 ? "s1 < s2" : "s1 >= s2"); //error
	}	
}

class Sample {
	public int x;
	
	public Sample(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki yazının aynı (özdeş) olup olmadığı == veya != operatörü ile karşılaştırılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		System.out.println(s1 == s2 ? "Aynı yazı" : "Farklı yazılar");
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	İki yazının aynı olup olmadığının karşılaştırılması için equals metodu kullanılabilir. equals metodu case-sensitive'dir 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equals(s2) ? "Aynı yazı" : "Farklı yazılar");
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	case-insensitive bir özdeşlik karşılaştırması için equalsIgnoreCase metodu kullanılabilir. Bu metot şüphesiz default
	olarak işletim sisteminin dil ayarlarına göre büyük-küçük harf belirlemesi yapmaktadır. Dile göre büyük-küçük harf
	belirlemesi burada ele alınmayacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equalsIgnoreCase(s2) ? "Aynı yazı" : "Farklı yazılar");
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	 İki yazıyı birleştirmek (concatenation) için concat metodu kullanılabilir. Şüphesiz bu metot yeni bir String 
	 referansına geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		String s = s1.concat(s2);
		
		System.out.printf("Yazı: %s%n", s);
	}	
}

/*----------------------------------------------------------------------------------------------------------------------
	 + operatörünün operandları String türündense bu durumda iki yazı birleştirilir. Bu + operatörünün extra bir 
	 özelliğidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Birinci yazıyı giriniz:");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz:");
		String s2 = kb.nextLine();
		
		String s = s1 + " " + s2;
		
		System.out.printf("Yazı: %s%n", s);
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	+ operatörünün operandlarından biri String türündense, diğeri hangi türde olursa olsun değerin yazı (String)
	karşılığı elde edilir. Bir tür için yazı karşılığının teknik olarak nasıl elde edildiği ileride detaylı olarak
	ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Derece bilgisini giriniz:");
		double degree = kb.nextDouble();
		String message = "Bugün hava " + degree + " derece olacak";
		
		System.out.println(message);
		
	}	
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte println metoduna geçilen ifade önce hesaplanır sonra println çağrılır değil mi?
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Derece bilgisini giriniz:");
		double degree = kb.nextDouble();
		
		System.out.println("Bugün hava " + degree + " derece olacak");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici özdeş String literal'lar için tek bir nesne yaratılacak şekilde kod üretir. Bu durumda özdeş String ikinci 
	defa yazılırsa daha önce yaratılmış olan nesnenin referansı anlamına gelir. String sınıfı immutable bir sınıf 
	olduğundan aynı nesneyi birden fazla referansın göstermesi durumunda herhahngi bir referans üzerinden değişiklik
	yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		String s1 = "ankara";
		String s2 = "ankara";
		
		System.out.println(s1 == s2 ? "Aynı yazı" : "Farklı yazılar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının tersini döndüren reverse isimli metodu StringUtil sınıfı içerisinde
	yazınız ve aşağıdaki kod ile test ediniz
	
	Not: reverse metodunu bu gerçekleştirimi (implementation) çok kolay olmasına karşın çok büyük yazılar için efektif
	bir yöntem değildir. Çünkü bu yöntemde sürekli String nesneleri yartatılmış ve eski nesneden kopşartılmıştır. Bu da
	göre maliyetli olabilir. Daha efektif yöntemler ileride ele alınacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilReverseTest.run();
	}
}

class StringUtilReverseTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.printf("Yazının tersi:%s%n", StringUtil.reverse(s));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

package org.csystem.util.string;

public class StringUtil {
	public static String reverse(String s)
	{
		String str = "";
		
		for (int i = s.length() - 1; i >= 0; --i)
			str += s.charAt(i);
		
		return str;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfına yardımcı immutable olmayan StringBuilder isimli bir sınıf vardır. Bu sınıf ile tutulan yazı üzerinde
	değişiklik yapılabilmektedir. Bu sınıf String sınıfına alternatif olarak düşünülmemelidir. Bu sınıf String sınıfının
	immutable olmasının dezavantaj oluşturduğu durumlarda yardımcı olarak kullanılmaktadır. StringBuilder sınıfının 
	append metotları ile yazının sonuna ekleme yapılabilir. StringBuilder sınıfının  metotları aynı StringBuilder 
	referansına geri dönerler. StringBuilder sınıfının diğer metotları kurs içerisinde çeşitli örneklerle ele alınacaktır.
	StrşngBuilder sınıfının içsel detayları "Java ile Uygulama Geliştirme 1" kursunda ele alınacaktır. StrinBuilder sınıfının
	String parametreli ctor'u ile bir String'dan bir StringBuilder nesnesi elde edilebilir. Yine StringBuilder sınıfının
	reverse metodu ile StringBuilder ile tutulan yazı ters yüz edilebilir. StringBuilder sınıfının toString metodu ile
	StringBuilder ile tutulan yazıyı tutan bir String nesnesine ilişkin referans elde edilebilir. StringBuilder sınıfı da
	java.lang paketi içerisinde bildirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilReverseTest.run();
	}
}

class StringUtilReverseTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.printf("Yazının tersi:%s%n", StringUtil.reverse(s));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir yazının boş String olup olmadığı String sınıfının isEmpty isimli metodu ile test edilebilir  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(s.isEmpty() ? "Boş String" : "Boş string değil");
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıları aralarında - karakteri ile birleştirip yeni bir 
	String elde eden programı yazınız. Örneğin: ankara, istanbul, izmir girişleri için ankara-istanbul-izmir yazısı
	elde edilecektir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		ConcatWithHyphenApp.run();
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		StringBuilder sb = new StringBuilder();
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			if (!sb.isEmpty())
				sb.append("-");
			
			sb.append(s);
		}
		
		String str = sb.toString();
		
		System.out.println(str);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının substring metotları ile bir yazının içerisindeki bir kısmı elde edilebilmektedir. StringBuilder 
	sınıfının da substring metodu vardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		String s = "ankara";
		
		System.out.println(s.substring(2));
		System.out.println(s.substring(2, 5)); //[2, 5)
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden elma girilene kadar alınan yazıları aralarında - karakteri ile birleştirip yeni bir 
	String elde eden programı yazınız. Örneğin: ankara, istanbul, izmir girişleri için ankara-istanbul-izmir yazısı
	elde edilecektir  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		ConcatWithHyphenApp.run();
	}
}

class ConcatWithHyphenApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		StringBuilder sb = new StringBuilder();
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
					
			sb.append(s).append('-');
		}
		
		String str = sb.substring(0, sb.length() - 1);
		
		
		System.out.println(str);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının char parametreli indexOf metodu aldığı karakterin yazı içerisindeki ilk görüldüğü indeks numarasına
	geri döner. Karakter bulunamazsa -1 değerine geri döner. Benzer şekilde char ve int parametreli overload'ı aldığı 
	karakteri ikinci parametresi ile aldığı indeks numarasından itibaren yazı içerisinde ilk gördüğü indeks numarasına
	geri döner
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		String s = "Bugün hava çok güzel. Bu çok güzel havada gezilebilir mi?";
		char c = 'ç';
		int index = s.indexOf(c);
		
		System.out.printf("Index = %d%n", index);
		
		index = s.indexOf(c, 12);
		
		System.out.printf("Index = %d%n", index);
		
		index = s.indexOf(c, 26);
		
		System.out.printf("Index = %d%n", index);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının String parametreki indexOf metotları yazı içerisinde yazı aramak için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		String s = "Bugün hava çok güzel. Bu çok güzel havada gezilebilir mi?";
		String c = "çok";
		int index = s.indexOf(c);
		
		System.out.printf("Index = %d%n", index);
		
		index = s.indexOf(c, 12);
		
		System.out.printf("Index = %d%n", index);
		
		index = s.indexOf(c, 26);
		
		System.out.printf("Index = %d%n", index);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının lastIndexOf metotları yazı aramayı sondan itibaren yapar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		String s = "Bugün hava çok güzel. Bu çok güzel havada gezilebilir mi?";
		char c = 'ç';
		String str = "çok";
		int index = s.lastIndexOf(c);
		
		System.out.printf("Index = %d%n", index);
		
		index = s.lastIndexOf(str);
		
		System.out.printf("Index = %d%n", index);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir iki yazıdan birincisi içerisinde, ikincisinden kaç tane olduğuna geri
	dönen countString isimli metodu StringUtil sınıfı içerisinde yazınız ve test ediniz. Benzer şekilde case-insensitive
	olarak çalışan countStringIgnoreCase isimli metoda yazınız. 
	Örneğin: aaa yazısı içerisinde aa'dan 2 tane olmalı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilCountStringTest.run();
	}
}

class StringUtilCountStringTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			System.out.printf("Count:%d%n", StringUtil.countString(s1, s2));
			System.out.printf("Count:%d%n", StringUtil.countStringIgnoreCase(s1, s2));
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	03.12.2023  
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı Random referansı ile int türden count bilgisi için, her biri rasgele 
	üretilmiş count tane Türkçe karakterden oluşan yazıya geri dönen generateRandomTextTR ve  her biri rasgele  üretilmiş
	count tane İngilizce karakterden oluşan yazıya geri dönengenerateRandomTextEN metotlarını StringUtil sınıfı içerisinde
	yazınız ve aşağıdaki kod ile test ediniz 
	Açıklama: Metot count değeri pozitif olmama kontrolü yapmayacaktır  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilGenerateRandomTextTest.run();
	}
}

class StringUtilGenerateRandomTextTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random random = new Random();
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
				
			System.out.printf("Text:%s%n", StringUtil.generateRandomTextEN(random, count));
			System.out.printf("Yazı:%s%n", StringUtil.generateRandomTextTR(random, count));
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte generateRandomTextEN metodu aşağıdaki gibi de yazılabilir. Şüphesiz bir önceki yöntem daha
	genel olma eğilimindedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		GenerateRandomTextENTest.run();
	}
}

class GenerateRandomTextENTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		Random random = new Random();
		
		while (true) {
			System.out.print("Input count:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
				
			System.out.printf("Text:%s%n", Util.generateRandomTextEN(random, count));
		}
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static String generateRandomTextEN(Random random, int count)
	{
		StringBuilder sb = new StringBuilder(count);
		
		for (int i = 0; i < count; ++i)
			sb.append((char)((random.nextBoolean() ? 'A' : 'a') + random.nextInt(26)));
		
		return sb.toString();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Character sınıfının çeşitli metotları ile bir karakter ile işlemler yapılabilmektedir. Örneğin isXXX static metotları 
	ile bir karakterin hangi karakter biçiminde olduğu anlaşılabilir. Örneğin, isWhitespace metodu bri karakterin
	whitespace karakter olup olmadığını test eder. isDigit metodu bir karakterin rakam karakteri olup olmadığını 
	test eder. toXXX metotları ise bri karakteri çevirek için kullanılabilir. Örneğin toUpperCase metodu bir karakteri
	büyük harfe çevirmek için, toLowerCase metodu ise bir karakteri küçük harfe çevirmek için kullanılır. Character
	sınıfının String sınıfına yardımcı olarak kullanılabilen pek çok metodu da bulunmaktadır. Bunlar için dokümantasyona
	başvurulabilir  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		char c1 = '\n';
		char c2 = '1';
		char c3 = 'D';
		char c4 = 'd';
		
		
		System.out.println(Character.isWhitespace(c1));
		System.out.println(Character.isDigit(c2));
		System.out.println(Character.isLetter(c3));
		System.out.println(Character.isLowerCase(c4));
		System.out.println(Character.toUpperCase(c4));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	substring metodunun tek parametreli overload'una yazının uzunluğu index olarak verildiğinde exception oluşmaz, boş 
	string'e geri döner. Benzer şekilde iki parametreli overload'una geçilen indeks değerleri aynı ise yine boş string'e
	geri döner  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.print("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		System.out.println(s.substring(s.length()).isEmpty());
		System.out.println(s.substring(0, 0).isEmpty());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazıyı baş harfini büyük geri kalan harflerini küçük olacak şekilde
	dönüştüren ve bu yazıya geri dönen capitalize isimli metodu StringUtil içerisinde yazınız ve aşağıdaki kod ile
	test ediniz  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilCapitalizeTest.run();
	}
}

class StringUtilCapitalizeTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.capitalize(s));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının Türkçe pangram olduğunu test eden isPangramTr ve İnglizce pangram
	olduğunu test eden isPangramEN metotlarını StringUtil sınıfı içerisinde yazınız ve test ediniz. 
	
	Pangram: İçerisinde özel isim geçmeyen ve ilgili dilin alfabesinde tüm karakterlerin kullanıldığı cümlelere denir.
	
	Programda özel isim ve anlamlı olması durumlarına bakılmayacaktır
	
	İnglizce Pangram: The quick brown fox jumps over the lazy dog
	Türkçe Pangram: Pijamalı hasta yağız şoföre çabucak güvendi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

class App { 
	public static void main(String [] args) 
	{	
		StringUtilIsPangramTest.run();
	}
}

class StringUtilIsPangramTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		StringUtilIsPangramTRTest.run(kb);
		StringUtilIsPangramENTest.run(kb);
	}
}

class StringUtilIsPangramTRTest {
	public static void run(Scanner kb)
	{
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramTR(s) ? "Pangram" : "Pangram değil");
		}
	}
}


class StringUtilIsPangramENTest {
	public static void run(Scanner kb)
	{
		while (true) {
			System.out.print("Input a text:");
			String s = kb.nextLine();
			
			if ("quit".equals(s))
				break;
			
			System.out.println(StringUtil.isPangramEN(s) ? "Pangram" : "Not a Pangram");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının trim metodu yazının başındaki ve sonundaki boşluk karakterlerini siler. Aradaki boşluk karakterlerine
	dokunmaz. Java 11 ile birlikte strip, stripLeading ve stripTrailing denilen 3 tane boşluk (whitespace) silen metot daha
	eklenmiştir. strip metodu yazının başındaki ve sonundaki boşluk karakterlerini siler, stripLeading yalnızca yazının
	başındaki boşluk karakterlerini siler, stripTrailing ise yazının yalnızca sonundaki boşluk karakterlerini siler.
	Peki trim ile strip arasında ne fark vardır?
	
	Java'da aşağıdaki koşullardan birini sağlayan bir karakter whitespace karakterdir. Tersine whitespace bir karakter
	aşağıdaki koşullardan birini sağlar (if and only if):
  	
  	- Karakter "Unicode space" karakter ve "Non-breaking space" olmayan karakterlerdendir. 
  	Unicode space karakterler şunlardır:  Space Seperator, Line Seperator, Paragraph Seperator. Bu karakterler
  	UNICODE'da çeşitli kategorilerdir. Detaylar burada ele alınmayacaktır. Bu karakter Character sınıfının
  	SPACE_SEPERATOR, LINE_SEPERATOR, PARAGRAPH_SEPERATOR isimli static veri elemanları ile elde edilebilir. 
  	non-breaking space karakterler şunlardır: '\u00A0', '\u2007', '\u202F'
  	
  	- '\t' horizontal tabulation
  	
  	- '\n' line feed (LF)
  	
  	- '\u000B' vertical tabulation
  	
  	- '\f' form tabulation
  	
  	- '\r' carriage return (CR)
  	
  	- '\u001C' file separator
  	
  	- '\u001D' group separator
  	
  	- '\u001E' record separator
  	
  	- '\u001F' unit separator
  	
  	Character sınıfının isWhitespace metodu bir karakter için bu koşullara bakar. 
  	
  	trim metodu dökumana göre '\u0020''den küçük veya eşit olan whitespace karakterleri siler. strip metodu 
  	yukarıda anlatılan koşullara uyan whitespace karakterleri siler
  	
  	Yukarıda anlatılanların detayları vardır. Şu aşamada önemsizdir. 
  	
  	Bu durumda programcı Java 11+ ile çalışıyorsa, tüm whitespace karakterler için strip metodunu çağırmalıdır. Java 11
  	öncesi için tüm whitespace karakterleri atan bir trim metotları yazılıp utility bir kütüphane oluşturulabilir.
  	
  	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		
		System.out.println("Bir yazı giriniz:");
		String s = kb.nextLine();
		
		System.out.printf("(%s)%n", s);
		System.out.printf("(%s)%n", s.trim());
		System.out.printf("(%s)%n", s.strip()); //Since Java 11
		System.out.printf("(%s)%n", s.stripLeading()); //Since Java 11
		System.out.printf("(%s)%n", s.stripTrailing()); //Since Java 11
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Java 11 öncesinde çalılıldığı varsayımıyla aşağıda prototipleri verilen metotları Util isimli 
	sınıfta yazınız ve test ediniz.
		public static String trim(String s);
		public static String trimLeading(String s);
		public static String trimTrailing(String s);
	Açıklamalar:
		- trim metodu baştakı ve sondaki, trimLeading metodu yalnızca baştaki, trimTrailing metodu yalnızca sondaki
		whitespace karakterleri atacaktır. 
		- Atılacak karakterler whitespace tanımına uyan tüm karakterlerdir.
		- Java 11 öncesinde çalışıldığı varsayımından dolayı stripXXX metotları kullanılamayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App { 
	public static void main(String [] args) 
	{	
		TrimLeadingTarilingTest.run();
	}
}

class TrimLeadingTarilingTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.printf("(%s)%n", s);
			System.out.printf("(%s)%n", Util.trim(s));
			System.out.printf("(%s)%n", Util.trimLeading(s));
			System.out.printf("(%s)%n", Util.trimTrailing(s));
		}
	}
}

class Util {
	public static String trim(String s)
	{
		return trimTrailing(trimLeading(s));
	}
	
	public static String trimLeading(String s)
	{
		int len = s.length();
		int i = 0;
		
		for (; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;
		
		return s.substring(i);
	}
	
	public static String trimTrailing(String s)
	{
		int i = s.length() - 1;
		
		for (; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;
		
		return s.substring(0, i + 1);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	09.12.2023  	
---------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir yazının palindrom olup olmadığını test eden isPalindrome isimli
	metodu StringUtil sınıfı içerisinde yazınız test ediniz
	Açıklamalar:
		- Yalnızca alfabetik karakterleri tersten okunduğunda aynısı olan yazılara palindrom denir. Örneğin
			Anastas mum satsana
			Ey Edip Adana'da pide ye
			Ali Papila
			
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.string.test;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

public class StringUtilIsPalindromeTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.println(StringUtil.isPalindrome(s) ? "Palindrom" : "Palindrom değil");
		}
	}
	
	public static void main(String [] args)
	{
		run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel türden bir değeri yazıya çevirmek için String sınıfının valueOf static metotları kullanılabişlir
	
	Anahtar Notlar: Aldığı parametrelere göre nesneyi yaratan static metotlara "factory method" denilmektedir. Şüphesiz
	burada ctor kastedilmemektedir.
	
	Aslında temel türden bir değer yazıya şu şekilde de çevrilebilir:
		a temel türden bir ifade olmak üzere a + ""
	Ancak bu durumda valueOf metodunun kullanılması tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class App { 
	public static void main(String [] args) 
	{	
		int a = 10;
		String s;
		
		s = String.valueOf(a);
		
		System.out.println(s);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfına Java 11 ile birlikte repeat isimli bir metot eklenmiştir. Bu metot aldığı int türden parametrenin
	değeri kadar yazıyı çoklar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		System.out.println("ankara".repeat(3));
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıda prototipleri verilen metotları StringUtil sınıfı içerisinde yazınız ve test ediniz
		public static String padLeading(String s, int newLen, char ch);
		public static String padLeading(String s, int newLen);
		public static String padTrailing(String s, int newLen, char ch);
		public static String padTrailing(String s, int newLen);
	Açıklamalar:
		- padLeading metodunun 3 parametreli overload'u aldığı yazının uzunluğu newLen ile aldığı değerden küçükse
		yazıyı baştan, üçüncü parametresi ile aldığı karakter ile besleyecektir. Örneğin:
		 	padLeading("ankara", 11, 'x');
		çağrısı için 
		 	xxxxxankara
		yazısına dönecektir.
		newLen değeri yazının uzunluğundan büyük değilse aynı yazıya geri dönecektir
		 
		- padLeading metodunun 2 parametreli overload'u yazıyı space ile besleyecektir
		 
		- padTrailing metotları, padLeading metotlarının sondan besleyen versiyonları olarak yazılacaktır
		
		Metotlar Java 11 öncesinde yazıldığı için aşağıdaki metot da StringUtil sınıfında bulunması iyi bir yaklaşımdır:
		public static String repeat(char ch, int count)
		{
			StringBuilder sb = new StringBuilder(count);
			
			while (count-- > 0)
				sb.append(ch);
		
			return sb.toString();
		}
		
		Java 11 ile birlikte repeat metodu eklendiğinden StringUtil sınıfına ayrıca bir repeat metodunu eklemeye
		gerek yoktur
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.string.test;

import java.util.Scanner;

import org.csystem.util.string.StringUtil;

public class StringUtilPadLeadingTrailingTest {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);
		
		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();
			
			if ("elma".equals(s))
				break;
			
			System.out.print("Bir sayı giriniz:");
			int len = Integer.parseInt(kb.nextLine());
			
			System.out.printf("(%s)%n", s);
			System.out.printf("(%s)%n", StringUtil.padLeading(s, len, 'x'));
			System.out.printf("(%s)%n", StringUtil.padLeading(s, len));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, len, 'x'));
			System.out.printf("(%s)%n", StringUtil.padTrailing(s, len));
		}
	}
	
	public static void main(String [] args)
	{
		run();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının format metodu printf metodu gibi çalışır. Formatladığı yazıyı ekrana basmaz String olarak döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();

		String message = String.format("Sayı:%d", a);

		System.out.println(message);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf türünden nesnenin yazısal karşılığının anlamlı olması durumunda o sınıfa bir convention
	olarak toString metodu yazılır. Bu isim JavaSE açısından da önemlidir. Önemi ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------
	FILE NAME	: Complex.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 9th December 2023

	Complex class that represents a complex number

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math;

public class Complex {
	public double real, imag;

	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		real = re;
	}

	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}

	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}

	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}

	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}

	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}

	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}

	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}

	public Complex conjugate()
	{
		return new Complex(real, -imag);
	}

	public Complex negate()
	{
		return new Complex(-real, -imag);
	}

	public void inc()
	{
		++real;
	}

	public void dec()
	{
		--real;
	}

	public String toString()
	{
		return String.format("%f + %f * i", real, imag);
	}
}

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 9th December 2023

	Point class that represents a 2 dimensional point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.sqrt;
import static java.lang.Math.pow;

public class Point {
	public double x, y;

	public Point()
	{
	}

	public Point(double a)
	{
		x = a;
	}

	public Point(double a, double b)
	{
		x = a;
		y = b;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}

	public double distance(double a, double b)
	{
		return sqrt(pow(x - a, 2) + pow(y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının replace metotları aldıkları yazı içerisindeki bir karakterin veya yazının tümünü değiştirir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		String s = "Bugün hava çok yağmurlu, çok yağmurlu havalarda şemsiye alınız";

		System.out.println(s.replace('ç', 't'));
		System.out.println(s.replace("çok", "az"));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Soru: Aşağıdaki programın çıktısı ne olur? Neden?
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		System.out.println("Java" + 12 + 34);
		System.out.println(12 + 34 + "Java");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Soru: Aşağıdaki repeat metodunu döngü kullanmadan ve Java 11 ile eklenen repeat metodunu kullanmadan yazınız.
		public static String repeat(char ch, int count)
		{
			StringBuilder sb = new StringBuilder(count);

			while (count-- > 0)
				sb.append(ch);

			return sb.toString();
		}
	Not: Örnek şu ana kadar öğrtendiklerimizle yapılmıştır. Başka yöntemler de vardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		System.out.println(Util.repeat1('x', 4));
		System.out.println(Util.repeat2('x', 4));
	}
}

class Util {
	public static String repeat1(char ch, int count)
	{
		return String.format("%0" + count + "d", 0).replace('0', ch);
	}

	public static String repeat2(char ch, int count)
	{
		return String.format("%" + count + "c", ' ').replace(' ', ch);
	}
}

/*--------------------------------------------------------
	FILE NAME	: StringUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 9th December 2023

	Utility class for string operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.string;

import java.util.Random;

public class StringUtil {
	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;

		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String generateRandomTextEN(Random random, int count)
	{
		return generateRandomText(random, count, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	}

	public static String generateRandomTextTR(Random random, int count)
	{
		return generateRandomText(random, count, "abcçdefgğhıijklmnoöprsştuüvyzABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ");
	}

	public static String generateRandomText(Random random, int count, String sourceText)
	{
		StringBuilder sb = new StringBuilder(count);
		int len = sourceText.length();

		for (int i = 0; i < count; ++i)
			sb.append(sourceText.charAt(random.nextInt(len)));

		return sb.toString();
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), "abcdefghijklmnopqrstuvwxyz");
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), "abcçdefgğhıijklmnoöprsştuüvyz");
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static String padLeading(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : String.valueOf(ch).repeat(newLen - s.length()) + s;
	}

	public static String padLeading(String s, int newLen)
	{
		return padLeading(s, newLen, ' ');
	}

	public static String padTrailing(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : s + String.valueOf(ch).repeat(newLen - s.length());
	}

	public static String padTrailing(String s, int newLen)
	{
		return padTrailing(s, newLen, ' ');
	}


	public static String reverse(String s)
	{
		return new StringBuilder(s).reverse().toString();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	16.12.2023
---------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Diziler (Arrays): Elemanları aynı türden olan ve bellekte peşpeşe olacak şekilde yaratılan veri yapılarıdır. Diziler
	önemli veri yapılarından biridir. Java'da diziler sınıfsal olarak temsil edilirler. Yani bir dizi heap'de yaratılır.
	Java'da stack'de dizi yaratılamaz. Mademki diziler sınıfsal temsil edilmiştir, o zaman dizi türünden bir referans
	değişken de söz konusudur. Bir dizi referans değişkeni iki şekilde bildirilebilir:
		1. <tür> [] <değişken ismi>
		2. <tür> <değişken ismi>[]
	Burada tür dizinin her bir elemanının türüdür. []'ler değişkenin bir dizi referansı olduğunu belirtir. Örneğin:
		int [] a;
		int a[];
	Burada dizinin her bir elemanının türü int'dir. Diğer bir deyişle a int türden bir dizi referansıdır. Bir burada
	birinci biçimi tercih edeceğiz.

	Bir dizi nesnesi yani bir dizi yaratmak için yine new operatörü kullanılır. Dizi yaratmak için new operatörünün
	kullanımının genel biçimi şu şekildedir:
	    new <tür>[<int türüne doğrudan dönüşebilen ifade>];
    Burada tür dizinin her bir elemanınn türüdür, [] içerisinde ise dizinin eleman sayısı (uzunluğu) belirtilmiş olur. Burada da
    new operatörü yaratılmış olan dizinin adresini üretir. Java'da yaratılmış olan bir dizinin uzunluğu yani eleman
    sayısı değiştirilemez. Yani bir dizi büyütülüp küçültülemez. Dizinin uzunluk bilgisi sabit ifadesi olmak zorunda
    değildir. Dizinin uzunluğu length isimli bir veri elemanı ile elde edilebilir. length elemanı final olarak
    bildirilmiştir. Yani değeri değiştirilemez. final değişkenler ileride ele alınacaktır. Dizinin her bir elemanına
    [] operatörü ile erişilebilir. [] operatörü iki operandlı araek durumunda bir operatördür. Operatörün birinci operandı
    bir dizi referansı olmalıdır. Bu referans ['den önce yazılır. [ ile ] arasında int türüne dönüşebilen bir indeks
    numarası yazılır. Indeks numarası sıfır değerinden başlar. Verilen index numarası pozitif ya da negatif bakımdan
    sınırlar dışında ise exception oluşur. Bu anlamda indeks değeri [0, length) aralığında olmalıdır. [] operatörü dizinin
    ilgili indeksteki elemanı olan değişkeni üretir. Dizi ilk kez yaratıldığında elemanları default değerlerini alırlar.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Dizi referansları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a; //int türden dizi referansı
		int b[]; //int türden dizi referansı
		double [] c; //double türden dizi referansı

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi referans bildirimlerinin farkı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a, b, c;
		int x[], y, z;

		b = 10; //error
		x = 23; //error
		y = 20;

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		int [] a;

		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		a = new int[n];
		System.out.printf("Eleman sayısı:%d%n", a.length);

		for (int i = 0; i < a.length; ++i)
			a[i] = i * 10;

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		int [] a;
		boolean [] b;

		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();

		a = new int[n];
		b = new boolean[n];

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
		for (int i = 0; i < b.length; ++i)
			System.out.printf("%b ",b[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir diziye ilk değer verme (initialization) işlemi dizi nesnesi yaratılırken {} ile yapılır. {} içerisinde diziye
	ilk değer olarak verilen elemanlar virgül kullanılarak listelenir. Son yazılan elemandan sonra yazılan virgül sentaks
	olarak geçerlidir. Dizinin uzunluğu verilen eleman sayısı kadar olur. İlk değer verme işleminde new operatörünün
	[] içerisi boş bırakılır. Boş bırakılmaması error oluşturur. Aşağıdaki örnekte diziye ilk değer verildiğine ancak
	diziyi gösteren referansa ilk değer verilmediğine dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a;

		a = new int[]{1, 2, 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte hem diziye hem de referansa ilk değer verildiğine dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a = new int[]{1, 2, 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Diziye ilk değer verilirken aynı zamanda onu gösteren referansa da ilk değer veriliyorsa new operatörü kullanılması
	gerekmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6};

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte referansa ilk değer verilmediği noktada new operatörü kullanılmadığından dolayı error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a;

		a = {1, 2, 3, 4, 5, 6}; //error

		for (int i = 0; i < a.length; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkeni bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6};

		print(a);
		print(a, 3);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun parametre değişkeni bir dizi referansı olduğunda metot dizi elemanları üzerinde değiştirebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import static org.csystem.util.array.ArrayUtil.print;
import static org.csystem.util.array.ArrayUtil.swap;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6};

		print(a);

		swap(a, 2, 3);
		print(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri de bir dizi referansı olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

import static org.csystem.util.array.ArrayUtil.*;

class App {
	public static void main(String [] args)
	{
		int [] a = generateRandomArray(new Random(), 10, 0, 100);

		print(2, a);

		swap(a, 2, 3);
		print(2, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	ArrayUtil sınıfının reverse metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilReverseTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            ArrayUtil.reverse(a);
            ArrayUtil.print(2, a);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	reverse metodun başka bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String [] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		Random random = new Random();

		for (int i = 0; i < count; ++i) {
			System.out.println("----------------------------------------------------");
			int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

			ArrayUtil.print(2, a);
			ArrayUtil.reverse(a);
			ArrayUtil.print(2, a);
			System.out.println("----------------------------------------------------");
		}
	}
}

class Util {
	public static void reverse(int [] a)
	{
		int left = 0;
		int right = a.length - 1;

		while (left < right)
			swap(a, left++, right--);
	}

	public static void swap(int [] a, int i, int k)
	{
		int temp = a[i];

		a[i] = a[k];
		a[k] = temp;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	ArrayUtil sınıfının reversed metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilReversedTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            int [] b = ArrayUtil.reversed(a);
            ArrayUtil.print(2, a);
            ArrayUtil.print(2, b);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    17.12.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Diziler sınıfsal olarak temsil edildiğinden temel türden diziler arasında explici tür dönüşüm geçersizdir. Aslında
	bu farklı türden referansların dönüşümüdür, dolayısıyla geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = {1, 2, 3, 4};
		long [] b;

		b = (long[])a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Uzunluğu sıfır olan bir dizi yaratılabilir. Ortada bir dizi nesnesi vardır ancak bu dizide herhangi bir eleman
	tutulamaz. Mantıksal olarak boş dizi biçiminde düşünülebilir. Uzunluğu sıfır olan bir dizi iki şekilde oluşturulabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		int [] a = new int[0];
		int [] b = {};

		System.out.printf("Length:%d%n", a.length);
		System.out.printf("Length:%d%n", b.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	ArrayUtil sınıfının sum metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilSumTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            System.out.printf("Toplam%d%n", ArrayUtil.sum(a));
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
  	ArrayUtil sınıfının min ve max metotları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilMinMaxTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            System.out.printf("Minimum:%d%n", ArrayUtil.min(a));
            System.out.printf("Maksimum:%d%n", ArrayUtil.max(a));
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir dizi ve int türden n değerine göre aşağıda açıklanan metodu
	yazınız ve test ediniz.
	Açıklamalar:
		- Metot ArrayUtil sınıfı içerisinde aşağıdaki bçimde yazılacaktır:
				public static int [] histogramData(int [] a, int n)
		- Metot dizi içerisinde [0, n] aralığında değerler olduğu varsayımıyla bu aralıktaki her bir değerden kaç tane
		olduğunu içeren bir diziye geri dönecektir.

		- Geri döndüğü dizinin her bir elemanı indek numarasına ilişkin sayının kaç tane olduğu bilgisidir. Örneğin
		sıfır numaralı indekse sıfır sayısının kaç tane olduğu, 1 numaralı indekste 1 sayısının kaç tane olduğu, ...,
		n numaralı indekste n sayısının kaç tane olduğu bilgisi olacaktır

		- Metot içerisinde dizinin elemanlarına ilişkin ve n sayısının pozitif olp olmamasına ilişkin bir kontrol
		yapılmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilHistogramDataTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(10, 41), 0, 11);

            ArrayUtil.print(2, a);
            int [] data = ArrayUtil.histogramData(a, 10);

            ArrayUtil.print(data);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Rasal olarak belirlenmiş sayısal loto kuponu üreten programı aşağıdaki açıklamalara göre yazınız.
	Açıklamalar:
		- Bir sayısal loto kuponu sıralanmış ve elemanları tekrarlamayan [1, 49] aralığında 6 tane sayıdan oluşur
		- NumericLottery isimli bir sınıf yazınız, sınıfın getNumbers isimli metodu ile kuponu döndürünüz. Sınıf
		Random referansını ctor ile alacaktır
	Not: Aşağıdaki yaklaşım görece iyi bir yaklaşım değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.random.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();
        NumericLottery numericLottery = new NumericLottery(random);

        while (true) {
            System.out.print("Kaç kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.random.lottery;

import java.util.Arrays;
import java.util.Random;

public class NumericLottery {
    public Random random;

    public NumericLottery(Random r)
    {
        random = r;
    }

    public int [] getNumbers()
    {
        int [] numbers = new int[6];
        boolean repeat;

        for (int i = 0; i < 6; ++i) {
            do {
                repeat = false;
                numbers[i] = random.nextInt(1, 50);
                for (int k = 0; k < i; ++k)
                    if (numbers[i] == numbers[k]) {
                        repeat = true;
                        break;
                    }
            } while (repeat);
        }

        Arrays.sort(numbers);

        return numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Rasal olarak belirlenmiş sayısal loto kuponu üreten programı aşağıdaki açıklamalara göre yazınız.
	Açıklamalar:
		- Bir sayısal loto kuponu sıralanmış ve elemanları tekrarlamayan [1, 49] aralığında 6 tane sayıdan oluşur
		- NumericLottery isimli bir sınıf yazınız, sınıfın getNumbers isimli metodu ile kuponu döndürünüz. Sınıf
		Random referansını ctor ile alacaktır
	Not: Aşağıdaki yaklaşım yukarıdaki yaklaşıma göre daha iyidir. İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.random.lottery;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class NumericLotteryApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();
        NumericLottery numericLottery = new NumericLottery(random);

        while (true) {
            System.out.print("Kaç kupon oynamak istersiniz?");
            int count = Integer.parseInt(kb.nextLine());

            while (count-- > 0)
                ArrayUtil.print(2, numericLottery.getNumbers());
        }
    }
    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.random.lottery;

import java.util.Arrays;
import java.util.Random;

public class NumericLottery {
    public Random random;

    public boolean[] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;

            do
                val = random.nextInt(1, 50);
            while (flags[val]);
            flags[val] = true;
        }

        return flags;
    }

    public int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];
        int idx = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[idx++] = i;

        return numbers;
    }

    public NumericLottery(Random r)
    {
        random = r;
    }

    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının basamaklarından oluşan diziye geri dönen digits
	isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	Açıklama: Metot negatif bir sayı için basamakları pozitif olarak diziye ekleyecektir
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.numeric.test;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.numeric.NumberUtil;

import java.util.Random;
import java.util.Scanner;

public class NumberUtilDigitsTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            long value = random.nextLong();

            System.out.printf("%d -> ", value);
            ArrayUtil.print(NumberUtil.digits(value));
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	char türden diziler: char türden diziler ile yazılar tutulabilir. char türden diziler String sınıfına bazı durumlarda
	yardımcı olarak kullanılabilmektedir. Örneğin String'in immutable olmasının dezavantaj oluşturduğu bir durumda char
	türden dizi ile işlem yapılabilir. Şüphesiz bu durumda StringBuilder sınıfı da kullanılabilir. String sınıfının char
	türden dizi parametreli ctor'ları ve char türden dizi parametreli valuOf metotları ile char türden diziden bir String
	elde edilebilir. String sınıfının toCharArray metodu ile tutulan yazının karakterlerinden oluşan yeni bir dizi
	elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının diziden String elde eden ctor ve valueOf metotları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		char [] c = {'A', 'n', 'k', 'a', 'r', 'a'};

		String s1 = new String(c);
		String s2 = String.valueOf(c);
		String s3 = new String(c, 0, 4);
		String s4 = String.valueOf(c, 0, 4);

		System.out.println(s1);
		System.out.println(s2);
		System.out.println(s3);
		System.out.println(s4);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının diziden String elde eden ctor ve valueOf metotları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		String s = "Ankara";
		char [] c = s.toCharArray();

		for (int i = 0; i < c.length; ++i)
			System.out.printf("%c ", c[i]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki reverse metodunu inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.array.ArrayUtil;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		while (true) {
			System.out.print("Bir yazı giriniz:");
			String s = kb.nextLine();

			if ("elma".equals(s))
				break;

			System.out.println(Util.reverse(s));
		}
	}
}

class Util {
	public static String reverse(String s)
	{
		char [] c = s.toCharArray();

		ArrayUtil.reverse(c);

		return String.valueOf(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Scanner sınıfı aslında okuma işlemlerinde kullanılan genel bir sınıftır. Bu sınıf nesne yaratılırken
	aldığı kaynaktan okuma yapar. Scanner sınıfınının ilgili ctor'una System.in arguman olarak verildiğinde okuma
	standard input'tan (kabaca klavyeden) yapılır. Scanner sınıfının çalışma sistematiği dılayısıyla özellike Syetem.in'den
	okuma yapılırken aynı nesne içim nextLine metodu ile birlikte temel türlere ilişkin nextXXX metotlarının (nextInt, nextLong vb)
	çağrılması durumunda bazı sistemlerde problem oluşabilir. Problemin detayları ve çözümü ve dolayısıyla Scanner sınıfının
	çalışma sistematiği ayrı bir konudur ve burada ele alınmayacaktır. Programcı açısından böylesi bir durumda nextLine
	ile birlikte diğer metotların çağrılmaması yani yine nextLine metosdu ile alınan yazıların parseXXX metotları ile
	ilgili değere çevrilmesi tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		while (true) {
			System.out.print("İsmi giriniz:");
			String name = kb.nextLine();

			if ("elma".equals(name))
				break;

			System.out.print("Numarayı giriniz:");
			int no = kb.nextInt();

			System.out.printf("%s, %d%n", name, no);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yapılarak problem giderilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		while (true) {
			System.out.print("İsmi giriniz:");
			String name = kb.nextLine();

			if ("elma".equals(name))
				break;

			System.out.print("Numarayı giriniz:");
			int no = Integer.parseInt(kb.nextLine());

			System.out.printf("%s, %d%n", name, no);
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	24.12.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Dizilerin Sıraya Dizilmesi (Sorting):
	Dizilerin sıraya dizilmesine yönelik bir çok algoritma vardır. Sıralama işleminin küçükten büyüğe diğer bir deyişle
	artan sırada (ascending) yapılmasına doğal sıralama (natural sort order) denir. Biz burada kabarcık sıralama
	(bubble sort) ve seçerek sıralama (selection sort) algoritmalarını kodlayacağız. Algoritmalar doğal sıralama olacak
	şekilde anlatılacaktır ancak her ikisi de kodlanacaktır.

	Anahtar Notlar: Algoritmaların karşılaştırmasına yönelik iki ölçüt vardır: hız (speed), kaynak kullanımı (resource usage).
	Burada baskın ölçüt hızdır. Burada implemente edilen bubble sort ve selection sort algoritmaları karşılaştırılmayacaktır.
	Algoritma analizi isimli konuda bu iki algoritmanın karşılaştırması da ayrıca yapılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Kabarcık sıralama algoritmasında dizinin yanyana iki elemanı karşılaştırılır ve duruma göre yer değiştirilir. Her
	yinelemede en büyük eleman daraltılmış dizinin sonuna gider. Böylece her yinelemede eskisinden bir geriye kadar
	gidilmiş olur

	Örneğin:
	23 9 67 -8 34 -5 14 22 68 45 -10 3 16

	9 23 -8 34 -5 14 22 67 45 -10 3 16 68

	9 23 -8 -5 14 22 34 45 -10 3 16 67 68

	...
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilBubbleSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            boolean desc = random.nextBoolean();

            ArrayUtil.bubbleSort(a, desc);
            System.out.printf("Dizi %s sıralandı:%n", desc ? "büyükten küçüğe" : "küçükten büyüğe");
            ArrayUtil.print(2, a);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Seçerek sıralama algoritmasında en küüçük eleman bulunur, ilk eleman ile yer değiştirilir. Dizi bir daraltılır, aynı
	işlem daraltılmış dizi için yapılır. Böylece ilerlenir

	Örneğin:
	23 9 67 -8 34 -5 14 22 68 45 -10 3 16

	-10 9 67 -8 34 -5 14 22 68 45 23 3 16

	-10 -8 67 9 34 -5 14 22 68 45 23 3 16

	...
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilSelectionSortTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            boolean desc = random.nextBoolean();

            ArrayUtil.selectionSort(a, desc);
            System.out.printf("Dizi %s sıralandı:%n", desc ? "büyükten küçüğe" : "küçükten büyüğe");
            ArrayUtil.print(2, a);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Bölümleme (Partition) Algoritması: Bu algoritmada amaç, bir dizinin belirli bir koşula uyan elemanlarının dizinin
	başında, uymayanların ise sonuna getirilmesidir. Bu işlem başka bir dizi kullanmadan yapılabilir. Dizi elde edildikten
	sonra ilk koşula uymayan elemanın bulunduğu indeks değerine bölümleme noktası (partition point) denir. Bu işlem tipik
	olarak şu şekilde yapılabilir. Önce dizinin ilk koşula uymayan elemanı bulunur. Sonra ikinci bir indeks ile koşula
	uymayan ilk elemandan bir sonraki elemana konumlanılır. Eğer eleman koşula uyuyorsa koşula uymayan eleman ile yer
	değiştirilir ve birinci indeks artırılır. İkinci indeks her durumda artırılır. Böylece ilerlenir. Bu durumda birinci
	indeks partition point olarak elde edilmiş olur.
	Örneğin
	9 2 23 67 -8 34 -5 14 22 68 45 -10 3 16
	dizisinde 11 değerinden küçük olan elemanların bölümlenmesi şu şekilde elde edilebilir:
	1.indeks: 2
	2.indeks: 3 -> 4

	9 2 -8 67 23 34 -5 14 22 68 45 -10 3 16
	1.indeks: 3
	2.indeks: 5 -> 6

	9 2 -8 -5 23 34 67 14 22 68 45 -10 3 16
	1.indeks: 4
	2.indeks: 7

	...
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.util.array.test;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ArrayUtilPartititonTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Random random = new Random();

        for (int i = 0; i < count; ++i) {
            System.out.println("----------------------------------------------------");
            int [] a = ArrayUtil.generateRandomArray(random, random.nextInt(5, 11), 0, 100);

            ArrayUtil.print(2, a);
            int threshold = random.nextInt(-10, 150);

            System.out.printf("Eşik değeri:%d%n", threshold);
            int partitionPoint = ArrayUtil.partition(a, threshold);

            ArrayUtil.print(2, a);
            System.out.printf("Bölümleme noktası:%d%n", partitionPoint);
            System.out.println("----------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Referans Dizileri (Reference Arrays): Dizinin her elemanı bir referans türünden olan diziye referans dizisi denir.
	Bu durumda dizinin her bir elemanı bir adres tutar. Bu durumda dizinin yaratılması dizinin elemanları olan referansların
	gösterdiği nesnelerin yaratılması anlamına gelmez. Bu durumda her bir referansa default olarak null değeri atanır. Yani
	bu referansların gösterdiği nesneler yaratılmış olmaz. Bu durumda programcının tipik olarak referans dizisini yarattıktan
	sonra her bir referansa uygun adresi de vermesi gerekir. Aksi durumda referansların kullanılması exception oluşturur.

	Anahtar Notlar: Programlamada kullanılmayan yani o bellek bölgesi için yer ayrılmayan adrese "null address" denir.
	Sistemlerin bir çoğunda belleğin sıfır numaralı gözeneği kullanılır ancak bu zorunlu değildir. Java'da null adress
	null isimli bir sabit (anahtar sözcük) ile temsil edilir. Referansların default değeri null'dır. İçerisinde null bulunan
	bir referans ile sınıfın elemanlarına erişilmesi exception oluşumuna yol açar. null address detayları ileride ele
	alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dizi yaratılmış ancak dizinin elemanı olan referanslar null değerinde olduğundan exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		Sample[] samples = new Sample[kb.nextInt()];

		for (int i = 0; i < samples.length; ++i)
			samples[i].x = i * 10;

		System.out.println("Dizinin elemanları yazdırılıyor:");

		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d ", samples[i].x);

		System.out.println();
	}
}

class Sample {
	public int x;

	public Sample(int a)
	{
		x = a;
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi her bir referans değişkene bir nesnenin adresi verilerek yazılabilir. Şüphesiz bu
	bir çözümdür, senaryoya göre başka çözümler de olabilir. Burada önemli olan referans dizisi yaratıldığında her bir
	referansın gösterdiği nesnenin yaratılmamasıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		Sample[] samples = new Sample[kb.nextInt()];

		for (int i = 0; i < samples.length; ++i)
			samples[i] = new Sample(i * 10);

		System.out.println("Dizinin elemanları yazdırılıyor:");

		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d ", samples[i].x);

		System.out.println();
	}
}

class Sample {
	public int x;

	public Sample(int a)
	{
		x = a;
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Referans dizilerine de ilk değer verilebilir. Bu durumda değerlerin uygun adresler olması gerekir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Sample s1 = new Sample(10);
		Sample s2 = new Sample(20);
		Sample[] samples = {s1, s2, new Sample(34), s1, new Sample(56), new Sample(67), s2};

		for (int i = 0; i < samples.length; ++i)
			System.out.printf("%d ", samples[i].x);

		System.out.println();
	}
}

class Sample {
	public int x;

	public Sample(int a)
	{
		x = a;
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Pratikte String türden dizilerle çok sık karşılaşılır. String türden bir dizi de aslında bir referans dizisidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		String [] cities = {"ankara", "istanbul", "izmir", "zonguldak"};

		for (int i = 0; i < cities.length; ++i)
			System.out.printf("%s%n", cities[i]);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir

		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir

	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.datetime;

import java.util.Scanner;

public class DemoDateApp {
	public static void run()
	{
		Scanner kb = new Scanner(System.in);

		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();

			if (day == 0 && month == 0 && year == 0)
				break;

			DateUtil.printDateTR(day, month, year);
		}

		System.out.println("Tekrar yapıyor musunuz?");
	}

	public static void main(String[] args)
	{
		run();
	}
}

package org.csystem.app.datetime;

public class DateUtil {
	public static int [] daysOfMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	public static String [] dayOfWeeksTR = {"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
	public static String [] dayOfWeeksEN = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

	public static String [] monthsTR = {"", "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz",
			"Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"};

	public static String [] monthsEN = {"", "January", "February", "March", "April", "May", "June", "July",
			"August", "September", "October", "November", "December"};

	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);

		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}

		int dayOfWeek = getDayOfWeek(day, month, year);

		System.out.printf("%d %s %d %s tarihi yılın %d. günüdür%n", day, monthsTR[month], year,
				dayOfWeeksTR[dayOfWeek], dayOfYear);

		if (dayOfWeek == 0 || dayOfWeek == 6)
			System.out.printf("Bugün günlerden %s, kurs var tekrar yaptınız mı?%n", dayOfWeeksTR[dayOfWeek]);
		else
			System.out.printf("Bugün günlerden %s, kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız!...%n", dayOfWeeksTR[dayOfWeek]);
	}

	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;
	}

	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;

		return totalDays;
	}

	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? getDayOfYearValue(day, month, year) : -1;
	}

	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;

		for (int m = month - 1; m >= 1; --m)
			dayOfYear += daysOfMonths[m];

		return month > 2 && isLeapYear(year) ? dayOfYear + 1 : dayOfYear;
	}

	public static String getDaySuffix(int day)
	{
		return switch (day) {
			case 1, 21, 31 -> "st";
			case 2, 22 -> "nd";
			case 3, 23 -> "rd";
			default -> "th";
		};
	}

	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}

	public static int getDays(int month, int year)
	{
		return month == 2 && isLeapYear(year) ? 29 : daysOfMonths[month];
	}

	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*--------------------------------------------------------
	FILE NAME	: ArrayUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 24th December 2023

	Utility class for array operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.array;

import java.util.Random;

public class ArrayUtil {
    public static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    public static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    public static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    public static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void fillRandomArray(Random random, int [] a, int origin, int bound)
    {
        fillRandomArray(random, a, a.length, origin, bound);
    }

    public static void fillRandomArray(Random random, int [] a, int count, int origin, int bound)
    {
        for (int i = 0; i < count; ++i)
            a[i] = random.nextInt(origin, bound);
    }

    public static int [] generateRandomArray(Random random, int count, int origin, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, origin, bound);

        return a;
    }

    public static int [] histogramData(int [] a, int n)
    {
        int [] result = new int[n + 1];

        for (int i = 0; i < a.length; ++i)
            ++result[a[i]];

        return result;
    }

    public static boolean isEmpty(int [] a)
    {
        return a.length == 0;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 0; i < a.length; ++i)
            result = Math.max(a[i], result);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 0; i < a.length; ++i)
            result = Math.min(a[i], result);

        return result;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        print(n, a, a.length);
    }

    public static void print(int [] a, int count)
    {
        print(1, a, count);
    }

    public static void print(int n, int [] a, int count)
    {
        print(n, a, count, " ", "\n");
    }

    public static void print(int [] a, int count, String sep, String end)
    {
        print(1, a, count, sep, end);
    }

    public static void print(int n, int [] a, int count, String sep, String end)
    {
        String fmt = String.format("%%0%dd%%s", n);

        for (int i = 0; i < count; ++i)
            System.out.printf(fmt, a[i], sep);

        System.out.print(end);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static int [] reversed(int [] a)
    {
        int [] result = new int[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static char [] reversed(char [] a)
    {
        char [] result = new char[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean desc)
    {
        if (desc)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i];

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyimi (enhanced for loop): for-each döngü deyimi dolaşılabilir (iterable) türlerde kullanılabilir.
	Diziler de dolaşılabilir türlerdir. İleri de başka dolaşılabilir sınıflar da göreceğiz. for-each döngü deyimi Java 5
	ile dile eklenmiştir. Bir sınıfın dolaşılabilir olarak bildirilmesi Java ile Uygulama Geliştirme 1 kursunda ele
	alınacaktır. for-each döngü deyiminin genel biçimi şu şekildedir:

		for (<tür> <değişken> : <dolaşılabilir tür referansı>)
			<deyim>

	Burada döngünün her adımında döngü değişkenine bir değer atanır. Örneğin bir dizi dolaşılırken her adımda dizinin
	o konumdaki elemanı döngü değişkenine atanmış olur. Yani dizi baştan sona dolaşılmış olur. for-each döngü deyimi bir
	dizi için genel olarak indeks gerekmedikçe kullanılmalıdır. Yani for-each döngü deyimi okunabilirliği bozmadıktan
	sonra kesinlikle kullanılmalıdır. for-each döngü deyiminin döngü değişekeni döngü boyunca görülebilirdir. Yani
	döngüden önce ya da	sonra kullanılamaz

	Aslında dolaşılabilir türler için for-each döngü deyimini uygun durumda kullanmak, klasik for döngü deyimi ile
	dolaşılabilir bir tür için yazılan kodların okunabilirliğini/algılanabilirliğini artırır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte kullanılan for-each döngü deyiminin yaklaşık karşılığı şu şekildedir:

	{
		int val;

		for (int i = 0; i < a.length; ++i) {
			val = a[i];
			System.out.printf("%d ", val);
		}
	}
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a = {1, 2, 3, 4};

		for (int val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	30.12.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte klasik for döngü deyimi daha okunabilir/algılanabilirdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

		for (int i = 0; i < a.length / 2; ++i)
			System.out.printf("%d ", a[i]);

		System.out.println();

		int i = 0;

		for (int val : a) {
			if (i++ == a.length / 2)
				break;

			System.out.printf("%d ", val);
		}

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte klasik for döngü deyimi daha okunabilir/algılabilirdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

		for (int i = a.length - 1; i >= 0; --i)
			System.out.printf("%d ", a[i]);

		System.out.println();

		int i = a.length - 1;

		for (int val : a)
			System.out.printf("%d ", a[i--]);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde döngü değişkenine atama işlemi implicit olarak yapılır. Aşağıdaki örnek int türünden long
	türüne implicit conversion tanımlı olduğundan geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

		for (long val : a)
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte int türünden short türüne implicit conversion geçersiz olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

		for (short val : a) //error
			System.out.printf("%d ", val);

		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for-each döngü deyiminde :'den sonrakı kısım bir kez yapılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		for (int val : Sample.getArray())
			System.out.printf("%d ", val);

		System.out.println();
	}
}

class Sample {
	public static int [] getArray()
	{
		System.out.println("getArray");

		return new int[]{1, 2, 3, 4, 5};
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	T[] türü için T her bir elemanın türü olduğuna göre T yerine bir dizi referansı yazıldığında dizinin her bir elemanı
	yine dizi referansı olur. Yani aslında dizimiz yine bir referans dizisidir. Bu dizilere dizi dizisi de denilmektedir.
	Bu anlamda Java'da teknik olarak çok boyutlu dizi kavramı yoktur. Çok boyutlu dizi kullanılarak gerçekleştirilen
	algoritmalar da yine dizi dizileri ile yazılır. Bir dizi dizisinin her bir elemanı olan dizi referanslarının hepsi
	aynı uzunlukta dizileri gösteriyorsa, bu durumda bu dizi dizisi bir matrisi temsil edebilir. Yani mantıksal olarak
	iki boyutlu bir dizidir ancak teknik olarak bir dizi dizisidir. Bir dizi yaratılırken dizinin türüne ilişkin kaç tane
	[] varsa, new operatöründe o kadar sayıda [] bulunmalıdır. new operatörü ile kullanılan []'lerden en soldakinin
	içerisi ilkdeğer verme sentaksı dışında boş bırakılamaz. Diğerleri boş bırakılabilir. Diğerleri boş bırakıldığında
	ana dizi yaratılmış olur ancak diğer diziler yaratılmaz ve her bir referansa null değer verilir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		int[][] a;
		int [][][] b;
		int [][][][] c;

		a = new int[10][];
		b = new int[4][][];
		c = new int[4][][][];
		//...

	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte bir matris temsil edilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Satır ve sütun sayılarını giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();

		int [][] a = new int[m][];

		for (int i = 0; i < m; ++i)
			a[i] = new int[n];

		for (int i = 0; i < m; ++i)
			for (int j = 0; j < n; ++j)
				a[i][j] = i + j;

		for (int [] array : a) {
			for (int val : array)
				System.out.printf("%02d ", val);

			System.out.println();
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte dizi dizi yaratılırken diğer []'in içerisinde uzunluk yazıldığında diziler otomatik olarak
	yaratılır. Yukarıdaki örnek aşağıdaki gibi daha da basitleştirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Satır ve sütun sayılarını giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();

		int [][] a = new int[m][n];

		for (int i = 0; i < m; ++i)
			for (int j = 0; j < n; ++j)
				a[i][j] = i + j;

		for (int [] array : a) {
			for (int val : array)
				System.out.printf("%02d ", val);

			System.out.println();
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dizi dizilerine ilk değer verilirken de küme parantezi kullanılır. Her bir diziye ilk değer verirken de yine
	küme parantezi yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.array.ArrayUtil;

class App {
	public static void main(String[] args)
	{
		int [][] a = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
		int [][] b = {{1, 2, 3}, {4, 5, 6}, {7, 8}, {9, 10, 11, 12}};

		ArrayUtil.print(2, a);
		System.out.println("----------------------");
		ArrayUtil.print(2, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	MatrixUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import static org.csystem.util.matrix.MatrixUtil.isMatrix;

public class MatrixUtilIsMatrixTest {
    public static void run()
    {
        int [][] a = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
        int [][] b = {{1, 2, 3}, {4, 5, 6}, {7, 8}, {9, 10, 11, 12}};

        System.out.println(isMatrix(a) ? "Matris" : "Matris değil");
        System.out.println(isMatrix(b) ? "Matris" : "Matris değil");
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.util.matrix.test;

import static org.csystem.util.matrix.MatrixUtil.isSquareMatrix;

public class MatrixUtilIsSquareMatrixTest {
    public static void run()
    {
        int [][] a = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int [][] b = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
        int [][] c = {{1, 2, 3}, {4, 5, 6}, {7, 8}, {9, 10, 11, 12}};

        System.out.println(isSquareMatrix(a) ? "Kare matris" : "Kare matris değil");
        System.out.println(isSquareMatrix(b) ? "Kare matris" : "Kare matris değil");
        System.out.println(isSquareMatrix(c) ? "Kare matris" : "Kare matris değil");
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.util.matrix.test;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.matrix.MatrixUtil;

import java.util.Random;
import java.util.Scanner;

public class MatrixUtilGenerateRandomMatrixTest {
    public static void run()
    {
        Random random = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            int [][] m = MatrixUtil.generateRandomMatrix(random, random.nextInt(3, 5), random.nextInt(3, 5), 0, 100);

            ArrayUtil.print(2, m);
            System.out.println("-----------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}


package org.csystem.util.matrix.test;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.matrix.MatrixUtil;

import java.util.Random;
import java.util.Scanner;

public class MatrixUtilGenerateRandomSquareMatrixTest {
    public static void run()
    {
        Random random = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            int [][] m = MatrixUtil.generateRandomSquareMatrix(random, random.nextInt(3, 5), 0, 100);

            ArrayUtil.print(2, m);
            System.out.println("-----------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir kare matrisin esas köşegeni (diagonal) üzerindeki elemanların
	toplamına geri dönen sumDiagonal isimli metodu MatrixUtil sınıfı içerisinde yazınız ve test ediniz
	Açıklamalar:
		- Metot aldığı dizi dizisinin matris ve kare matris olup olmadığını kontrol etmeyecektir
		- Esas köşegen üzerindeki elemanlar
			1 2 3
			4 5 6
			7 8 9
		matrisi için 1, 5 ve 9 elemanlarıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.matrix.MatrixUtil;

import java.util.Random;
import java.util.Scanner;

public class MatrixUtilSumDiagonalTest {
    public static void run()
    {
        Random random = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            int [][] m = MatrixUtil.generateRandomSquareMatrix(random, random.nextInt(3, 5), 0, 100);

            ArrayUtil.print(2, m);
            System.out.printf("Total:%d%n", MatrixUtil.sumDiagonal(m));
            System.out.println("-----------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden bir kare matrisin devriğine (transpose) geri dönen transopose
	isimli metodu MatrixUtil sınıfı içerisinde yazınız ve test ediniz
	Açıklamalar:
		- Metot aldığı dizi dizisinin matris olup olmadığını kontrol etmeyecektir
		- Bir matrisin devriği satırlarının sütun, sütunlarının satır yapıldığı matristir. Örneğin:
			1 2 3
			4 5 6
		matrisinin devriği

			1 4
			2 5
			3 6

		matrisidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.matrix.test;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.matrix.MatrixUtil;

import java.util.Random;
import java.util.Scanner;

public class MatrixUtilTransposeTest {
    public static void run()
    {
        Random random = new Random();
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            System.out.println("#########################################");
            int [][] m = MatrixUtil.generateRandomMatrix(random, random.nextInt(3, 5), random.nextInt(3, 5), 0, 100);

            ArrayUtil.print(2, m);
            System.out.println("Devriği:");
            ArrayUtil.print(2, MatrixUtil.transpose(m));
            System.out.println("#########################################");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
  	31.12.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Fizik sınavı şubeler arasında ortak olarak yapılıyor olsun. Ders notları da [0, 100]
	aralığında tamsayılar biçiminde belirlensin. Aşağıdaki açıklamalara göre, ilgili basit simülasyon programını yazınız.
	Açıklamalar:
		- Şube sayısı ve her bir şubedeki öğrenci sayısı klavyeden girilecektir

		- Alınan notlar rasgele olarak belirlenecektir

		- Bu işlemlerden sonra her bir şubenin ayrı ayrı not ortalamasını, okulun bu sınav için not ortalamasını, her bir
		şubenin en düşük ve en yüksek notunu ve okulun bu sınav için en düşük ve en yüksek notunu hesaplayınız

		- Çıktıları dilediğiniz gibi yapabilirsiniz

		- Mümkün olduğunca (şu ana kadar gördüklerimizle) nesne yönelimli olarak düşününüz
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.simulation.exam;

public class ExamSimulationApp {
    public static void run()
    {
        ExamSimulation examSimulation = new ExamSimulation("Fizik");

        examSimulation.run();
        examSimulation.printReport();
    }

    public static void main(String[] args)
    {
        run();
    }
}


package org.csystem.app.simulation.exam;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    public String lectureName;
    public int [][] grades;
    public double [] averages;
    public int [] maxGrades;
    public int [] minGrades;
    public double average;
    public int maxGrade;
    public int minGrade;

    public int calculateAndGetSumGrades(int i)
    {
        maxGrades[i] = 0;
        minGrades[i] = 100;
        int sumGrades = 0;

        for (int k = 0; k < grades[i].length; ++k) {
            maxGrades[i] = Math.max(maxGrades[i], grades[i][k]);
            minGrades[i] = Math.min(minGrades[i], grades[i][k]);
            maxGrade = Math.max(maxGrades[i], maxGrade);
            minGrade = Math.min(minGrades[i], minGrade);
            sumGrades += grades[i][k];
        }

        return sumGrades;
    }

    public void fillGrades()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Şube sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        grades = new int[n][];
        averages = new double[n];
        maxGrades = new int[n];
        minGrades = new int[n];

        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şube öğrenci sayısını giriniz:", i + 1);
            grades[i] = ArrayUtil.generateRandomArray(r, Integer.parseInt(kb.nextLine()), 0, 101);
        }
    }

    public void doSimulation()
    {
        int totalGrades = 0;
        int nStudents = 0;
        maxGrade = 0;
        minGrade = 100;

        for (int i = 0; i < grades.length; ++i) {
            nStudents += grades[i].length;
            int sumGrades = calculateAndGetSumGrades(i);

            averages[i] = (double) sumGrades / grades[i].length;
            totalGrades += sumGrades;
        }

        average = (double) totalGrades / nStudents;
    }

    public ExamSimulation(String name)
    {
        lectureName = name;
    }

    public void run()
    {
        fillGrades();
        doSimulation();
    }

    public void printReport()
    {
        System.out.println("#################################################################");
        printGrades();
        for (int i = 0; i < averages.length; ++i)
            System.out.printf("%d.şube:Ortalama:%f, En yüksek not:%d, En düşük not:%d%n", i + 1, averages[i],
                    maxGrades[i], minGrades[i]);
        System.out.printf("Okul Ortalaması:%f%n", average);
        System.out.printf("En yüksek not:%d%n", maxGrade);
        System.out.printf("En düşük not:%d%n", minGrade);
        System.out.println("#################################################################");
    }

    public void printGrades()
    {
        System.out.println("-----------------------------------------------------------------");

        System.out.printf("%s dersi notları:%n", lectureName);
        for (int i = 0; i < grades.length; ++i) {
            System.out.printf("%d.şube:", i + 1);
            ArrayUtil.print(grades[i]);
        }

        System.out.println("-----------------------------------------------------------------");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	String sınıfının split metodu yazıyı verilen ayraçlara göre ayırarak bir String dizisi referansına geri döner. Ancak
	split metodu aldığı ayraçlar için regular expression (regex) kullanır. Regex oldukça detaylı bir konudur. Bu sebeple
	burada split için en çok kullanılan regex kalıpları (pattern) ele alınacaktır. Burada anlatılanlar dışında gereken
	pattern'ler için regex bilinmesi gerekir. Regex konusu Java ile Uygulama Geliştirme kurslarında ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	split metodunda genel olarak ayraçlar [ ile ] arasında yazılır. Bu işlem aslında veya anlamına gelir. Yani burada
	yazılan karakterlerin en az bir tanesi görüldüğünde ayraç kabul edilir. Ancak bu kalıpta ayraçlar yanyana geldiğinde
	aralarındaki boş string'ler de diziye dahil edilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		String str = "Bugün hava çok güzel. Bu güzel havada denize girilir mi?";
		String [] words = str.split("[ .]");

		for (String word : words)
			System.out.println(word);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Ayraçların yanyana gelmesi durumunda da ayraç kabul edilmesi için yani boş string'in diziye dahil edilmemesi için
	aşağıdaki kalıp kullanılabilir. Demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		String str = "Bugün hava çok güzel. Bu güzel havada denize girilir mi?";
		String [] words = str.split("[. ]+");

		for (String word : words)
			System.out.println(word);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	[ ve ] karakterleri ayraç olarak ters bölü ile yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		String str = "Bugün [hava] çok güzel. Bu güzel havada denize girilir mi?";
		String [] words = str.split("[\\[\\]. ]+");

		for (String word : words)
			System.out.println(word);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Elemanlarının Erişim Belirleyicileri: Anımsanacağı gibi sınıf elemanları (member) şu erişim belirleyicilerden
	bir tanesini alırlar: public, no-modifier, protected, private.

	Burada no-modifier hiç bir erişim belirleyici yazılmaması anlamındadır. Java'da hiç bir erişim belirleyicisi
	yazılmamasının da diğerlerinden farklı bir anlamı vardır. Burada öncelikle bu erişim belirleyicilerin sentaks ve
	semantik kuralları ele alınacak, sonrasında NYPT'de kullanımı anlatılacaktır

	Aslında bir sınıf erişim belirleyiciler anlamında 4 tane bölümden oluşur. Bir eleman hangi erişim belirleyici ile
	bildirilmişse o bölüme eklenmiş olur. public ve private bölümün anlamı aynı paketteki sınıflar (friendly classes)
	veya farklı paketlerdeki sınıflar için değişmemektedir. Yani private bölüme erişim aynı paketteki veya farklı
	paketlerdeki sınıflar için değişiklik göstermez. Benzer şekilde public bölüme erişim aynı paketteki veya farklı
	paketlerdeki sınıflar için değişiklik göstermez. Ancak no-modifier ve protected bölümleri aynı paketteki sınıfların
	ve farklı paketlerdeki sınıfların erişimi değişiklik gösterir.

	Erişim belirleyiciler, sınıf dışından erişimde geçerlidir. Sınıf içerisinde her bölüme erişilebilir.

	Sentaks açısından bölümlere ilişkin elemanlar karışık sırada yazılabilir ancak şüphesiz belli bir düzende yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın public bölümüne aynı paketteki diğer sınıflardan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B {
	public void bar()
	{
		A a;

		a = new A();

		a.foo();
		a.x = 10;
	}
}


class A {
	public int x;
	public A()
	{
		//...
	}

	public void foo()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	Sınıfın public bölümüne farklı paketteki diğer sınıflardan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package x;

public class A {
	public int x;
	public A()
	{
		//...
	}

	public void foo()
	{
		//...
	}
}

package y;

import x.A;

class B {
	public void bar()
	{
		A a;

		a = new A();

		a.foo();
		a.x = 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın private bölümüne aynı paketteki diğer sınıflardan erişilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B {
	public void bar()
	{
		A a;

		a = new A(); //error
		a.foo(); //error
		a.x = 10; //error
	}
}


class A {
	private int x;
	private A()
	{
		//...
	}

	private void foo()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın private bölümüne farklı paketteki diğer sınıflardan erişilemez
----------------------------------------------------------------------------------------------------------------------*/
package x;

public class A {
	private int x;
	private A()
	{
		//...
	}

	private void foo()
	{
		//...
	}
}


package y;

import x.A;

class B {
	public void bar()
	{
		A a;

		a = new A(); //error
		a.foo(); //error
		a.x = 10; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public anlamındadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{

	}
}

class B {
	public void bar()
	{
		A a;

		a = new A();
		a.foo();
		a.x = 10;
	}
}


class A {
	int x;
	A()
	{
		//...
	}

	void foo()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın no-modifier bölümü farklı paketteki diğer sınıflar için private anlamındadır
----------------------------------------------------------------------------------------------------------------------*/
package x;

public class A {
	int x;
	A()
	{
		//...
	}

	void foo()
	{
		//...
	}
}

package y;

import x.A;

class B {
	public void bar()
	{
		A a;

		a = new A(); //error
		a.foo(); //error
		a.x = 10; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın protected bölümü aynı paketteki diğer sınıflar için public anlamındadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class B {
	public void bar()
	{
		A a;

		a = new A();
		a.foo();
		a.x = 10;
	}
}


class A {
	protected int x;
	protected A()
	{
		//...
	}

	protected void foo()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın protected bölümü farklı paketteki diğer sınıflar için türetme/kalıtım (inheritance) söz konusu değilse
	private anlamındadadır. Türemiş sınıf (derived class) kendisine ait olan protected bölüme erişebilir.  protected
	bölümün anlamı ve türemiş sınıf kavramı inheritance konusunda ayrıca ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/
package x;

public class A {
	protected int x;
	protected A()
	{
		//...
	}

	protected void foo()
	{
		//...
	}
}


package y;

import x.A;

class B {
	public void bar()
	{
		A a;

		a = new A(); //error
		a.foo(); //error
		a.x = 10; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
  	Sınıf içerisinde her bölüme erişilebillir
----------------------------------------------------------------------------------------------------------------------*/
package x;

public class A {
	private int x;
	private A()
	{
		//...
	}

	private void foo(int y)
	{
		x = y;
		A a = new A();

		a.foo(20);
	}
}



/*----------------------------------------------------------------------------------------------------------------------
  	Erişim Belirleyici      Aynı sınıf       Friendly sınıf      Farklı paketteki sınıf      Türemiş sınıf
  	public                      T                   T                       T                       T
  	protected                   T                   T                       F                       T
  	no-modifier                 T                   T                       F                       F
  	private                     T                   F                       F                       F
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
  	06.01.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	NYPT'de özellikle veri elemanlarının gizlenmesine encapsulation denilmektedir. Bu anlamda bu kavrama veri/bilgi
	gizleme (data/information hiding) de denilmektedir. Bu kavram aslında gerçek hayattan programlamaya aktarılmıştır.
	Örneğin, televizyon izleyen bir kişi televizyonun kumandası ile nasıl haberleştiğini bilmek zorunda değildir. Yani
	bunu bilmesi ya da bilmeemsi izlemesini etkilemez. Bu durumda aslında bu kısım televizyonu izleyenden gizlenmiştir.
	Çünkü gerek yoktur. Ancak televiyonu üreten açısından bunun bilinmesi gerekir.

	Bir sınıf için iki bakış açısı söz konusudur: Sınıfı yazan bakış açısı, sınıfı kullanan bakış açısı.
	Sınıfı yazan, sınıfa ilişkin tüm detayları ve sınıfı kullanan bakış açısını da bilmelidir. Sınıfı kullanan ise
	içsel detayları bilmek zorunda değildir. Bu anlamda sınıfı yazana hizmet veren anlamında "server codes", kullanana
	ise hizmet alan anlamında "client codes" da denilmektedir. Aslında bu kavramlar geneldir. Sınıfların elemanlarının
	gizlenmesi ile NYPT'de kullanılmaktadır.

	Bir sınıfın veri elemanı gizlendiğinde, dışarıdan değerinin değiştirilmesi ve/veya değerinin elde edilmesi gerekebilir.
	Bunun için veri elemanına erişen public metotların yazılması gerekir. Gizlenmiş bir veri elemanının değerini değiştirmek
	için yazılan public metoda set metodu (setter/mutator) denir ve bir convention olarak (genelde) set öneki ile başlatılır.
	Gizlenmiş bir veri elemanının değerini elde etmek için yazılan public metoda get metodu (getter/accessor) denir ve
	bir convention olarak (genelde) get öneki ile başlatılır. Veri elemanı boolean türdense tipik olarak getter, is ile
	başlatılır. Gizlenenen bir eleman için mutator ve accessor metotlarının yazılıp yazılmayacağı sınıfa yani domain'e
	bağlıdır. Bazı veri elemanları için hiç biri yazılmayabilirken, bazı veri elemanları için bir tanesi, bazı veri
	elemanları için ise ikisi de yazılabilir.

	Bir sınıfın public ve protected bölümleri dökumante edilir. private ve no-modifier bölümleri dökumante edilmez.

	Bir sınıfın bir elemanının erişim belirleyicisi (yani aslında sınıfın bölümleri) diğer sınıflar için anlamldır. Sınıf
	içerisinden erişimde elemanın hengi bölümde olduğunun önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Değişken isimlendirmede bazı teknikler kullanılabilmektedir. Bu teknikler dışında da isimlendirme
	yapılabilir. Burada anlatılanlar çok kullanılan ve bilinen tekniklerden bazılardır:
	1. Unix stili (snake case): Bu isimlendirmede karakterlerin tamamı küçük harf ile yazılır ve birden fazla kelimeden
	oluşuyorsa aralarına alttire karakteri yerleştirilir. Örneğin:
		number_of_devices usb_port
	Bu isimlendirme Java'da doğrudan tercih edilmez.

	2. Camel case (lower camel case): Bu isimlendirmede kelimeler bitişik olarak yazılır. İlk kelimenin baş harfi küçük
	diğer kelimelerin baş harfleri büyük olarak, geri kalan tüm karakterler küçük harf olacak şekilde yazılır. Örneğin:
		numberOfDevices usbPort parseInt, nextInt, changeCase
	Bu isimlendirme genel olarak Java'da metot isimleri, yerel değişken isimleri ve parametre değişken isimlerinde
	tercih edilir.

	3. Pascal case (upper camel case): Bu isimlendirmede kelimeler bitişik olarak yazılır. Tüm kelimelerin baş harfleri
	büyük, geri kalan tüm karakterler küçük harf olacak şekilde yazılır. Örneğin:
		Random, String, System, StringUtil, DataBindingUtil, TimeUnit
	Bu isimlendirme Java'da genel olarak UDT'lerde tercih edilir.

	İsimlendirmede bunlardan biri ya da birden fazlası kullanılabilir. Kullanılmak zorunda da değildir. Örneğin Java'da
	paket isimlerinin tamamı küçük harf olacak şekilde isimlendirme yapılır ve kelimeler bitişik olarak yazılır. Örneğin
	    java.util, org.csystem.util.math, com.springframework
    Burada anlatılan teknikler tamamen geneldir ve bunlara isimler verilmiştir. Hatta bazen bir ya da birden fazla
	teknik biraz değiştirilerek de kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Bazı programcılar sınıfın özellikle private veri elemanlarının isimlendirilmesinde bazı önekler
    kullanabilmektedirler. Örneğin, "m_", "m", "d_" gibi önekler tercih edilebilmektedir. Bazı programcılar hiç bir ek
    koymamayı yani lowerCamelCase yapmayı tercih ederler. Bu tür yaklaşımların iyisi ya da kötüsü yoktur. Geliştirici
    ekip tarafından belirlenen kullanılır. Yani bir "convention" biçiminde kullanılır. Biz convention olarak, sınıfın
    non-static ve private olarak bildirilmiş veri elemanlarını "m_" öneki ile başlatacağız. Eğer private veri elemanı
    aynı zamanda static ise özel bazı durumlar dışında "ms_" ile başlatacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo Date sınıfını inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Date d = new Date(11, 7, 1983);

		System.out.printf("%02d/%02d/%04d%n", d.getDay(), d.getMonth(), d.getYear());
		d.setDay(6);
		d.setMonth(9);
		d.setYear(2021);
		System.out.printf("%02d/%02d/%04d%n", d.getDay(), d.getMonth(), d.getYear());
	}
}

class Date {
	private int m_day, m_month, m_year;
	private int m_dayOfWeek;

	//...

	public Date(int day, int month, int year)
	{
		//...
		m_day = day;
		m_month = month;
		m_year = year;
		//...
	}

	public void setDay(int day)
	{
		//...
		m_day = day;
		//...
	}

	public int getDay()
	{
		return m_day;
	}

	public void setMonth(int month)
	{
		//...
		m_month = month;
		//...
	}

	public int getMonth()
	{
		return m_month;
	}

	public void setYear(int year)
	{
		//...
		m_year = year;
		//...
	}

	public int getYear()
	{
		return m_year;
	}

	public int getDayOfWeek()
	{
		return m_dayOfWeek;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durumlardan en az bir tanesi varsa ilgili veri elemanı gizlenir:
	- Sınıfların versiyonları ilerledikçe veri elemanlarının isimlerinin hatta türlerinin değiştirilmesi ile çok sık
	karşılaşılır. Bu durumda eski kodların yeni değişikliklerden etkilenmemesi için ilgili veri elemanları gizlenir.

	- Bir veri elemanının sınır değerleri olabilir. Bu durumda sınırlar dışında değer verilmemesi için veri elemanı
	gizlenir.

	- Bir veri elemanının değerinin, başka bir veri elemanının (ya da elemanlarının) değerinin değiştirilmesiyle hesaplanması
	gerekebilir. Bu durumda yine veri elemanı gizlenir.

	- Bir veri elemanı değiştiğinde değişen değere göre bir işlem yapılması gerekebilir. Örneğin, bir veritabanı bağlantısına
	yönelik bir bilginin değişmesi durumunda eski bağlantının kopartılıp yeni bağlantının sağlanması gerekebilir. Bu durumda
	ilgili veri elemanı gizlenir.

	- Bazı durumlarda veri elemanı yukarıdaki durumlardan biri bile olmasa da gizlenebilir. Örneğin, sınıfın bir elemanı
	dışında kalan diğer veri elemanlarının gizlenmesi gerekbilir. Bütünlüğün bozulmaması için gizlenmesi gerekmeyen bir
	veri elemanı da gizlenebilir. Bu durumda ilgili veri elemanı için accessor ve mutator metotlar yazılır. Şüphesiz bu
	bir örnektir ve domain'e bağlı olarak değişiklik gösterebilir.

	Anahtar Notlar: Buradaki ilk 4 maddeden en az birisi varsa programcı hiç düşünmeden veri elemanını gizler. Ancak son
	durum biraz domain'e bağlıdır.

	Yukarıda durumlarla karşılaşılmaması durumunda (%3 ile %5 arası karşılaşılmaz) ilgili veri elemanı public yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte Date sınıfının kodları değişmesine rağmen, değişiklik yapılmadan önce yazılmış client code'ların
	değiştirilmesi gerekmediğine dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Date d = new Date(11, 7, 1983);

		System.out.printf("%02d/%02d/%04d%n", d.getDay(), d.getMonth(), d.getYear());
		d.setDay(6);
		d.setMonth(9);
		d.setYear(2021);
		System.out.printf("%02d/%02d/%04d%n", d.getDay(), d.getMonth(), d.getYear());
	}
}

class Date {
	private String m_date;
	private int m_dayOfWeek;

	//...

	public Date(int day, int month, int year)
	{
		//06/09/2021
		//...
		m_date = String.format("%02d/%02d/%04d", day, month, year);
		//...
	}

	public void setDay(int day)
	{
		//...
		m_date = String.format("%02d/%02d/%04d", day, getMonth(), getYear());
		//...
	}

	public int getDay()
	{
		return Integer.parseInt(m_date.substring(0, 2));
	}

	public void setMonth(int month)
	{
		//...
		m_date = String.format("%02d/%02d/%04d", getDay(), month, getYear());
		//...
	}

	public int getMonth()
	{
		return Integer.parseInt(m_date.substring(3, 5));
	}

	public void setYear(int year)
	{
		//...
		m_date = String.format("%02d/%02d/%04d", getDay(), getMonth(), year);
		//...
	}

	public int getYear()
	{
		return Integer.parseInt(m_date.substring(6));
	}

	public int getDayOfWeek()
	{
		return m_dayOfWeek;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazı durumlarda sınıfın public bölümünde de değişiklik yapılması gerekebilir. Bu durumda değişikliği değişikliği
	doğrudan yapmak yerine, eskisi korunup deprecated yapılabilir. Şüphesiz bu durum yine domain'e bağlıdır. Örneğin
	Date sınıfımızda getMonth metodu (bir sebepten) getMonthValue olarak değiştirilmek istenebilir. Bu durumda getMonth
	metodu da deprecated yapılıp korunur ve getMonthValue eklenir. Bu durum şüphesiz sınıf dökumanlarında belirtilir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  	Bazı metotların sınıf dışından çağrılması istenmez. Sınıf içerisinde çağrılması için yazılır. Bu durumda metot gizlenir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
  	Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math.geometry.test;

import org.csystem.math.geometry.Circle;

import java.util.Random;
import java.util.Scanner;

public class CircleCtorTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);

            System.out.println("--------------------------------------------------");
            System.out.printf("Generated radius:%f%n", radius);
            Circle c = new Circle(radius);
            System.out.printf("Circle:%s%n", c.toString());
            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.math.geometry.test;

import org.csystem.math.geometry.Circle;

import java.util.Random;
import java.util.Scanner;

public class CircleSetterTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();
        Circle c = new Circle();
        System.out.printf("Circle:%s%n", c.toString());

        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);

            System.out.println("--------------------------------------------------");
            System.out.printf("Generated radius:%f%n", radius);
            c.setRadius(radius);
            System.out.printf("Circle:%s%n", c.toString());
            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*--------------------------------------------------------
	FILE NAME	: Circle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 6th January 2024

	Circle class that represents a circle

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    private double m_radius;
    private double m_area;
    private double m_circumference;

    private void calculateArea()
    {
        m_area = Math.PI * m_radius * m_radius;
    }

    private void calculateCircumference()
    {
        m_circumference = 2 * Math.PI * m_radius;
    }

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
        calculateArea();
        calculateCircumference();
    }

    public double getRadius()
    {
        return m_radius;
    }

    public double getArea()
    {
        return m_area;
    }

    public double getCircumference()
    {
        return m_circumference;
    }

    public String toString()
    {
        return String.format("Radius:%f, Area:%f, Circumference:%f", m_radius, m_area, m_circumference);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
  	Bazen bir get metodu bir veri elemanına karşılık gelmeyebilir. Yani örneğin get metodunda değer çağrıldığında
  	hesaplanabilir. Sınıfı kullanan açısından bu yine bir accessor metottur. Değeri hesaplandıktan sonra sınıf içerisinde
  	kullanılmayan değerler veri elemanı olarak tutulmayabilir. Şüphesiz bu da yine sınıfın domain'ine bağlıdır
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: Circle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 6th January 2024

	Circle class that represents a circle

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    private double m_radius;

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
    }

    public double getRadius()
    {
        return m_radius;
    }

    public double getArea()
    {
        return Math.PI * m_radius * m_radius;
    }

    public double getCircumference()
    {
        return 2 * Math.PI * m_radius;
    }

    public String toString()
    {
        return String.format("Radius:%f, Area:%f, Circumference:%f", m_radius, getArea(), getCircumference());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir okulda Fizik sınavı şubeler arasında ortak olarak yapılıyor olsun. Ders notları da [0, 100]
	aralığında tamsayılar biçiminde belirlensin. Aşağıdaki açıklamalara göre, ilgili basit simülasyon programını yazınız.
	Açıklamalar:
		- Şube sayısı ve her bir şubedeki öğrenci sayısı klavyeden girilecektir

		- Alınan notlar rasgele olarak belirlenecektir

		- Bu işlemlerden sonra her bir şubenin ayrı ayrı not ortalamasını, okulun bu sınav için not ortalamasını, her bir
		şubenin en düşük ve en yüksek notunu ve okulun bu sınav için en düşük ve en yüksek notunu hesaplayınız

		- Çıktıları dilediğiniz gibi yapabilirsiniz

		- Mümkün olduğunca (şu ana kadar gördüklerimizle) nesne yönelimli olarak düşününüz
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.simulation.exam;

public class ExamSimulationApp {
    public static void run()
    {
        ExamSimulation examSimulation = new ExamSimulation("Fizik");

        examSimulation.run();
        examSimulation.printReport();
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.simulation.exam;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    private String m_lectureName;
    private int [][] m_grades;
    private double [] m_averages;
    private int [] m_maxGrades;
    private int [] m_minGrades;
    private double m_average;
    private int m_maxGrade;
    private int m_minGrade;

    private int calculateAndGetSumGrades(int i)
    {
        m_maxGrades[i] = 0;
        m_minGrades[i] = 100;
        int sumGrades = 0;

        for (int k = 0; k < m_grades[i].length; ++k) {
            m_maxGrades[i] = Math.max(m_maxGrades[i], m_grades[i][k]);
            m_minGrades[i] = Math.min(m_minGrades[i], m_grades[i][k]);
            m_maxGrade = Math.max(m_maxGrades[i], m_maxGrade);
            m_minGrade = Math.min(m_minGrades[i], m_minGrade);
            sumGrades += m_grades[i][k];
        }

        return sumGrades;
    }

    private void fillGrades()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Şube sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        m_grades = new int[n][];
        m_averages = new double[n];
        m_maxGrades = new int[n];
        m_minGrades = new int[n];

        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d.şube öğrenci sayısını giriniz:", i + 1);
            m_grades[i] = ArrayUtil.generateRandomArray(r, Integer.parseInt(kb.nextLine()), 0, 101);
        }
    }

    private void doSimulation()
    {
        int totalGrades = 0;
        int nStudents = 0;
        m_maxGrade = 0;
        m_minGrade = 100;

        for (int i = 0; i < m_grades.length; ++i) {
            nStudents += m_grades[i].length;
            int sumGrades = calculateAndGetSumGrades(i);

            m_averages[i] = (double) sumGrades / m_grades[i].length;
            totalGrades += sumGrades;
        }

        m_average = (double) totalGrades / nStudents;
    }

    public ExamSimulation(String name)
    {
        m_lectureName = name;
    }

    public String getLectureName()
    {
        return m_lectureName;
    }

    public void setLectureName(String lectureName)
    {
        m_lectureName = lectureName;
    }

    public int getGrade(int i, int k)
    {
        return m_grades[i][k];
    }

    public double getAverage(int i)
    {
        return m_averages[i];
    }

    public double getAverage()
    {
        return m_average;
    }

    public int getMaxGrade(int i)
    {
        return m_maxGrades[i];
    }

    public int getMaxGrade()
    {
        return m_maxGrade;
    }

    public int getMinGrade(int i)
    {
        return m_minGrades[i];
    }

    public int getMinGrade()
    {
        return m_minGrade;
    }

    public void run()
    {
        fillGrades();
        doSimulation();
    }

    public void printReport()
    {
        System.out.println("#################################################################");
        printGrades();
        for (int i = 0; i < m_averages.length; ++i)
            System.out.printf("%d.şube:Ortalama:%f, En yüksek not:%d, En düşük not:%d%n", i + 1, m_averages[i],
                    m_maxGrades[i], m_minGrades[i]);
        System.out.printf("Okul Ortalaması:%f%n", m_average);
        System.out.printf("En yüksek not:%d%n", m_maxGrade);
        System.out.printf("En düşük not:%d%n", m_minGrade);
        System.out.println("#################################################################");
    }

    public void printGrades()
    {
        System.out.println("-----------------------------------------------------------------");

        System.out.printf("%s dersi notları:%n", m_lectureName);
        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d.şube:", i + 1);
            ArrayUtil.print(m_grades[i]);
        }

        System.out.println("-----------------------------------------------------------------");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NYPT için bir takım ilkeler (principles) söz konusudur. Bunlar kısaca SOLID kısaltması olarak bilinir:
	Single Responsibility Principle (SRP)
	Open Closed Principle (OCP)
	Liskov Substitution Principle (LSP)
	Interface Segregation Principle (ISP)
	Dependency Inversion Principle (DIP)

	Bu ilkeler birbirlerinden ayrı olarak düşünülmemelidir. Burada yalnızca SRP ele alınacaktır.
	SRP: Bir sınıfın tek bir sorumluluğu olmalıdır. Bu anlamda bir sınıf birbirinden bağımsız işler yapacak şekilde
	tasarlanmamalıdır. Bu anlamda bu ilkenin mottosu şöyle özetlenebilir: Bir sınıfın değiştirilmesi için tek bir
	gerekçe olmalıdır

	Diğer ilkeler ileride ele alınacaktır

	Anahtar Notlar: Aslında bu ilkeler geneldir. NYPT'de de uygulanır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
  	NYPT ilerledikçe bazı programcılar, bir takım problemlere genel çözümler üretme çabasına girmişlerdir. Bu anlamda
  	Gang Of Four (GOF) olarak anılan 4 tane bilim insanı bir grup genel problemi çözümleriyle birlikte kategorize etmişlerdir.
  	Bunlara "design pattern (DP)" denilmektedir. Gof pattern'lerinden sonra da pek çok pattern tasarlanmıştır. Bu kurs
  	ve uygulama kurslarında çeşitli pattern'ler konulara göre ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Singleton: Öyle bir sınıf olsun ki o sınıf türünden program boyunca yalnızca bir tane nesne yaratılabilsin ve
    yaratılmış olan o nesnenin referansı gerektiğinde elde edilebilsin.

    Anahtar Notlar: Singleton pattern'inin bir çok implementasyonu söz konusudur. Zaman içerisinde bunlar ele alınacaktır.

    Anahtar Notlar: Burada Singleton pattern'inin hangi durumlarda kullanıldığı ele alınmayacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Singleton sınıfın lazy implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Singleton s1 = Singleton.getInstance();
		Singleton s2 = Singleton.getInstance();

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
	}
}

class Singleton {
	private static Singleton ms_instance;
	private int m_value;

	private Singleton()
	{
	}

	public static Singleton getInstance()
	{
		if (ms_instance == null)
			ms_instance = new Singleton();

		return ms_instance;
	}

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    07.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Tüm elemanları static olarak bildirilmiş sınıflar türünden nesne yaratmanın bir anlamı yoktur. Çünkü bir nesne ilgili
	sınıfın non-static elemanları ve o elemanları kullanan metotlar ile anlamlıdır. İşte tüm elemanları static olarak
	bildirilmiş bir sınıfın ctor'u bir convention olarak private yapılır. Bu convention JavaSE içerisindeki sınıflarda da
	uygulanmıştır. Örneğin Math ve Arrays sınıflarının tüm elemanları static olarak bildirildiklerinden ctor'ları private
	yapılmıştır. Bu tip sınıflara "utility classes" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.matrix.MatrixUtil;
import org.csystem.util.numeric.NumberUtil;
import org.csystem.util.string.StringUtil;

import java.util.Arrays;

class App {
	public static void main(String[] args)
	{
		Math m = new Math(); //error
		Arrays a = new Arrays(); //error
		ArrayUtil au = new ArrayUtil(); //error
		NumberUtil nu = new NumberUtil(); //error
		MatrixUtil mu = new MatrixUtil(); //error
		StringUtil su = new StringUtil(); //errror

	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Point sınıfının kutupsal koordinat bilgileri ile nesne yaratılabilmesi sağlanmıştır. Kullanımı daha yalın ve okunabilir
    duruma getirmek için ctor gizlenmiş ve factory metotlarla nesne yaratılması sağlanmıştır. Buradaki yaklaşım bir sınıf
    için ctor sayısını azaltmak olarak DÜŞÜNÜLMEMELİDİR. Bu sınıfa yani domain'e özel olarak kullanım basitleştirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math.geometry.test;

import org.csystem.math.geometry.Point;

import java.util.Random;
import java.util.Scanner;

public class PointCartesianTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            double x = random.nextDouble(-100, 100);
            double y = random.nextDouble(-100, 100);

            System.out.println("--------------------------------------------------");

            System.out.printf("Generated coordinates:(%f, %f)%n", x, y);

            Point p = Point.createCartesian(x, y);

            System.out.printf("Point:%s%n", p.toString());

            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.math.geometry.test;

import org.csystem.math.geometry.Point;

import java.util.Random;
import java.util.Scanner;

public class PointPolarTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);
            double theta = random.nextDouble(-2 * Math.PI, 2 * Math.PI);

            System.out.println("--------------------------------------------------");

            System.out.printf("Generated radius:%f%n", radius);
            System.out.printf("Generated theta:%f%n", theta);
            Point p = Point.createPolar(radius, theta);

            System.out.printf("Point:%s%n", p.toString());

            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 7th January 2024

	Point class that represents a 2-dimensional point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.pow;
import static java.lang.Math.sqrt;

public class Point {
	private double m_x, m_y;

	private Point(double a, double b, boolean polar)
	{
		m_x = polar ? a * Math.cos(b) : a;
		m_y = polar ? a * Math.sin(b) : b;
	}

	public static Point createCartesian(double x, double y)
	{
		return new Point(x, y, false);
	}

	public static Point createPolar(double radius, double theta)
	{
		return new Point(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public void setX(double x)
	{
		m_x = x;
	}

	public double getY()
	{
		return m_y;
	}

	public void setY(double y)
	{
		m_y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double a, double b)
	{
		return sqrt(pow(m_x - a, 2) + pow(m_y - b, 2));
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		m_x += dx;
		m_y += dy;
	}

	public String toString()
	{
		return String.format("(%f, %f)", m_x, m_y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	final Anahtar Sözcüğü:
	final Java'da bazı bildirimlerde kullanılan önemli bir anahtar sözcüktür. Bu anlamda final aşağıdaki bildirimlerde
	kullanılır:
		- final değişken bildiirimi
		- final sınıf (ve bazı UDT'ler) bildirimi
	 	- final metot bildirimi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 final değişkenler: Anımsamacağı gibi Java'da 3 çeşit değişken vardır: local variable, parameter variable, member variable.
	 Değişkenler final olarak bildirilebilir. Hatta final anahtar sözcüğü kullanılmasa bile belirli koşullar altında bazı
	 değişkenler final etkisinde olabilmektedir. Bu kavrama "effectively final" denilmektedir. İleride detaylandırılacaktır.

	 Bir değişken final olarak bildirildiğinde o değişkene scope'u boyunca bir kez değer verilebilir. Yani değişkenin
	 değeri bir daha değiştirilemez. Değerinin değiştirilmesi error oluşturur.

	 Anahtar Notlar: Java 8 ile birlikte yerel değişkenlerin ve parametre değişkenlerinin final olarak bildirilmesi
	 gerekliliği neredeyse ortadan kalkmıştır. Bunun sebebi uygulama kurslarında ele alınacaktır. Ancak veri elemanlarının
	 final olarak bildirilmesi oldukça önemlidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	 final bir yerel değişkene değeri ya initialization olarak ya da scope'u içerisinde atama yapılarak bir kez verilebilir.
	 Bir metodun parametre değişkeni de final olabilir. Bu durumda metot içerisinde o değişkenin değeri değiştirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		final int x;
		final int y = 10;

		x = 20;

		++x; //error
		++y; //error
		//...
	}
}

class Sample {
	public static void foo(int a, final int b)
	{
		++a;
		++b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 final veri elemanlarına default değerler verilmez. Yani final bir veri elemanına değer verilmesi artık sınıfı yazan
	 programcının sorumluluğundadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public final int x;
	public static final int y;
}

/*----------------------------------------------------------------------------------------------------------------------
	 Sınıfın non-static ve final bir veri elemanına aşağıdaki 3 yerden yalnızca birinde değer verilebilir:
	 	- Bildirim noktasında
	 	- Tüm ctor'lar içerisinde
	 	- non-static initializer elemanında
	 Sınıfın static ve final olarak bildirilmiş bir veri elemanına aşağıdaki 2 yerden yalnızca birinde değer verilebilir:
	 	- Bildirim noktasında
	 	- static initializer elemanında

	 static ve non-static initializer elemanları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		System.out.println(Sample.y);
		Sample s1 = new Sample();
		Sample s2 = new Sample();

		System.out.println(s1.x);
		System.out.println(s2.x);
		Mample m1 = new Mample();
		Mample m2 = new Mample(20);

		System.out.println(m1.x);
		System.out.println(m2.x);
	}
}

class Sample {
	public final int x = 10;
	public static final int y = 20;
}

class Mample {
	public final int x;

	public Mample()
	{
		x = 0;
	}

	public Mample(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 final bir değişkene sabit ifadesi (constant expression) verilmesi zorunlu değildir. Sınıfın static ve final bir veri
	 elemanına sabit ifadesi ile ilk değer verildiğinde o veri elemanı sabit ifadesi olarak kullanılabilir. Sınıfın
	 public, static ve final bir veri elemanına sabit ifadesi ile ilk değer verildiğinde bir convention veri elemanı
	 isimlendirmesinde tamamen büyük harfler kullanılır ve birden fazla kelime için alttire karakteri ile ayrım yapılır.
	 public olmayan veya sabit ifadesi ile değeri verilmeyen final ve static veri elemanları için genel olarak programcı
	 tarafından isimlendirme tekniği belirlenir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class GameObject {
	public void move(int direction)
	{
		switch (direction) {
			case Direction.LEFT -> System.out.println("Left");
			case Direction.RIGHT -> System.out.println("Right");
			case Direction.TOP -> System.out.println("Top");
			case Direction.BOTTOM -> System.out.println("Bottom");
		}
	}
}

class Direction {
	public static final int LEFT = 0;
	public static final int RIGHT = 1;
	public static final int TOP = 2;
	public static final int BOTTOM = 3;
}

/*----------------------------------------------------------------------------------------------------------------------
	 Bir referansın final olması durumunda referansın gösterdiği nesne (yani içerisinde tuttuğu adres) değiştirilemez.
	 Ancak nesneye ilişkin sınıf immutable değilse nesnenin bilgileri değiştirilebilir. Bu durumda bir nesne final olamaz.
	 Bir nesnenin içeriğinin değiştirilememesi için o nesneye ilişkin sınıfın immutable olarak yazılmış olması gerekir.
	 Bu durumda da zaten nesneyi gösteren referansın final olup olmamasının bu anlamda önemi olmaz. Immutable bir sınıf
	 yazmanın final sınıf bildirimi ile doğrudan bir ilgisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		final Sample s = new Sample(10);

		s.x = 10;

		s = null; //error
	}
}

class Sample {
	public int x;

	public Sample(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    13.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte m_texts referansı gizlenmiştir. Referansın içerisindeki adres dışarıya verildiği için
	ve referans da bir diziyi gösterdiği için client code içerisinde dizinin elemanları değiştirilmiş ve dolayısıyla
	StringArrayGenerator sınıfının tuttuğu dizi de bu değişklikten etkilenmiştir. Yani referans değişkeni gizlemek ve
	final yapmak dizi nesneninin değiştirilmesini engellememiştir. Çünkü diziler immutable değildir. Bu durumda sınıfı
	yazan programcı da getTexts metodunun dokümantasyonunda bu durumu genellikle belirtir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.string.StringUtil;

import java.util.Random;

class App {
	public static void main(String[] args)
	{
		StringArrayGenerator generator = new StringArrayGenerator(new Random(), 10, 5, 11);
		String [] texts = generator.getTexts();

		for (String s : texts)
			System.out.printf("%s ", s);

		System.out.println();

		for (int i = 0; i < texts.length; ++i)
			texts[i] = texts[i].toLowerCase();

		for (String s : texts)
			System.out.printf("%s ", s);

		System.out.println();

		for (String s : generator.getTexts())
			System.out.printf("%s ", s);
	}
}

class StringArrayGenerator {
	private final String [] m_texts;

	public StringArrayGenerator(Random random, int count, int min, int bound)
	{
		m_texts = StringUtil.generateRandomTextsEN(random, count, min, bound);
	}

	public String [] getTexts()
	{
		return m_texts;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi dizinin bir kopyası çıkartılarak yapılabilir. Bu durumda sınıfı yazan programcı da
	getTexts metodunun dokümantasyonunda bu durumu belirtir.

	Anahtar Notlar: Arrays sınıfının copyOf metodu birinci parametresi ile aldığı dizinin, ikinci parametresi ile
	newLength tane elemanından oluşan yeni bir dizi referansına geri döner
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.string.StringUtil;

import java.util.Arrays;
import java.util.Random;

class App {
	public static void main(String[] args)
	{
		StringArrayGenerator generator = new StringArrayGenerator(new Random(), 10, 5, 11);
		String [] texts = generator.getTexts();

		for (String s : texts)
			System.out.printf("%s ", s);

		System.out.println();

		for (int i = 0; i < texts.length; ++i)
			texts[i] = texts[i].toLowerCase();

		for (String s : texts)
			System.out.printf("%s ", s);

		System.out.println();

		for (String s : generator.getTexts())
			System.out.printf("%s ", s);
	}
}

class StringArrayGenerator {
	private final String [] m_texts;

	public StringArrayGenerator(Random random, int count, int min, int bound)
	{
		m_texts = StringUtil.generateRandomTextsEN(random, count, min, bound);
	}

	public String [] getTexts()
	{
		return Arrays.copyOf(m_texts, m_texts.length);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekkte dizinin referansı gizlenmiştir yani client code'a verilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.string.StringUtil;

import java.util.Random;

class App {
	public static void main(String[] args)
	{
		StringArrayGenerator generator = new StringArrayGenerator(new Random(), 10, 5, 11);
		int len = generator.length();

		for (int i = 0; i < len; ++i)
			System.out.printf("%s ", generator.getText(i));

		System.out.println();
	}
}

class StringArrayGenerator {
	private final String [] m_texts;

	public StringArrayGenerator(Random random, int count, int min, int bound)
	{
		m_texts = StringUtil.generateRandomTextsEN(random, count, min, bound);
	}

	public int length()
	{
		return m_texts.length;
	}

	public String getText(int index)
	{
		return m_texts[index];
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Bir veri elemanının final olması algoritmik açıdan kodu değiştirimiyorsa ve final yapılması sentaks
    olarak error oluşturmuyorsa final olarak bildirilmesi her zaman iyi bir tekniktir. Pek çok static kod analizi
    arası da default olarak final yapma uyarısı verir. Ancak programcının nasılsa uyarı verir düşüncesiyle değil, iyi bir
    teknik olarak bunu tasarımda düşünmesi ve ona göre kodu yazması gerekir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    NumericLottery sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.random.lottery;

import java.util.Random;

public class NumericLottery {
    private final Random m_random;

    private boolean[] getFlags()
    {
        boolean [] flags = new boolean[50];

        for (int i = 0; i < 6; ++i) {
            int val;

            do
                val = m_random.nextInt(1, 50);
            while (flags[val]);
            flags[val] = true;
        }

        return flags;
    }

    private int [] getNumbers(boolean [] flags)
    {
        int [] numbers = new int[6];
        int idx = 0;

        for (int i = 1; i < 50; ++i)
            if (flags[i])
                numbers[idx++] = i;

        return numbers;
    }

    public NumericLottery(Random random)
    {
        m_random = random;
    }

    public int [] getNumbers()
    {
        return getNumbers(getFlags());
    }

    public int [][] getNumbers(int count)
    {
        int [][] numbers = new int[count][];

        for (int i = 0; i < count; ++i)
            numbers[i] = getNumbers();

        return numbers;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ExamSimulation sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.simulation.exam;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;
import java.util.Scanner;

public class ExamSimulation {
    private String m_lectureName;
    private int [][] m_grades;
    private double [] m_averages;
    private int [] m_maxGrades;
    private int [] m_minGrades;
    private double m_average;
    private int m_maxGrade;
    private int m_minGrade;

    private int calculateAndGetSumGrades(int i)
    {
        m_maxGrades[i] = 0;
        m_minGrades[i] = 100;
        int sumGrades = 0;

        for (int k = 0; k < m_grades[i].length; ++k) {
            m_maxGrades[i] = Math.max(m_maxGrades[i], m_grades[i][k]);
            m_minGrades[i] = Math.min(m_minGrades[i], m_grades[i][k]);
            m_maxGrade = Math.max(m_maxGrades[i], m_maxGrade);
            m_minGrade = Math.min(m_minGrades[i], m_minGrade);
            sumGrades += m_grades[i][k];
        }

        return sumGrades;
    }

    private void fillGrades()
    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("Şube sayısını giriniz:");
        int n = Integer.parseInt(kb.nextLine());

        m_grades = new int[n][];
        m_averages = new double[n];
        m_maxGrades = new int[n];
        m_minGrades = new int[n];

        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d.şube öğrenci sayısını giriniz:", i + 1);
            m_grades[i] = ArrayUtil.generateRandomArray(r, Integer.parseInt(kb.nextLine()), 0, 101);
        }
    }

    private void doSimulation()
    {
        int totalGrades = 0;
        int nStudents = 0;
        m_maxGrade = 0;
        m_minGrade = 100;

        for (int i = 0; i < m_grades.length; ++i) {
            nStudents += m_grades[i].length;
            int sumGrades = calculateAndGetSumGrades(i);

            m_averages[i] = (double) sumGrades / m_grades[i].length;
            totalGrades += sumGrades;
        }

        m_average = (double) totalGrades / nStudents;
    }

    public ExamSimulation(String name)
    {
        m_lectureName = name;
    }

    public String getLectureName()
    {
        return m_lectureName;
    }

    public void setLectureName(String lectureName)
    {
        m_lectureName = lectureName;
    }

    public int getGrade(int i, int k)
    {
        return m_grades[i][k];
    }

    public double getAverage(int i)
    {
        return m_averages[i];
    }

    public double getAverage()
    {
        return m_average;
    }

    public int getMaxGrade(int i)
    {
        return m_maxGrades[i];
    }

    public int getMaxGrade()
    {
        return m_maxGrade;
    }

    public int getMinGrade(int i)
    {
        return m_minGrades[i];
    }

    public int getMinGrade()
    {
        return m_minGrade;
    }

    public void run()
    {
        fillGrades();
        doSimulation();
    }

    public void printReport()
    {
        System.out.println("#################################################################");
        printGrades();
        for (int i = 0; i < m_averages.length; ++i)
            System.out.printf("%d.şube:Ortalama:%f, En yüksek not:%d, En düşük not:%d%n", i + 1, m_averages[i],
                    m_maxGrades[i], m_minGrades[i]);
        System.out.printf("Okul Ortalaması:%f%n", m_average);
        System.out.printf("En yüksek not:%d%n", m_maxGrade);
        System.out.printf("En düşük not:%d%n", m_minGrade);
        System.out.println("#################################################################");
    }

    public void printGrades()
    {
        System.out.println("-----------------------------------------------------------------");

        System.out.printf("%s dersi notları:%n", m_lectureName);
        for (int i = 0; i < m_grades.length; ++i) {
            System.out.printf("%d.şube:", i + 1);
            ArrayUtil.print(m_grades[i]);
        }

        System.out.println("-----------------------------------------------------------------");
    }
}


/*--------------------------------------------------------
	FILE NAME	: Complex.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	Complex class that represents a complex number

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math;

public class Complex {
	private double m_real, m_imag;

	private static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	private static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	private static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		m_real = re;
	}

	public Complex(double re, double im)
	{
		m_real = re;
		m_imag = im;
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.m_real, z.m_imag);
	}

	public Complex add(double val)
	{
		return add(m_real, m_imag, val, 0);
	}

	public Complex add(Complex other)
	{
		return add(m_real, m_imag, other.m_real, other.m_imag);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.m_real, z.m_imag);
	}

	public Complex subtract(double val)
	{
		return subtract(m_real, m_imag, val, 0);
	}

	public Complex subtract(Complex other)
	{
		return subtract(m_real, m_imag, other.m_real, other.m_imag);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.m_real, z.m_imag);
	}

	public Complex multiply(double val)
	{
		return multiply(m_real, m_imag, val, 0);
	}

	public Complex multiply(Complex other)
	{
		return multiply(m_real, m_imag, other.m_real, other.m_imag);
	}

	public Complex conjugate()
	{
		return new Complex(m_real, -m_imag);
	}

	public Complex negate()
	{
		return new Complex(-m_real, -m_imag);
	}

	public void inc()
	{
		++m_real;
	}

	public void dec()
	{
		--m_real;
	}

	public String toString()
	{
		return String.format("%f + %f * i", m_real, m_imag);
	}
}

/*--------------------------------------------------------
	FILE NAME	: StringUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	Utility class for string operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.string;

import java.util.Random;

public class StringUtil {
	private static final String LETTERS_EN = "abcdefghijklmnopqrstuvwxyz";
	private static final String LETTERS_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
	private static final String LETTERS_CAPITAL_EN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	private static final String LETTERS_CAPITAL_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
	private static final String LETTERS_ALL_EN = LETTERS_EN + LETTERS_CAPITAL_EN;
	private static final String LETTERS_ALL_TR = LETTERS_TR + LETTERS_CAPITAL_TR;

	private StringUtil()
	{
	}

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;

		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String generateRandomTextEN(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_EN);
	}

	public static String generateRandomTextTR(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_TR);
	}

	public static String generateRandomText(Random random, int count, String sourceText)
	{
		StringBuilder sb = new StringBuilder(count);
		int len = sourceText.length();

		for (int i = 0; i < count; ++i)
			sb.append(sourceText.charAt(random.nextInt(len)));

		return sb.toString();
	}

	public static String [] generateRandomTextsEN(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_EN);
	}

	public static String [] generateRandomTextsTR(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_TR);
	}

	public static String [] generateRandomTexts(Random random, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		for (int i = 0; i < count; ++i)
			texts[i] = generateRandomText(random, random.nextInt(min, bound), sourceText);

		return texts;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_EN);
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_TR);
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static String padLeading(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : String.valueOf(ch).repeat(newLen - s.length()) + s;
	}

	public static String padLeading(String s, int newLen)
	{
		return padLeading(s, newLen, ' ');
	}

	public static String padTrailing(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : s + String.valueOf(ch).repeat(newLen - s.length());
	}

	public static String padTrailing(String s, int newLen)
	{
		return padTrailing(s, newLen, ' ');
	}

	public static String reverse(String s)
	{
		return new StringBuilder(s).reverse().toString();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıda açıklanan IntValue isimli sınıfı yazınız
	Açıklamalar:
		- Sınıf int türden bir değeri sarmalayacaktır (wrapping).

		- Sınıf immutable olarak yazılacaktır. Yani sınıf içerisinde tutulan int türden değer client code'lar tarafından
		değiştirilemeyecektir.

		- Sınıf [-128, 127] aralığındaki değerler için bir ön bellek (cache) tutacaktır. Bu aralıktaki bir değer için
		ilk sarmalamada nesne yaratılacak ve tekrar aynı değer istendiğinde daha önceden yaratılmış olan nesnenin
		referansı verilecektir.

		- Sınıf [-128, 127] aralığı dışında kalan değerleri ön bellekte tutmayacaktır.

		- Sınıfa senaryosu doğrulrusunda pek çok eklenti yapılabilir

	Anahtar Notlar: Ön bellek (cache) genel bir kavramdır ve etkinlik açısından tercih edilir. Bu örnekte sınıf nasılsa
	immutable olduğundan belirli bir aralıktaki değerler için ayrı ayrı nesnelerin yaratılması engellenmiştir. Bu durumda
	bellek de etkin kullanılmış olur. Daha fazla değerin saklanmaması yine etkinlik açısından düşünülmüştür. Daha fazla
	değerin ön bellekte tutulması da yine belleğin etkin kullanımı açısından tercih edilmemiştir.

	Anahtar Notlar: Aslında JavaSE'de örnekteki int türden bir değeri immutable olarak sarmalayan ve [-128, 127] araslığındaki
	değerleri ön bellekte tutan bir sınıf vardır. İleride ele alınacaktır. Burada programlama açısından böyle bir sınıfın
	nasıl yazılabilediği örneklenmiştir.

	Anahtar Notlar: Bir değerin sarmalanması aslında o değerin bir sınıf içerisinde tutulması anlamında kullanılır. Temel
	türden bir değerin heap'de tutulmasına yani sarmalanmasına genel olarak "boxing" denilmektedir. Boxing ve unboxing
	kavramları ileride detaylı olarak ele alınacaktır.

	Anahtar Notlar: Java 8 öncesinde pek çok sınıfta valueOf isimli factory method'lar bulundurulmuştur. Java 8 ile
	birlikte bu tarz bir factory metot isimlendirmesinde valueOf yerine of ismi tercih edilmiştir. Java 8'den itibaren
	eklenen sınıflarda bu tarz bir metot of ismiyle bildirilmektedir. Bu bir convention'dır.

	Anahtar Notlar: Yukarıdaki örnekte [-128, 127] aralığında kalan bir değer için nesne ilk kez sarmalandığında yaratılıp
	aynı değerin tekrar sarmalanması durumunda aynı nesne kullanıldığından kalıp olarak GOF'un flyweight tasarım kalıbı
	implemente edilmiştir. Kalıbın detayları şu an için önemsizdir.


----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.primitive.wrapper.test;

import org.csystem.primitive.wrapper.IntValue;

public class IntValueOfCacheTest {
    public static void run()
    {
        IntValue iVal1 = IntValue.of(-128);
        IntValue iVal2 = IntValue.of(-128);
        IntValue iVal3 = IntValue.of(127);
        IntValue iVal4 = IntValue.of(127);
        IntValue iVal5 = IntValue.of(67);
        IntValue iVal6 = IntValue.of(67);
        IntValue iVal7 = IntValue.of(128);
        IntValue iVal8 = IntValue.of(128);

        System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı nesneler");
        System.out.println(iVal3 == iVal4 ? "Aynı nesne" : "Farklı nesneler");
        System.out.println(iVal5 == iVal6 ? "Aynı nesne" : "Farklı nesneler");
        System.out.println(iVal7 == iVal8 ? "Aynı nesne" : "Farklı nesneler");
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.primitive.wrapper.test;

import org.csystem.primitive.wrapper.IntValue;

public class IntValueAllCacheTest {
    public static void run()
    {
        for (int v = -128; v <= 127; ++v) {
            IntValue iVal1 = IntValue.of(v);
            IntValue iVal2 = IntValue.of(v);

            System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı nesneler");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*--------------------------------------------------------
	FILE NAME	: IntValue.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	Wrapper class that use cache for values in [-128, 127]

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.primitive.wrapper;

public class IntValue {
    private static final int CACHE_MIN_VALUE = -128;
    private static final int CACHE_MAX_VALUE = 127;
    private static final IntValue [] CACHE = new IntValue[CACHE_MAX_VALUE - CACHE_MIN_VALUE + 1];
    private final int m_value;

    private IntValue(int value)
    {
        m_value = value;
    }

    public static IntValue of(int value)
    {
        if (value < CACHE_MIN_VALUE || value > CACHE_MAX_VALUE)
            return new IntValue(value);

        if (CACHE[value - CACHE_MIN_VALUE] == null)
            CACHE[value - CACHE_MIN_VALUE] = new IntValue(value);

        return CACHE[value - CACHE_MIN_VALUE];
    }

    public int getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazı sınıfların duruma göre hem mutable hem de immutable versiyonları kütüphanede buılundurulur. Şüphesiz bu durum da
	yine sınıfın domain'ine göre belirlenir. Böylesi yani hem mutable hem de immutable versiyonu olan sınıfların
	isimlendirilmesinde genel olarak, immutable olan doğrudan isimlendirilir mutable olan da Mutable ön eki ile isimlendirilir.
	Örneğin, point sınıfının hem mutable hem de immutable olan versiyonları yazılacaksa immutbale olana Point ismi,
	mutable olana ise MutablePoint ismi verilir. Şüphesiz bu bir convention'dır. Aşağıdaki Point ve MutablePoint
	sınıfları ile friendly olarak yazılan utility PointCommon sınıflarını inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	Immutable Point class that represents a 2-dimensional
	point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Point {
	private final double m_x, m_y;

	private Point(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static Point createCartesian(double x, double y)
	{
		return new Point(x, y, false);
	}

	public static Point createPolar(double radius, double theta)
	{
		return new Point(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public double getY()
	{
		return m_y;
	}


	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: MutablePoint.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	MutablePoint class that represents a 2-dimensional point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class MutablePoint {
	private double m_x, m_y;

	private MutablePoint(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static MutablePoint createCartesian(double x, double y)
	{
		return new MutablePoint(x, y, false);
	}

	public static MutablePoint createPolar(double radius, double theta)
	{
		return new MutablePoint(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public void setX(double x)
	{
		m_x = x;
	}

	public double getY()
	{
		return m_y;
	}

	public void setY(double y)
	{
		m_y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(MutablePoint other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		m_x += dx;
		m_y += dy;
	}

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: PointCommon.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 13th January 2024

	Friendly common utility class for Point and MutablePoint
	classes

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.*;

class PointCommon {
    private PointCommon()
    {
    }

    static double getXBy(boolean polar, double a, double b)
    {
        return polar ? a * cos(b) : a;
    }

    static double getYBy(boolean polar, double a, double b)
    {
        return polar ? a * sin(b) : b;
    }

    static double distance(double x1, double y1, double x2, double y2)
    {
        return sqrt(pow(x1- x2, 2) + pow(y1 - y2, 2));
    }

    static String toString(double x, double y)
    {
        return String.format("(%f, %f)", x, y);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    14.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte Font sınıfının setColor ve GameObject sınıfının move metotlarının parametre isimleri bir fikir
	verse de parametrelerin türleri hangi değerleri alabileceğine yönelik bir fikir vermemektedir. Şüphesiz bu dokümantasyondan
	anlaşılabilir ancak kod açısından metotlar okunabilir/algılanabilir yazılmamıştır. Ayrıca bu metotlar çağrılırken
	verilen değerler de client code'ların okunabilirliğini/algılanabilirliğini azaltmaktadır. Yani aşağıdaki sınıflar
	ve ilgili metotları (setColor ve move) özel bir durum yoksa iyi tasarlanmanmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Font f = new Font();
		GameObject g = new GameObject();

		//...

		f.setColor(0);
		//...
		f.setColor(2);

		//...
		f.setColor(4);

		g.move(0);

		//...
		g.move(1);

		//...

		g.move(3);
	}
}

//Red = 0, Green = 1, Blue = 2, White = 3, Black = 4
class Font {
	public void setColor(int color)
	{
		//...
	}
}

//Right = 0, Top = 1, Left = 2, Bottom = 3
class GameObject {
	public void move(int direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte metotların parametre değişkenleri String yapıldığında clien code'ların okunabilirliği/algılanabilirliği
	artmıştır ancak metotların parametre değişkenleri yine geçilebilecek argümanlarla ilgili fikir vermemektedir. Üstelik
	yazıları karşılaştırılması int türüne göre daha yavaştır. Ayrıca yazılar argüman olarak geçilirken hata yapma olasılığı da
	vardır. Şüphesiz bu durum final değişkenler ile engellenebilir ancak diğer durumlar önemlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Font f = new Font();
		GameObject g = new GameObject();

		//...

		f.setColor("Red");
		//...
		f.setColor("Blue");

		//...
		f.setColor("Black");

		g.move("Right");

		//...
		g.move("Top");

		//...

		g.move("Bottom");
	}
}

class Font {
	public void setColor(String color)
	{
		//...
	}
}

class GameObject {
	public void move(String direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örneğe aşağıdaki FontColor ve Directionj sınıfları eklenerek istenilen gerçekleştirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Font f = new Font();
		GameObject g = new GameObject();

		//...

		f.setColor(FontColor.RED);
		//...
		f.setColor(FontColor.BLUE);

		//...
		f.setColor(FontColor.BLACK);

		g.move(Direction.RIGHT);

		//...
		g.move(Direction.TOP);

		//...

		g.move(Direction.BOTTOM);
	}
}

class FontColor {
	private FontColor()
	{}

	public static final FontColor RED = new FontColor();
	public static final FontColor GREEN = new FontColor();
	public static final FontColor BLUE = new FontColor();
	public static final FontColor WHITE = new FontColor();
	public static final FontColor BLACK = new FontColor();
}

class Font {
	public void setColor(FontColor color)
	{
		//...
	}
}


class Direction {
	private Direction()
	{
	}

	public static final Direction RIGHT = new Direction();
	public static final Direction TOP = new Direction();
	public static final Direction LEFT = new Direction();
	public static final Direction BOTTOM = new Direction();
}

class GameObject {
	public void move(Direction direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte yukarıdaki FontColor ve Direction sınıflarındaki veri elemanlarının daha kolay bildirildiği ve
	daha başka yetenekleri de olan enum sınıflar (enumeration/enum classes) dile eklenmiştir. Detaylar daha sonraki
	örneklerde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Font f = new Font();
		GameObject g = new GameObject();

		//...

		f.setColor(FontColor.RED);
		//...
		f.setColor(FontColor.BLUE);

		//...
		f.setColor(FontColor.BLACK);

		g.move(Direction.RIGHT);

		//...
		g.move(Direction.TOP);

		//...

		g.move(Direction.BOTTOM);
	}
}

enum FontColor {
	RED, GREEN, BLUE, WHITE, BLACK
}

class Font {
	public void setColor(FontColor color)
	{
		//...
	}
}


enum Direction {
	RIGHT, TOP, LEFT, BOTTOM
}

class GameObject {
	public void move(Direction direction)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfları enum anahtar sözcüğü ile bildirilir. enum sınıfı içerisinde virgül ile ayrılacak şekilde bildirilen
	isimlere enum sabitleri (enum constants) denir. enum sabitleri public static, final olarak bildirilmiş ve ilgili
	enum sınıfı türünden referans değişkendir ve bu değişkenler yaratıldığında her biri ilgili enum sınıfı türünden
	bir nesneyi gösterir duruma gelir. enum sabitleri için public, statici final veya tür bilgisinin yazılması error
	oluşturur. Son enum sabitinden sonra noktalı virgül konabilir. Bu noktalı virgül eğer enum sınıfına sabit dışında
	bir eleman eklenecekse zorunludur. Bu durum ileride ele alınacaktır. enum sınıflar kendine has özellikleri olan
	sınıflardır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum DayOfWeek {
	SUN, MON, TUE, WED, THU, FRI, SAT
}

enum Month {
	JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
}

enum CardValue {
	TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, KNAVE, QUEEN, KING, ACE
}

enum FontColor {
	RED, GREEN, BLUE, WHITE, BLACK
}

enum Direction {
	RIGHT, TOP, LEFT, BOTTOM
}

enum CardType {
	SPADE, CLUB, HEART, DIAMOND
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir enum sabitinin, enum içerisindeki bildirim sırasına ilişkin ordinal değeri vardır. ordinal değeri enum sınıfının
	ordinal isimli metodu ile elde edilebilir. ordinal değeri sıfırdan başlar. enum sınıfının static values isimli metodu
	ile sabitlere ilişkin referansların sırasıyla bulunduğu ilgili enum türünden bir dizi elde edilebilir. values her
	çağrıldığında yeni bir dizi referansı elde edilir. enum sınıfının toString metodu ilgili referansa ilişkin sabitin
	yazısal karşılığına geri döner. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		CardValue [] cardValues = CardValue.values();
		CardType []cardTypes = CardType.values();
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Kaç tane kart istiyorsunuz?");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			System.out.println("--------------------------------------");
			Card c = new Card(cardTypes[random.nextInt(cardTypes.length)], cardValues[random.nextInt(cardValues.length)]);

			System.out.println(c.toString());
			System.out.printf("Ordinal of card type:%d, Ordinal of card value:%d%n", c.getCardType().ordinal(), c.getCardValue().ordinal());
			System.out.println("--------------------------------------");
		}
	}
}


class Card {
	private CardValue m_cardValue;
	private CardType m_cardType;

	public Card(CardType cardType, CardValue cardValue)
	{
		m_cardType = cardType;
		m_cardValue = cardValue;
	}

	public CardValue getCardValue()
	{
		return m_cardValue;
	}

	public void setCardValue(CardValue cardValue)
	{
		m_cardValue = cardValue;
	}

	public CardType getCardType()
	{
		return m_cardType;
	}

	public void setCardType(CardType cardType)
	{
		m_cardType = cardType;
	}

	public String toString()
	{
		return String.format("%s-%s", m_cardType.toString(), m_cardValue.toString());
	}
}

enum CardType {
	SPADE, CLUB, HEART, DIAMOND
}

enum CardValue {
	TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, KNAVE, QUEEN, KING, ACE
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		for (Card card : Card.getDeck())
			System.out.println(card.toString());
	}
}


class Card {
	private CardValue m_cardValue;
	private CardType m_cardType;

	public static Card[] getDeck()
	{
		Card [] deck = new Card[52];
		int i = 0;

		for (CardType cardType : CardType.values())
			for (CardValue cardValue : CardValue.values())
				deck[i++] = new Card(cardType, cardValue);

		return deck;
	}

	public Card(CardType cardType, CardValue cardValue)
	{
		m_cardType = cardType;
		m_cardValue = cardValue;
	}

	public CardValue getCardValue()
	{
		return m_cardValue;
	}

	public void setCardValue(CardValue cardValue)
	{
		m_cardValue = cardValue;
	}

	public CardType getCardType()
	{
		return m_cardType;
	}

	public void setCardType(CardType cardType)
	{
		m_cardType = cardType;
	}

	public String toString()
	{
		return String.format("%s-%s", m_cardType.toString(), m_cardValue.toString());
	}
}

enum CardType {
	SPADE, CLUB, HEART, DIAMOND
}


enum CardValue {
	TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, KNAVE, QUEEN, KING, ACE
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ordinal değerinin kullanımına ilişkin demo bir senaryo ele alınmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		Month [] months = Month.values();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			Month month1 = months[random.nextInt(months.length)];
			Month month2 = months[random.nextInt(months.length)];
			int diff = month1.ordinal() - month2.ordinal();

			if (diff > 0)
				System.out.printf("%s ile %s arasında %d ay vardır%n", month2.toString(), month1.toString(), diff);
			else if (diff < 0)
				System.out.printf("%s ile %s arasında %d ay vardır%n", month1.toString(), month2.toString(), -diff);
			else
				System.out.printf("%s ile %s aynı aylardır%n", month1.toString(), month2.toString());
		}
	}
}


enum Month {
	JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfına sabitler dışında da elemanlar eklenebilir. Bunun için son sabit bildiriminden sonra noktalı virgül
	konmalıdır. enum sınıfına klasik sınıflarda olduğu gibi veri elemanı, ctor ve metot eklenebilmektedir. enum sınıfına
	herhangi bir ctor eklenmemişse klasik sınıflarda olduğu gibi default ctor derleyici tarafından içi boş ve otomatik
	olarak yazılır. Ancak klasik sınıflarda default ctor public yazılırken, enum sınıflarında ister derleyici yazsın
	ister programcı yazsın bir ctor public olarak yazılamaz. ctor ya private ya da no-modifier olarak yazılabilir. enum
	sınıflarında ctor için no-modifier private ile aynı anlamdadır. Ancak diğer elemanlar için yin eklasik sınıflardaki
	erişim belirliyiciler geçerlidir. ctor'un private olması (aslında private'dan da öte) enum sınıfı türünden nesnenin
	sınıf dışında yaratılamauacağı anlamındadır. enum sınıfı için sınıf içerisinde de aynı enum sınıfı türünden bir nesne
	yaratılamaz. Yani enum sınıflarının ctor'ları private erişiminde ötesinde bir erişime sahiptir. Bu durumda bir
	enum sınıfı türünden nesne sayısı sabit sayısı kadardır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte sabitlere ilişkin nesneler default ctor ile yaratılmıştır. Örnekte doWork çağrısında tüm
	static veri elemanları yaratıldığından 12 tane I am a default ctor yazısı ve sonrasında doWork yazısı görüntülenecektir.
	Sınıfın static veri elemanlarının, sınıfın ilk kez bir elemanı kullanıldığında hepsinin birden yaratıldığını
	anımsayınız. Bir enum sabiti () ile bildirildiğinde ilgili nesne default ctor kullanılarak yaratılır, () kullanılmasa da
	yine default ctor çağrılır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Month.doWork();
	}
}


enum Month {
	JAN(), FEB(), MAR(), APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC;
	Month()
	{
		System.out.println("I am a default ctor");
	}

	public static void doWork()
	{
		System.out.println("doWork");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte Color enum sınıfına ilişkin her sabite r, g, b değerleri iliştirilmiştir. Artık her Color nesnesinin
	r, g ve b non-static veri elemanları ilgili değerleri ile yaratılmıştır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Color [] colors = Color.values();
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			Color c = colors[random.nextInt(colors.length)];

			System.out.printf("%s(%d, %d, %d)%n", c.toString(), c.r, c.g, c.b);
		}
	}
}


enum Color {
	RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255), BLACK(0, 0, 0), WHITE(255, 255, 255);
	public final int r, g, b;
	Color(int x, int y, int z)
	{
		r = x;
		g = y;
		b = z;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Month [] months = Month.values();
		Random random = new Random();
		Scanner kb = new Scanner(System.in);

		System.out.print("Input a value:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			Month m = months[random.nextInt(months.length)];
			int year = random.nextInt(1900, 2101);

			System.out.printf("Month:%s, Year:%d, Days:%d%n", m.toString(), year, m.getDays(year));
		}
	}
}

enum Month {
	JAN(31), FEB(28), MAR(31), APR(30), MAY(31), JUN(30), JUL(31), AUG(31), SEP(30), OCT(31), NOV(30), DEC(31);
	private final int m_days;

	private static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}

	Month(int days)
	{
		m_days = days;
	}

	public int getDays(int year)
	{
		return ordinal() == 1 && isLeapYear(year) ? 29 : m_days;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfının valueOf static metodu parametresi ile aldığı yazıyla aynı isimde enum sabiti varsa o sabite ilişkin
	referansa geri döner. Aksi durumda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);

		System.out.print("Input marital status as SINGLE or MARRIED or DIVORCED or WIDOW:");
		MaritalStatus maritalStatus = MaritalStatus.valueOf(kb.nextLine());

		System.out.println(maritalStatus.toString());
	}
}

enum MaritalStatus {
	SINGLE, MARRIED, DIVORCED, WIDOW
}

/*----------------------------------------------------------------------------------------------------------------------
	enum referansları == veya != operatörü ile karşılaştırıldığında aslında mantıksal eşitlik karşılaştırması da
	yapılmış olur. Yani referans karşılaştırması çoğu zaman mantıksal eşitlik karşılaştırması olarak da kullanılabilir.
	enum sınıfının ayrıca compareTo isimli metodu vardır. compareTo metodu a.compareTo(b) çağrısı için
		a.ordinal() - b.ordinal()
	değerine geri döner. Bu durumda bu değer negatif ise a referansına ilişkin sabit, b referansına sabitten önce gelir,
	pozitif ise a referansına ilişkin sabit, b referansına sabitten sonra gelir, sıfırsa iki referans da aynı nesneyi
	gösterir durumdadır. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Random random = new Random();
		Scanner kb = new Scanner(System.in);
		Month [] months = Month.values();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			Month month1 = months[random.nextInt(months.length)];
			Month month2 = months[random.nextInt(months.length)];
			int diff = month1.compareTo(month2);

			if (diff > 0)
				System.out.printf("%s ile %s arasında %d ay vardır%n", month2.toString(), month1.toString(), diff);
			else if (diff < 0)
				System.out.printf("%s ile %s arasında %d ay vardır%n", month1.toString(), month2.toString(), -diff);
			else
				System.out.printf("%s ile %s aynı aylardır%n", month1.toString(), month2.toString());
		}
	}
}


enum Month {
	JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
}

/*----------------------------------------------------------------------------------------------------------------------
	enum sınıfı switch ile kullanılabilmektedir. Bu durumda case bölümlerinin enum sabitlerinden biri olması gerekir.
	bu sabitler enum sınıf isminin kullanılmasına gerek yoktur. Bu anlamda aslında bir enum sabiti aynı zamamda bir
	constant expression'dır. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

enum FontColor {
	RED, GREEN, BLUE, WHITE, BLACK
}

class Font {
	public void setColor(FontColor color)
	{
		switch (color) {
			case RED -> System.out.println("Kırmızı");
			case GREEN -> System.out.println("Yeşil");
			case BLUE -> System.out.println("Mavi");
			case WHITE -> System.out.println("Beyaz");
			case BLACK -> System.out.println("Siyah");
			default -> System.out.println("Geçrsiz renk...");
		}

		//...
	}
}


enum Direction {
	RIGHT, TOP, LEFT, BOTTOM
}

class GameObject {
	public void move(Direction direction)
	{
		switch (direction) {
			case RIGHT -> System.out.println("Sağa dön");
			case TOP -> System.out.println("Yukarı çık");
			case LEFT -> System.out.println("Sola dön");
			case BOTTOM ->  System.out.println("Aşağı in");
			default -> System.out.println("Geçersiz yön!...");
		}
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Singleton sınıfın eager implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Singleton s1 = Singleton.INSTANCE;
		Singleton s2 = Singleton.INSTANCE;

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
	}
}

class Singleton {
	public static final Singleton INSTANCE = new Singleton();
	private int m_value;

	private Singleton()
	{
	}

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Singleton sınıfın eager implementasyonu enum sınıf ile çok daha basit ve etkin olarak yapılabilir. Lazy implementasyon
	söz konusu olmadıktan sonra Java'da en iyi Singleton implementasyonu budur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Singleton s1 = Singleton.INSTANCE;
		Singleton s2 = Singleton.INSTANCE;

		System.out.println(s1 == s2 ? "Aynı nesne" : "Farklı nesneler");
	}
}

enum Singleton {
	INSTANCE;
	private int m_value;

	public int getValue()
	{
		return m_value;
	}

	public void setValue(int value)
	{
		m_value = value;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Dikkat edilirse enum sabitleri ve dolayısıyla gösterdikleri nesneler yaratıldıktan sonra programın
    sonuna kadar yaşarlar. Bu durum nadir de olsa önemli bazı uygulamalarda bellek açısından dezavantaj oluşturabilir.
    Örneğin bir çok güçlü olmayan (limited) bir Android cihazın bellek kapasitesi kullanımına göre kısıtlı olabilir ve
    yaratılan nesnelerin uzun süre yaşamaması gerekebilir. Böylesi nadir ama önemli durumlarda enum sınıf kullanmak yerine
    int türden değerler kullanmak uygun olabilecektir. Bu durumda performans açısından okunabilirlikten/algılanabilirkten
    vazgeçilmiş olur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    20.01.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıflararası İlişkiler: Bir projenin kodlama aşamasında, NYPT kullanılacaksa ilk olarak domain'e ilişkin varlıkların
	karşılık geldiği sınıflar belirlenir.  Sonra aralarındaki ilişkiler belirlenir. Bu kavrama transformation da denilmektedir.
	Sonrasında kodlama aşamasına geçilir. Örneğin bir uçak bileti rezarvasyonuna ilişkin bir uygulamada, uçuş, havaalanı,
	yolcu gibi kavramlar sınıflar olarak belirlenir. Aslında ilişkiler nesne düzeyinde düşünülür ve sınıflar olarak
	implemente edilir.

	Bir uygulamanın ihtiyaçlarının belirlenmesinden teslimine kadar geçen süreci şemalarla ifade etmeye yarayan
	UML (Unified Modeling Language) denilen bir araç kullanılabilmektedir. UML'in genel olarak programcıyı ilgilendiren
	önemli şemalarından biri "class diagram"'dır. Bu şema ile sınıflar ve aralarındaki ilişkiler bir standart olarak
	gösterilebilmektedir.

	Anahtar Notlar: UML oldukça geniş bir kavramdır. Teorik olarak bakıldığında UML ile projenin tüm aşamaları belirlenebilir.
	Ancak prtatikte her projede tüm detayıyla kullanılmaz. Hatta bazen kodlama aşamasından sonra da şemalarda değişiklik
	yapılabilir. Bu UML'in hedefine aykırı bir durum değildir. UML projenin süreçlerini anlatır. Değişiklik yapıldığında
	şemaların değişmesi de normal bir durumdur.

	Bir kodun yazılabilmesi için gereken kodlar olması durumuna genel olarak "dependency" denilmektedir. Örneğin bir
	metodu yazmak için başka bir metodun olması gerektiği durum böylesi bir durumdur. NYPT açısından dependency sınıflar
	için de söz konusudur. Örneğin bir sınıfın başka bir sınıf türünden veri elemanı olması durumu aslında bir dependency'dir.
	Yani daha kabaca söylemek gerekirse, bir sınıfın derlenebilmesi için başka bir sınıfın var olması gerektiği durumdur.

	Anahtar Notlar: Modelleme yapılırken kavramın özel durumları değil genel durumları düşünülür. Özel durumlar da
	düşünüldüğünde hiç bir şey modellenemez. Örneğin bir "araba" nesnesi ile ona ait olan "motor" nesnesi arasındaki
	ilişki (ne olduğu şu an önemsiz) aşağıdaki koşulu genel olarak sağlar:
		- Bir araba nesnesine ait motor nesnesi başka bir nesne tarafından kullanılamayacak
		- Bir araba nesnesine ait motor nesnesi ömrüne hemen hemen araba ile başlayacak ve ömrü araba ile son bulacak.
	Buradaki örnekte özel bir durum olan arabanın motorunun değişmesi kavramı bu modeli etkilemez. Çünkü genel olarak
	karşılaşılan bir durum değildir.

	İki sınıf arasında aşağıdaki ilişkilerden birisi vardır ya da hiç birisi yoktur:
	- Composition (has a): A has B ilişkisinde aşağıdaki iki koşulun gerçeklenmesi gerekir. Ya da tersine aşağıdaki iki
	koşul gerçeklendiğinde bu ilişki söz konusudur:
	    - A nesnesine ait B nesnesi başka bir nesne tarafından kullanılamayacak.
	    - A nesnesine ait B nesnesi ömrüne hemen hemen, ait olduğu A nesnesi ile başlayacak ve ömrü hemen hemen bu nesne
	    ile son bulacak.
	Burada, B nesnesi ait olduğu nesne tarafından gerektiğinde kullanılabilmektedir. Gerektiğinde kullanıma bütünsel
	kullanım (whole usage) denir.

	- Aggregation (holds a): A holds a B ilişkisi, composition ilişkisinin koşullarından en az birisinin gerçeklenmediği
	bütünsel kullanım ilişkisidir.

	- Association: Bir nesnenin başka bir nesneyi ihtiyacı ölçüsünde kullanması (partial usage), bütünsel olarak kullanmaması
	ilişkisidir.

	- Inheritance (is a): Biyolojiden programlamaya aktarılmış bir kavramdır. Biyoloji'de inheritance, ebeveynin (parent)
	özelliklerinin çocuğuna (child) aktarılmasıdır. NYPT'ye ilişkin detayları ileride ele alınacaktır

    Anahtar Notlar: Yukarıdaki 4 ilişkiden inheritance dışındakiler için Java'da ayrı bir kural seti yoktur. İlişkinin
    tanımı ve kuralları doğrultusunda, Java kuralları ile implementasyon yapılır. Ancak inheritance için Java'da ayrı
    bir kural seti vardır.

	Anahtar Notlar: İki sınıf arasında, sınıfların tasarımları ve implementasyonları gereği yukarıdaki 4 ilişkiden hiç
	birisi olmamasına karşın bir bağımlılık söz konusu olabilir. Bu da özel durumlardan biridir, genel durumu etkilemez
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki composition ilişkisinin bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A x = new A(/*...*/);
		A y = new A(/*...*/);

		x.doSomething1();
		x.doSomething2();
		y.doSomething1();
		y.doSomething2();
	}
}

class A {
	private B m_b;

	//...

	public A(/*...*/)
	{
		m_b = new B(/*...*/);
		//...
	}

	public void doSomething1()
	{
		//...
		m_b.doWork();
		//...
	}

	public void doSomething2()
	{
		//...
		m_b.doWork();
		//...
	}
}

class B {
	//...

	public void doWork()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki aggregation ilişkisinin bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B b1 = new B(/*...*/);
		B b2 = new B(/*...*/);
		A a = new A(b1/*...*/);

		a.doSomething1();
		a.doSomething2();
		a.setB(b2);
		a.doSomething1();
		a.doSomething2();
	}
}

class A {
	private B m_b;

	//...

	public A(B b/*...*/)
	{
		m_b = b;
		//...
	}

	public B getB()
	{
		return m_b;
	}

	public void setB(B b)
	{
		//...
		m_b = b;
	}

	public void doSomething1()
	{
		//...
		m_b.doWork();
		//...
	}

	public void doSomething2()
	{
		//...
		m_b.doWork();
		//...
	}
}

class B {
	//...

	public void doWork()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte Car ile Engine ve Driver arasındaki ve Plane ile Engine ve Pilot arasındaki ilişkileri
	inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Driver driver = new Driver("Ali Serçe", 100);
		Car car = new Car(driver/*...*/);
		Pilot [] pilots = {new Pilot(1, "Kaan Aslan", 10000), new Pilot(2, "Oğuz Karan", 7000), new Pilot(3, "Güray Sönmez", 2000)};
		Plane plane = new Plane(4, pilots/*...*/);

		//...
		car.run();
		plane.fly();
	}
}

class Plane {
	private Engine [] m_engines;
	private Pilot [] m_pilots;

	private void startEngines()
	{
		for (Engine engine : m_engines)
			engine.startEngine();
	}

	private void accelerateEngines()
	{
		for (Engine engine : m_engines)
			engine.accelerateEngine();
	}

	private void slowEngines()
	{
		for (Engine engine : m_engines)
			engine.slowEngine();
	}

	private void stopEngines()
	{
		for (Engine engine : m_engines)
			engine.stopEngine();
	}

	public Plane(int nEngines, Pilot [] pilots/*...*/)
	{
		//...
		m_engines = new Engine[nEngines];

		for (int i = 0; i < nEngines; ++i)
			m_engines[i] = new Engine(/*...*/);

		m_pilots = pilots;
		//...
	}

	public void fly()
	{
		System.out.println("Pilots:");

		for (Pilot pilot : m_pilots)
			System.out.printf("Pilot-%d:%s%n", pilot.getTitle(), pilot.toString());

		startEngines();
		accelerateEngines();

		//...
		System.out.println("flying!...");

		slowEngines();
		stopEngines();
	}

	//...
}

class Car {
	private Engine m_engine;
	private Driver m_driver;

	public Car(Driver driver/*...*/)
	{
		//...
		m_driver = driver;
		m_engine = new Engine(/*...*/);
		//...
	}
	public void brake()
	{
		//...
		System.out.println("brake!...");
		m_engine.slowEngine();
		//...
	}

	public void run()
	{
		System.out.printf("Driver:%s%n", m_driver.toString());
		m_engine.startEngine();
		m_engine.accelerateEngine();

		//...

		System.out.println("running!...");

		brake();
		m_engine.stopEngine();
	}

	//...
}

class Pilot {
	private int m_title;
	private String m_name;
	private int m_flightDuration;
	//...

	public Pilot(int title, String name, int flightDuration)
	{
		m_title = title;
		m_name = name;
		m_flightDuration = flightDuration;
	}

	public int getTitle()
	{
		return m_title;
	}

	public void setTitle(int title)
	{
		m_title = title;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		m_name = name;
	}

	public int getFlightDuration()
	{
		return m_flightDuration;
	}

	public void setFlightDuration(int flightDuration)
	{
		m_flightDuration = flightDuration;
	}

	public String toString()
	{
		return String.format("Title:%d, Name:%s, Flight Duration:%d", m_title, m_name, m_flightDuration);
	}

	//...
}

class Driver {
	private String m_name;
	private int m_rating;

	//...

	public Driver(String name, int rating)
	{
		m_name = name;
		m_rating = rating;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		m_name = name;
	}

	public int getRating()
	{
		return m_rating;
	}

	public void setRating(int rating)
	{
		m_rating = rating;
	}

	public String toString()
	{
		return String.format("Name:%s, Rating:%d", m_name, m_rating);
	}

	//...
}

class Engine {
	//...
	public void startEngine()
	{
		System.out.println("Start engine");
	}

	public void accelerateEngine()
	{
		System.out.println("Accelerate engine");
	}

	public void slowEngine()
	{
		System.out.println("Slow engine");
	}

	public void stopEngine()
	{
		System.out.println("Stop engine");
	}

	//...
}
/*----------------------------------------------------------------------------------------------------------------------
	A ile B arasındaki association ilişkisinin bir implementasyonu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A x = new A(/*...*/);
		B b1 = new B(/*...*/);

		x.doSomething(b1);

		//...

		B b2 = new B(/*...*/);

		x.doSomething(b2);
	}
}

class A {
	//...
	public void doSomething(B b)
	{
		//...
		b.doWork();
		//...
	}

	//...
}

class B {
	//...

	public void doWork()
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte Taxi ile Client ve Driver arasındaki ilişkileri inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Driver driver = new Driver("Ali Serçe", 100);
		Taxi taxi = new Taxi(driver/*...*/);

		Client client1 = new Client("secati", "Secati Şahin");

		taxi.take(client1);

		//...

		Client client2 = new Client("selami", "Selami Veli");

		taxi.take(client2);

		//...
	}
}

class Taxi {
	private Driver m_driver;
	//...

	public Taxi(Driver driver)
	{
		//...
		m_driver = driver;
	}

	public void take(Client client)
	{
		System.out.printf("Driver:%s%n", m_driver.toString());
		//...

		System.out.println("take!...");

		System.out.printf("Client:%s%n", client.getUsername());
	}

	//...
}

class Client {
	private String m_username;
	private String m_name;
	//...


	public Client(String username, String name)
	{
		m_username = username;
		m_name = name;
	}

	public String getUsername()
	{
		return m_username;
	}

	public void setUsername(String username)
	{
		m_username = username;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		m_name = name;
	}

	public String toString()
	{
		return String.format("Username:%s", m_username);
	}
	//...
}

class Driver {
	private String m_name;
	private int m_rating;

	//...

	public Driver(String name, int rating)
	{
		m_name = name;
		m_rating = rating;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		m_name = name;
	}

	public int getRating()
	{
		return m_rating;
	}

	public void setRating(int rating)
	{
		m_rating = rating;
	}

	public String toString()
	{
		return String.format("Name:%s, Rating:%d", m_name, m_rating);
	}

	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    21.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	A sınıfından B sınıfı türetilmiş olsun. Bu durumda A'ya B'nin taban sınıfı (base class), B'ye ise A'nın türemiş sınıfı (derived class)
	denir. Java'da base class yerine "super class", derived class yerine ise "sub class" terimleri daha çok kullanılmaktadır.
	Ayrıca NYPT'de base class yerine parent class, derived class yerine child class terimleri de kullanılmaktadır. Bir
	dizi türetme durumunda yani örneğin A sınıfından B sınıfı, B sınıfından da C sınıfı türetilmiş olsun. Burada A sınıfı,
	B'nin super class'ı ya da direct super class'ıdır. A sınıfı C'nin indirect super class'ıdır. Bu anlamda super class
	dendiğinde direct super class anlaşılır. Bu durumda C'nin taban sınıf (super class) yani doğrudan taban sınıfı
	B'dir.  Şu cümle teknik olarak doğru değildir: "A, C'nin taban sınıfıdır". Cümlenin teknik olarak doğrusu şu şekilde
	yazılabilir: A, C'nin dolaylı taban sınıfıdır.

	Türetme işlemi ile bir sınıfın kodlarına dokunmadan sınıf genişletilebilir. Yani türemiş sınıf aslında taban sınıfın
	özelliklerini de içerecek şekilde yeni bir tür olarak bildirilmiş olur. Örneğin daha önce yazdığımız Circle sınıfı
	bir çemberi (ve daireyi) temsil eden bir sınıftır. Ancak bu sınıf analitik düzlemde bir çemberi temsil etmediği
	için merkez koordinatı yoktur. Analitik çemder de aslında çember olduğundan (is a) yani çember olma özelliklerini
	taşıdığından Circle sınıfından türetilebilir. Bu durumda Circle sınıfına ilişkin işlemler tekrar yazılmak ya da
	kopyalanmak zorunda kalmaz. Bu durumda aslında ortak özellikler taban sınıfta toplanabilmektedir. Türetme OCP'nin
	en net karşılığını vermektedir. Bu ilkenin tipik mottosu "open for extension, closed for modification"'dır. Bu durumda
	taban sınıfa dokunmadan onu genişletmek türetme ilişkisinin zaten hedefidir.

	Bu anlamda türetme ilişkisinde mantıksal olarak yukarıya doğru (türemiş sınıftan taban sınıfa doğru) bir genelleşme
	(generalization), mantıksal olarak aşağıya doğru (taban sınıftan türemiş sınıfa doğru) ise bir özelleşme (specialization)
	söz konusudur.

	Java'da bir sınıfın birden fazla taban sınıfı (doğrudan taban sınıfı) olamaz. Bu anlamda Java'da multiple inheritance
	yoktur. Programlamada tam anlamkıyla çoklu türetme ile çözülen bir problem yoktur. Kısmi olarak gerektiren durumlarda
	Java'da interface'ler ile gerçekleştirilebilmektedir. Interface'ler ileride detaylı olarak ele alınacaktır. Yani Java'da
	çoklu türetmenin olmaması bir eksiklik değildir. Örneğin Araç sınıfından Deniz Aracı, Hava Aracı ve Kara Aracı sınıfları
	türetilebilir. Deniz Uçağı bu hiyerarşide hem deniz aracı hem de hava aracı mıdır? Aslında deniz uçağı hava aracıdır
	ancak deniz aracı olma özelliklerinin tümünü gerçeklemez. Yani örneğin gemi gibi bir deniz aracı değildir. Deniz
	aracı olma davranışlarının bir kısmını yapabilir (yüzebilme). Bu anlamda aslında deniz uçağı deniz aracı olma
	özelliklerinin bir kısmını içerdiği için deniz aracı olarak ele alınmaz. Detaylar inteface'ler konsunda daha iyi
	anlaşılacaktır.

	Bir sınıf kendisinden doğrudan ya da dolaylı olarak türetilemez.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Türetme işlemi Java'da extends anahtar sözcüğü ile yapılır. Türetme işleminde taban sınıfın elemanları türemiş
	sınıfa aktarılmış olur. Örneğin taban sınıfta olan bir metot türemiş sınıfa da aktarılır. Benzer şekilde veri
	elemanları da taban sınıftan türemiş sınıfa aktarılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		C y = new C();

		x.foo();
		x.bar();
		y.foo();
		y.bar();
		y.tar();

		x.a = 10;
		x.b = 20;
		y.a = 23;
		y.b = 34;
		y.c = 45;
	}
}

class C extends B {
	public int c;
	public void tar()
	{
		System.out.println("C.tar");
	}
	//...
}

class B extends A {
	public int b;
	public void bar()
	{
		System.out.println("B.bar");
	}
	//...
}

class A {
	public int a;
	public void foo()
	{
		System.out.println("A.foo");
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Türetme ilişkisinde nesnesel bir kapsama söz konusudur. Bu ilişkide türemiş sınıf nesnesi içerisinde taban sınıf
	kadarlık bir bölüm de bulunur. Bu anlamda bakıldığında türemiş sınıfa eklenmiş non-static veri elemanları aslında
	taban sınıf nesnesini genişletmiş olur. Bu durumda türemiş sınıf nesnenin bellekte kapladığı alan en az taban sınıf
	nesnesinin uzunluğu + türemiş sınıfa eklenen non-static veri elemanlarının toplam uzunluğu kadardır. Aslında türemiş
	sınıfa eklenen veri elemanı ile nesne genişlemiş (extend) olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		C y = new C();

		x.a = 10;
		x.b = 20;
		y.a = 23;
		y.b = 34;
		y.c = 45;

		//...
	}
}

class C extends B {
	public int c;
	public void tar()
	{
		System.out.println("C.tar");
	}
	//...
}

class B extends A {
	public int b;
	public void bar()
	{
		System.out.println("B.bar");
	}
	//...
}

class A {
	public int a;
	public void foo()
	{
		System.out.println("A.foo");
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi bir nesnenin yaratılmasının tamamlanması için en son aşamada ilgili ctor'unun da çağrılması
	gerekir. Bu durumda türemiş sınıf nesnesi yaratıldığında içerisindeki taban sınıf nesnesinin da yaratılması yani
	taban sınıf nesnesi için de ilgili ctor'un çağrılması gerekir. Türemiş sınıf ctor'undan önce, türemiş sınıfın ctor'unda
	herhangi bir belirtme yapılmamışsa, taban sınıfın default ctor'u çağrılır. Yani aslında derleyici türemiş sınıfın
	ctor'unun başına gizlice taban sınıfın ctor çağrısı kodunu yerleştirir. Belirtmenin nasıl yapıldığı ileride ele
	alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		System.out.println("-------------------------------------");
		B y = new B(23);
		System.out.println("-------------------------------------");
		C z = new C();
		System.out.println("-------------------------------------");
		C t = new C(20);
		//...
	}
}

class C extends B {
	public C()
	{
		System.out.println("I am a default ctor of C");
	}

	public C(int a)
	{
		System.out.println("I am a ctor of C with parameter type: int");
	}
}

class B extends A {
	public B()
	{
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		System.out.println("I am a ctor of B with parameter type: int");
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type: int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Peki, taban sınıfın default ctor'u yoksa ya da var ama erişilemiyorsa ya da türemiş sınıfı yazan programcı taban
	sınıfın default ctor'u yerine istediği bir ctor'unu çağırmak isterse ne yapması gerekir? Bu durumda "super ctor sentaksı"
	kullanılır. super ctor sentaksı super anahtar sözcüğü ile birlikte metot çağırma operatörü kullanılarak ilgili argümanlar
	geçilerek ctor'un ilk deyimi olacak şekilde yerleştirilir. super ctor sentaksında hangi ctor'un çağrılacağı method
	overload resolution kurallarına göre belirlenir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		System.out.println("-------------------------------------");
		B y = new B(23);
		System.out.println("-------------------------------------");
		C z = new C();
		System.out.println("-------------------------------------");
		C t = new C(20);
		//...
	}
}

class C extends B {
	public C()
	{
		System.out.println("I am a default ctor of C");
	}

	public C(int a)
	{
		super(a);
		System.out.println("I am a ctor of C with parameter type: int");
	}
}

class B extends A {
	public B()
	{
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		super(a);
		System.out.println("I am a ctor of B with parameter type: int");
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type: int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bu durumda bir ctor'un başında super() (dikkat argümen geçmeden) şeklinde yazılması ile hiç super ctor sentaksı
	kullanılmaması tamamen aynı anlamdadır. Yani derleyici adeta gizlice bu kodu ekler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		System.out.println("-------------------------------------");
		B y = new B(23);
		System.out.println("-------------------------------------");
		C z = new C();
		System.out.println("-------------------------------------");
		C t = new C(20);
		//...
	}
}

class C extends B {
	public C()
	{
		super();
		System.out.println("I am a default ctor of C");
	}

	public C(int a)
	{
		super(a);
		System.out.println("I am a ctor of C with parameter type: int");
	}
}

class B extends A {
	public B()
	{
		super();
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		super(a);
		System.out.println("I am a ctor of B with parameter type: int");
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type: int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	super ctor sentaksına ilişkin deyimin ctor'un ilk deyimi olması gerekir. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
	public B()
	{
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		System.out.println("I am a ctor of B with parameter type: int");
		super(a); //error
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type: int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	super ctor sentaksı adından da anlaşılacağı gibi yalnızca ctor içerisinde kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
	public B()
	{
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
	    super(a);
		System.out.println("I am a ctor of B with parameter type: int");
	}

	public void foo(int a)
    {
        super(a); //error
    }
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type: int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf extends anahtar sözcüğü hiç bir sınıftan türetilmese de java.lang paketi içerisinde bulunan Object isimli
	sınıftan türetilmiş olur. Bu durumda Object sınıfı her sınıfın doğrudan ya da dolaylı taban sınıfıdır. Böyle bir
	tasarımın yani Object sınıfının anlamı ileride ele alınacaktır. Object sınıfı extends ile yazılabilir, yazılmasa da
	aynı anlamda olduğundan yazmamayı tercih edeceğiz. Bu durumda Java'da taban sınıfı olmayan tek sınıf Object sınıfıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A extends Object{
	//...
}

class B {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi nitelikli ve niteliksiz isim arama genel kurallarında bir isim sınıf içerisinde aranıyorsa ve
	bulunamadıysa taban sınıfa, yoksa onun taban sınıfına ... bakılır. Hiç birinde yoksa bu adımda bulunamamış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B();
		C y = new C();

		x.foo();
		x.bar();
		y.foo();
		y.bar();
		y.tar();

		x.a = 10;
		x.b = 20;
		y.a = 23;
		y.b = 34;
		y.c = 45;
	}
}

class C extends B {
	public int c;
	public void tar()
	{
		System.out.println("C.tar");
	}
	//...
}

class B extends A {
	public int b;
	public void bar()
	{
		System.out.println("B.bar");
	}
	//...
}

class A {
	public int a;
	public void foo()
	{
		System.out.println("A.foo");
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi sınıfın protected bölümü friendly sınıflar için public, farklı paketteki sınıflar için türetme
    söz konusu değilse private anlamındadır. Ancak türetme söz konusu ise protected bölüme erişim aşağıdaki gibi yine
    yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package mest;

import test.A;

public class B extends A {
    public void bar()
    {
        A a = new A(); //error

        a.a = 10; //error
        a.foo(); //error
    }
}

package test;

public class A {
    protected int a;

    protected A()
    {

    }

    protected void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıf farklı paketteki bir sınıftan türetilmişse, sınıfın mantıksal olarak kendisine ait olan protected bölüme
    erişebilir
----------------------------------------------------------------------------------------------------------------------*/
package mest;

import test.A;

public class B extends A {
    public B(int a)
    {

    }

    public void bar()
    {
        a = 20;
        foo();
    }
}

package test;

public class A {
    protected int a;

    protected A()
    {

    }

    protected void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    27.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıfın ctor'undan başka bir ctor'unun çağrılabilmesi için this ctor sentaksı kullanılır. this ctor sentaksı
	sentaks olarak super ctor sentaksına benzer. this ctor sentaksı da ctor'un ilk deyimi olmalıdır. this ctor sentaksı
	yalnızca ctor içerisinde kullanılabilir. Bu sentaksda da hangi ctor'un çağrılacağı overload resolution kurallarına
	göre belirlenir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		new A();
		System.out.println("---------------------------------------------");
		new A(10);
		System.out.println("---------------------------------------------");
		new A(10.);
		System.out.println("---------------------------------------------");
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		this();
		System.out.println("I am a ctor of A with parameter type int");
	}

	public A(double a)
	{
		this((int)a);
		System.out.println("I am a ctor of A with parameter type double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	this ctor sentaksında döngüsel durum geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A {
	public A() //error
	{
		this(0);
		System.out.println("I am a default ctor of A");
	}

	public A(int a) //error
	{
		this();
		System.out.println("I am a ctor of A with parameter type int");
	}

	public A(double a) //error
	{
		this(a);
		System.out.println("I am a ctor of A with parameter type double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	this ctor sentaksı ve super ctor sentaksı aynı ctor'da kullanılamaz. Her ikisinin de ctor'un ilk deyimi olması
	gerektiğinden errotr oluşur. Aslında böylesi bir ihtiyacın iyi bir tasarımda olmaması gerekir. Programcı böyle bir
	işlem gerektiğinde tasarımına ve koduna bakmalı ve uygun şekilde yazmalıdır. Kısacası böyle bir duruma ihtiyaç
	olmamalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A {
	public B()
	{
		System.out.println("I am a default ctor of B");
	}

	public B(int a)
	{
		this();
		super(a); //error

		System.out.println("I am a ctor of B with parameter type int");
	}
}

class A {
	public A()
	{
		System.out.println("I am a default ctor of A");
	}

	public A(int a)
	{
		System.out.println("I am a ctor of A with parameter type int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    AnalyticalCircle sınıfı
    Bir sınıf, private olarak referansını tuttuğu bir sınıfın metodunu aynı isimde ve genel olarak aynı yapıda public
    bölümde bildirdiğinde, bildirilen metoda delagate/pass through/forwarding method denir. AnalyticalCircle sınıfında
    getX, getY, setX, setY ve offset metotları delagate metotlardır
----------------------------------------------------------------------------------------------------------------------*/
package com.baturhansahin.math.test;

import com.baturhansahin.math.AnalyticalCircle;

import java.util.Random;
import java.util.Scanner;

public class AnalyticalCircleCtorTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);
            double x = random.nextDouble(-1000, 1000);
            double y = random.nextDouble(-1000, 1000);

            System.out.println("--------------------------------------------------");
            System.out.printf("Generated radius:%f, (%f, %f)%n", radius, x, y);
            AnalyticalCircle c = new AnalyticalCircle(radius, x, y);
            System.out.printf("(%f, %f),%s%n", c.getX(), c.getY(), c.toString());
            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package com.baturhansahin.math.test;

import com.baturhansahin.math.AnalyticalCircle;

import java.util.Random;
import java.util.Scanner;

public class AnalyticalCircleSetterTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        AnalyticalCircle c = new AnalyticalCircle();

        System.out.printf("(%f, %f),%s%n", c.getX(), c.getY(), c.toString());
        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);
            double x = random.nextDouble(-1000, 1000);
            double y = random.nextDouble(-1000, 1000);

            System.out.println("--------------------------------------------------");
            System.out.printf("Generated radius:%f, (%f, %f)%n", radius, x, y);
            c.setRadius(radius);
            c.setCenter(x, y);
            System.out.printf("(%f, %f),%s%n", c.getX(), c.getY(), c.toString());
            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package com.baturhansahin.math.test;

import com.baturhansahin.math.AnalyticalCircle;

import java.util.Random;
import java.util.Scanner;

public class AnalyticalCircleOffsetTest {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        Random random = new Random();

        System.out.print("Bir sayı giriniz:");
        int count = kb.nextInt();

        for (int i = 0; i < count; ++i) {
            double radius = random.nextDouble(-10, 11);
            double x = random.nextDouble(-1000, 1000);
            double y = random.nextDouble(-1000, 1000);
            double dx = random.nextDouble(-100, 100);
            double dy = random.nextDouble(-100, 100);

            System.out.println("--------------------------------------------------");
            System.out.printf("Generated radius:%f, (%f, %f), dx = %f, dy = %f%n", radius, x, y, dx, dy);
            AnalyticalCircle c = new AnalyticalCircle(radius, x, y);

            System.out.printf("(%f, %f),%s%n", c.getX(), c.getY(), c.toString());
            c.offset(dx, dy);
            System.out.printf("(%f, %f),%s%n", c.getX(), c.getY(), c.toString());
            System.out.println("--------------------------------------------------");
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package com.baturhansahin.math.test;

import com.baturhansahin.math.AnalyticalCircle;

public class AnalyticalCircleIsTangentTest {
    public static void run()
    {
        AnalyticalCircle ac1 = new AnalyticalCircle(3, 200, 100);
        AnalyticalCircle ac2 = new AnalyticalCircle(2, 196, 103);

        System.out.println(ac1.centerDistance(ac2));

        System.out.println(ac1.isTangent(ac2) ? "Teğet" : "Teğet değil");
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*--------------------------------------------------------
	FILE NAME	: AnalyticalCircle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 27th January 2024

	AnalyticalCircle class that represents a circle
	in cartesian plane

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package com.baturhansahin.math;

import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.MutablePoint;

public class AnalyticalCircle extends Circle {
    private static final double DELTA = 0.00000000001;
    private final MutablePoint m_center;

    public AnalyticalCircle()
    {
        this(0);
    }

    public AnalyticalCircle(double radius)
    {
        this(radius, 0, 0);
    }

    public AnalyticalCircle(double x, double y)
    {
        this(0, x, y);
    }

    public AnalyticalCircle(double radius, double x, double y)
    {
        super(radius);
        m_center = MutablePoint.createCartesian(x, y);
    }

    public double getX()
    {
        return m_center.getX();
    }

    public void setX(double x)
    {
        m_center.setX(x);
    }

    public double getY()
    {
        return m_center.getY();
    }

    public void setY(double y)
    {
        m_center.setY(y);
    }

    public void setCenter(double x, double y)
    {
        setX(x);
        setY(y);
    }

    public void offset(double dxy)
    {
        offset(dxy, dxy);
    }

    public void offset(double dx, double dy)
    {
        m_center.offset(dx, dy);
    }

    public double centerDistance(AnalyticalCircle other)
    {
        return m_center.distance(other.m_center);
    }

    public boolean isTangent(AnalyticalCircle other)
    {
        return Math.abs(centerDistance(other) - getRadius() - other.getRadius()) < DELTA;
    }
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aralarında türetme ilişkisi olmayan iki sınıf türünden referans birbirine explicit olarak bile dönüştürülemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		B b;

		b = (B)a; //error
	}
}

class A {
	//...
}

class B {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Türemiş sınıf türünden bir referans taban sınıf türünden bir referansa doğrudan (implicit) atanabilir. Bu kavrama
	"upcasting" denir. Upcasting işleminde taban sınıf referansına, türemiş sınıf nesnesine ait olan taban sınıf nesnesinin
	adresi atanır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		B x = new B(10, 20);
		A y;

		y = x; //upcasting

		System.out.printf("x.a = %d, x.b = %d%n", x.a, x.b);
		System.out.printf("y.a = %d%n", y.a);

		++y.a;

		System.out.printf("x.a = %d, x.b = %d%n", x.a, x.b);
		System.out.printf("y.a = %d%n", y.a);
	}
}

class A {
	public int a;
	public A(int x)
	{
		a = x;
	}
	//...
}

class B extends A {
	public int b;
	public B(int x, int y)
	{
		super(x);
		b = y;
	}
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte Sample sınıfının doWork metodu A sınıfından doğrudan ya da dolaylı olarak türetilmiş bir sınıf
	türünden referans ile çağrılabilir. Bu anlamda doWork metodu türden bağımsız (type independent) olarak yani yalnızca
	A türüne bağımlı olarak yazılmıştır. doWork metodunun A hiyerarşisine ilişkin diğer türlere derleme aşamasında
	bağımlılığı yoktur. Bu durumda hiyerarşiye yeni bir tür eklendiğinde doWork metodunun kodlarında değişiklik yapılması
	gerekmez.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Sample s = new Sample();
		A a = new A();
		B b = new B();
		C c = new C();
		D d = new D();
		E e = new E();
		F f = new F();

		s.doWork(a);
		s.doWork(b);
		s.doWork(c);
		s.doWork(d);
		s.doWork(e);
		s.doWork(f);
	}
}

class Sample {
	//...
	public void doWork(A x)
	{
		//...
		System.out.println(x.a);
	}
}

class F extends D {
	//...
}

class E extends C {
	//...
}

class D extends A {
	//...
}

class C extends B {
	//...
}

class B extends A {
	//...
}

class A {
	public int a;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıda yazılan demo örnekteki türden bağımsızlığa dikkat ediniz. A hiyerarşisine yeni bir tür eklendiğinde, yeni
	türün sisteme dahil olması için hangi kodlarda değişiklik yapılmalıdır?
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		Sample s = new Sample();
		AFactory factory = new AFactory();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();

		for (int i = 0; i < count; ++i) {
			A a = factory.create();

			s.doWork(a);
			//....
		}
	}
}

class Sample {
	//...
	public void doWork(A x)
	{
		//...
		System.out.println(x.a);
	}
}

class AFactory {
	private final Random m_random = new Random();

	public A create()
	{
		return switch (m_random.nextInt(6)) {
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			case 4 -> new F();
			default -> new A();
		};
	}
}

class F extends D {
	//...
}

class E extends C {
	//...
}

class D extends A {
	//...
}

class C extends B {
	//...
}

class B extends A {
	//...
}


class A {
	public int a;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir referansın iki tane türü vardır: static, dynamic.
	static type: Referansın bildirildiği türdür. Derleme zamanına ilişkindir. Değişmez. Referansın türü dendiğinde
	static tür anlaşılır

	dynamic type: Referansın gösterdiği adresteki nesnenin gerçek türüdür. Çalışma zamanına ilişkindir. Değişebilir.

	Anahtar Notlar: Bir referansın dinamik türününün fully qualified bir biçimde yazı olarak (String) elde edilebimesi
	için aşağıdaki kalıp kullanılabilir:
		<referans>.getClass().getName();
	Kalıbın detayının şu aşamada önemi yoktur.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		AFactory factory = new AFactory();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		A x;

		for (int i = 0; i < count; ++i) {
			x = factory.create();

			System.out.printf("Dynamic Type:%s%n", x.getClass().getName());
			//....
		}
	}
}

class AFactory {
	private final Random m_random = new Random();

	public A create()
	{
		return switch (m_random.nextInt(6)) {
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			case 4 -> new F();
			default -> new A();
		};
	}
}

class F extends D {
	//...
}

class E extends C {
	//...
}

class D extends A {
	//...
}

class C extends B {
	//...
}

class B extends A {
	//...
}


class A {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Object sınıfı doğrudan ya da dolaylı olarak her sınıfın taban sınıfı olduğuna göre her türden referans Object türden
	bir referansa doğrudan atanabilir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		ObjectFactory factory = new ObjectFactory();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		Object x;

		for (int i = 0; i < count; ++i) {
			x = factory.create();

			System.out.printf("Dynamic Type:%s%n", x.getClass().getName());
			//....
		}
	}
}

class ObjectFactory {
	private final Random m_random = new Random();

	public Object create()
	{
		return switch (m_random.nextInt(6)) {
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			case 4 -> new F();
			default -> new A();
		};
	}
}

class F extends D {
	//...
}

class E extends C {
	//...
}

class D extends A {
	//...
}

class C extends B {
	//...
}

class B extends A {
	//...
}


class A {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    28.01.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Taban sınıf türünden bir referans türemiş sınıf türünden bir referansa implicit olarak dönüşemez ancak explicit olarak
	dönüşebilir. Bu kavrama downcasting denir. Aslında tür dönüştürme operatörü derleme işlemini geçmek içindir. Çalışma
	zamanında kaynak referansın dinamik türünün tür dönüştürme operatörüne yazılan türü kapsayıp kapsamamasına bakılır.
	Buradaki kapsama nesnesel kapsamadır. Eğer kapsıyorsa haklı dönüşümdür akış devam eder, kapsamıyorsa haksız dönüşümdür
	ve exception oluşur. Aşağıdaki demo örnekte B, C ve E dışındaki dinamik türler için haksız dönüşümden dolayı exception
	oluşur. Örneği çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		ObjectFactory factory = new ObjectFactory();

		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		A x;
		B y;

		for (int i = 0; i < count; ++i) {
			x = factory.create();

			System.out.printf("Dynamic Type:%s%n", x.getClass().getName());

			y = (B)x;
			//...
		}
	}
}

class ObjectFactory {
	private final Random m_random = new Random();

	public A create()
	{
		return switch (m_random.nextInt(6)) {
			case 0 -> new B();
			case 1 -> new C();
			case 2 -> new D();
			case 3 -> new E();
			case 4 -> new F();
			default -> new A();
		};
	}
}

class F extends D {
	//...
}

class E extends C {
	//...
}

class D extends A {
	//...
}

class C extends B {
	//...
}

class B extends A {
	//...
}


class A {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte çalışma zamanında tür tespiti yapılıp ilgili türe göre downcasting yapılarak işlem yapılmaktadır.
    Burada artık haksız dönüşüm olmaz ancak programcı tür isimlerini hatalı olarak yazdığında ilgili tür tespit edilemeyebilir.
    Ayrıca yazı karşılaştırma görece yavaş bir işlemdir. Örneği çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.primitive.wrapper.IntValue;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            if (typeStr.equals("org.csystem.primitive.wrapper.IntValue")) {
                IntValue iVal = (IntValue)object;
                int val = iVal.getValue();

                System.out.printf("%d * %d = %d%n", val, val, val * val);
            }
            else if (typeStr.equals("java.lang.String")) {
                String str = (String)object;

                System.out.printf("%s, %s%n", str, str.toUpperCase());
            }
            else if (typeStr.equals("org.csystem.math.geometry.Point")) {
                Point p = (Point)object;

                System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
            }
            else if (typeStr.equals("org.csystem.math.geometry.Circle")) {
                Circle c = (Circle)object;

                System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
            }
            else if (typeStr.equals("org.csystem.math.Complex")) {
                Complex z = (Complex)object;

                System.out.printf("Conjugate:%s%n", z.conjugate().toString());
            }

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Çalışma zamanında tür tespiti için instanceof operatörü kullanılabilir. Bu operatör iki operandlı, araek durumunda
    özel amaçlı bir operatördür. Operatörün birinci operandı bir referans olmalıdır, ikinci operandı ise bir referans
    türü olmalıdır. Operatör birinci operandına ilişkin referansın dinamik türü ikinci operandına ilişkin türü kapsıyorsa
    true, kapsamıyorsa false değerini üretir. Bu operatör downcasting işlemlerinde kullanılabilir. Yukarıdaki demo
    örnek aşağıdaki gibi instanceof operatörüyle yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.primitive.wrapper.IntValue;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            if (object instanceof IntValue) {
                IntValue iVal = (IntValue)object;
                int val = iVal.getValue();

                System.out.printf("%d * %d = %d%n", val, val, val * val);
            }
            else if (object instanceof String) {
                String str = (String)object;

                System.out.printf("%s, %s%n", str, str.toUpperCase());
            }
            else if (object instanceof Point) {
                Point p = (Point)object;

                System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
            }
            else if (object instanceof Circle) {
                Circle c = (Circle)object;

                System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
            }
            else if (object instanceof Complex) {
                Complex z = (Complex)object;

                System.out.printf("Conjugate:%s%n", z.conjugate().toString());
            }

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 14 ile birlikte "instanceof pattern" kavramı dile eklenek instanceof operatörü ve downcasting kullanımı
    basitleştirilmiştir. instanceof pattern ile downcasting işlemine ilişkin kodu derleyici üretir. Yukarıdaki
    demo örnek aşağıdaki gibi instanceof operatörüyle yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.primitive.wrapper.IntValue;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            if (object instanceof IntValue iVal) {
                int val = iVal.getValue();

                System.out.printf("%d * %d = %d%n", val, val, val * val);
            }
            else if (object instanceof String str)
                System.out.printf("%s, %s%n", str, str.toUpperCase());
            else if (object instanceof Point p)
                System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
            else if (object instanceof Circle c)
                System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
            else if (object instanceof Complex z)
                System.out.printf("Conjugate:%s%n", z.conjugate().toString());

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Java 17 ile birlikte switch pattern dile eklenmiştir. Aslında Java 17 ile birlikte preview olarak dile eklenmiştir.
    Daha sonraki sürümler için doğrudan kullanılabilir hale gelmiştir. switch pattern ile bir referansın ilgili türü
    kapsayıp kapsamadığı kontrol edilebilir. switch expression bu işlemi instanceof operatörü ile aynı şekilde yapar. Bu
    durumda switch expression'ın default case kısmı olmak zorundadır. Yukarıdaki demo örnek aşağıdaki gibi instanceof
    operatörüyle yazılabilir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.primitive.wrapper.IntValue;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            switch (object) {
                case IntValue iVal -> {
                    int val = iVal.getValue();

                    System.out.printf("%d * %d = %d%n", val, val, val * val);
                }
                case String str -> System.out.printf("%s, %s%n", str, str.toUpperCase());
                case Point p -> System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
                case Circle c -> System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
                case Complex z -> System.out.printf("Conjugate:%s%n", z.conjugate().toString());
                default -> {}
            }

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.primitive.wrapper.IntValue;
import org.csystem.util.string.StringUtil;

import java.util.Random;

public class ObjectArrayGenerator {
    private final Random m_random = new Random();

    //String, IntValue, Point, Circle, Complex
    private Object createObject()
    {
        return switch (m_random.nextInt(5)) {
            case 0 -> StringUtil.generateRandomTextTR(m_random, m_random.nextInt(5, 11));
            case 1 -> IntValue.of(m_random.nextInt(-128, 127));
            case 2 -> Point.createCartesian(m_random.nextDouble(-100, 100), m_random.nextDouble(-100, 100));
            case 3 -> new Circle(m_random.nextDouble(-10, 10));
            default -> new Complex(m_random.nextDouble(-10, 10), m_random.nextDouble(-10, 10));
        };
    }

    public Object [] createObjects(int count)
    {
        Object[] objects = new Object[count];

        while (count-- > 0)
            objects[count] = createObject();

        return objects;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Programlamada (dilin desteği de olması koşuluyla) çalışma zamanında tür bilgisinin elde edilmesi
    kavramına gene olarak "Runtime Type Information (RTTI)" denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan Sınıflar (Wrapper Classes): JavaSE'de her temel türe karşılık bir sınıf bulundurulmuştur. Bu sınıflara
    "wrapper/platform classes" denilmektedir. Bu sınıfların sarmalama dışında ilgili temel türe ilişkin pek çok yararlı
    elemanı bulunur. Sarmalayan sınıflar ve ilişkin oldukları türler şu şekildedir:

    Temel Tür           Sarmalayan sınıf
    short                   Short
    int                     Integer
    long                    Long
    byte                    Byte
    float                   Float
    double                  Double
    char                    Character
    boolean                 Boolean

    Sarmalayan sınıfların tipik özellikleri:
    - Bu sınıflar java.lang paketi içerisindedir.

    - Tamsayı ve gerçek sayı türlerine ilişkin sarmalayan sınıflar (Short, Integer, Long, Byte, Float, Double) java.lang.Number
    sınıfından türetilmiştir. Bu sınıflara "numeric classes" da denilmektedir.

    - Bu sınıfların Java 9 ile birlikte ctor'ları deprecated olmuştur ve aynı zamanda ileride silineceği söylenmiştir.
    Zaten ileride göreceğimiz nedenlerden dolayı Java 5'den itibaren bu sınıfların ctor'ları ile nesne yaratılması
    önerilmemektedir ve programcılar tarafından da ctor ile nesne yaratılmamaktadır. Nesne yaratma işlemi için valueOf
    factory metotları kullanılmaktadır.

    - Bu sınıflar ilgili temel türden bir değerin heap'de tutulması için kullanılırlar. Sarmalama zaten bu işleme denir.
    Temel türden bir değerin heap'de sarmalanarak tutulmasına "kutulama (boxing)", heap'de tutulan yani sarmalanan temel
    türden bir değerin elde edilmesine ise "kutu açma (unboxing)" denilmektedir.

    - Bu sınıflar immutable'dır. Yani kutuladıkları değer değiştirilemez.

    - Bu sınıflar kutuladıkları değerlere ilişkin ön bellek (cache) tutarak zaman ve bellek maliyetini minimize ederler.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Boolean sınıfı dışında kalan sarmalayan sınıfların BYTES ve SIZE public static ve final veri elemanları sırasıyla
	ilgili temel türün uzunluğunu byte ve bit cinsinden verir. Anımsanacağı gibi Java'da boolean türü dışında kalan tüm
	temel türlerin uzunlukları sistemden sisteme değişiklik göstermez. Programcı okunabilirlik açısından bu sabit
	elemanları kullanabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		System.out.printf("int:%d/%d bytes/bits%n", Integer.BYTES, Integer.SIZE);
		System.out.printf("long:%d/%d bytes/bits%n", Long.BYTES, Long.SIZE);
		System.out.printf("short:%d/%d bytes/bits%n", Short.BYTES, Short.SIZE);
		System.out.printf("byte:%d/%d bytes/bits%n", Byte.BYTES, Byte.SIZE);
		System.out.printf("float:%d/%d bytes/bits%n", Float.BYTES, Float.SIZE);
		System.out.printf("double:%d/%d bytes/bits%n", Double.BYTES, Double.SIZE);
		System.out.printf("char:%d/%d bytes/bits%n", Character.BYTES, Character.SIZE);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Boolean sınıfı dışında kalan sarmalayan sınıfların MIN_VALUE ve MAX_VALUE isimli public static ve final veri elemanları
	ilgili temel türe ilişkin en küçük ve en büyük değerleri elde etmek için kullanılabilir. Dikkat edilirse Float ve Double
	sınıflarının MIN_VALUE ve MAX_VALUE değerleri pozitiftir. Gerçek sayıların tutuluş formatına göre bu değerlerin
	her birininin negatif değerleri de sınırlara dahildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		System.out.printf("int:[%d, %d]%n", Integer.MIN_VALUE, Integer.MAX_VALUE);
		System.out.printf("long:[%d, %d]%n", Long.MIN_VALUE, Long.MAX_VALUE);
		System.out.printf("short:[%d, %d]%n", Short.MIN_VALUE, Short.MAX_VALUE);
		System.out.printf("byte:[%d, %d]%n", Byte.MIN_VALUE, Byte.MAX_VALUE);
		System.out.println("float:[" + Float.MIN_VALUE + ", " + Float.MAX_VALUE + "]");
		System.out.println("double:[+-" + Double.MIN_VALUE + ", +-" + Double.MAX_VALUE + "]");
		System.out.printf("char:[%d, %d]%n", (int)Character.MIN_VALUE, (int)Character.MAX_VALUE);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Character sınıfı dışından kalan sarmalayan sınıfların parseXXX metotları parametresi ile aldığı yazıyı ilgili
	temel türden değere çevirmeye çalışır. Boolean sınıfının parseBoolean metodu dışındaki diğer parseXXX metotları
	yazıyı ilgili türe çeviremezlerse exception oluşur. Boolean sınıfının parseBoolean metodu yazıyı çeviremediği durumda
	false değerine geri döner. true değeri için yazı case insensitive olarak true yazısıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		boolean result;

		System.out.print("True ya da false değerlerlerinden birini giriniz:");
		result = Boolean.parseBoolean(kb.nextLine());

		while (result) {
			System.out.printf("result:%b%n", result);
			System.out.print("True ya da false değerlerlerinden birini giriniz:");
			result = Boolean.parseBoolean(kb.nextLine());
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerine ilişkin sarmalayan sınıfların radix parametreli parseXXX metotları ilgili yazıyı verilen sayı
	sistemine göre ilgili türe çevirir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
	public static void main(String[] args)
	{
		Scanner kb = new Scanner(System.in);
		System.out.print("Hexadecimal bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine(), 16);

		System.out.printf("val = %d%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınıfların yukarıda anlatılanlar dışında da pek çok elemanı bulunur. Bunlar ihtiyaca göre incelenebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte sarmalayan sınıflara eklenen ilgili temel türden parametreli valueOf factory metotları ilgili
	türe ilişkin bir ön bellek kullanırlar. Örneğin tamsayı türlerine ilişkin sarmalayan sınıfların valueOf metotları
	[-128, 127] aralığındaki değerleri bir ön bellekten alır. Bu aralıktaki bir değer ilk sarmalandığında nesne yaratılır,
	diğer sarmalamalarda aynı nesnenin referansı elde edilir. Bu sınırlar dışında kalan değerler için ön bellek tutulup
	tutulmayacağı yazanlara bırakılmıştır. Derste yazdığımız IntValue sınıflarını inceleyiniz. Yine örneğin Character
	sınıfının valueOf metodu da ['\u0000', '\u007F'] aralığındaki karakterler için bir ön bellek tutar. Gerçek sayı
	türlerine ilişkin sarmalayan sınıfların valuOf metotları tutuluş formatına uygun olacak şekilde bir öm bellek
	tutar. Bu ön belleğin detayları verilmemiştir. Ancak tutulacağı garanti edilmiştir. Boolean sınıfının valueOf
	metodu da true ve false değerlerini bir ön bellekten alacağını garanti eder. Bu sınıfların ön bellek kullanmasındaki
	temel amaç "to yield significantly better space and time performance" içindir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Integer sınıfının valueOf metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Integer iVal1 = Integer.valueOf(127);
		Integer iVal2 = Integer.valueOf(127);
		Integer iVal3 = Integer.valueOf(128);
		Integer iVal4 = Integer.valueOf(128);

		System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(iVal3 == iVal4 ? "Aynı nesne" : "Farklı nesneler");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Character sınıfının valueOf metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Character c1 = Character.valueOf('D');
		Character c2 = Character.valueOf('D');
		Character c3 = Character.valueOf('Ş');
		Character c4 = Character.valueOf('Ş');

		System.out.println(c1 == c2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(c3 == c4 ? "Aynı nesne" : "Farklı nesneler");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Sarmalayan sınıfların xxxValue isimli metotları ile sarmalanan değer elde edilebilir. Numeric sınıfların xxxValue
    metotları Number sınıfından gelir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz. Örnekte temel türlere ilişkin değerler sarmalanarak (kutulanarak) ilgili adresler
    Object referansından tutulmuştur. Zaten kutulamanın genel anlamı da budur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            switch (object) {
                case Integer iVal -> {
                    int val = iVal.intValue();

                    System.out.printf("%d * %d = %d%n", val, val, val * val);
                }
                case String str -> System.out.printf("%s, %s%n", str, str.toUpperCase());
                case Point p -> System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
                case Circle c -> System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
                case Complex z -> System.out.printf("Conjugate:%s%n", z.conjugate().toString());
                case Boolean b -> System.out.println(b ? "Married" : "Single");
                case Character c -> System.out.printf("ch = %c%n", c);
                default -> {}
            }

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.util.string.StringUtil;

import java.util.Random;

public class ObjectArrayGenerator {
    private final Random m_random = new Random();

    //String, Integer, Point, Circle, Complex, Boolean, Character
    private Object createObject()
    {
        return switch (m_random.nextInt(7)) {
            case 0 -> StringUtil.generateRandomTextTR(m_random, m_random.nextInt(5, 11));
            case 1 -> Integer.valueOf(m_random.nextInt(-128, 127));
            case 2 -> Point.createCartesian(m_random.nextDouble(-100, 100), m_random.nextDouble(-100, 100));
            case 3 -> new Circle(m_random.nextDouble(-10, 10));
            case 4 -> Boolean.valueOf(m_random.nextBoolean());
            case 5 -> Character.valueOf((char)((m_random.nextBoolean() ? 'A' : 'a') + m_random.nextInt(26)));
            default -> new Complex(m_random.nextDouble(-10, 10), m_random.nextDouble(-10, 10));
        };
    }

    public Object [] createObjects(int count)
    {
        Object[] objects = new Object[count];

        while (count-- > 0)
            objects[count] = createObject();

        return objects;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 5 ile birlikte "auto boxing" ve "auto unboxing" kavramları da dile eklenmiştir. Bu anlamda temel türden bir ifade
	ilişkin olduğu sarmaklayan sınıf referansına veya Object referansına doğrudan atanabilir. Bu durumda derleyici valueOf
	metodunu çağıran yaklaşık kodu üretir. Buna "auto boxing" denir. Benzer şekilde ilgili sarmalayan sınıf türünden bir
	referans doğrudan ilişkin olduğu türden bir değişkene atanabilir. Bu durumda derleyici xxxValue metodunu çağıran
	yaklaşık kodu üretir. Buna da "auto unboxing" denir. Eğer Object referansından ilgili türe dönüşüm yapılacaksa tür
	dönüştürme operatörü kullanılır. Bu durumda derleyici, ilgili sarmalayan sınıf türüne downcasting yapılıp, xxxValue
	metodunu çağıran yaklaşık kodu üretir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Integer iVal1 = 127; // auto boxing: Integer.valueOf(127)
		Integer iVal2 = 127; // auto boxing: Integer.valueOf(127)
		Integer iVal3 = 128; // auto boxing: Integer.valueOf(128)
		Integer iVal4 = 128; // auto boxing: Integer.valueOf(128)

		System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(iVal3 == iVal4 ? "Aynı nesne" : "Farklı nesneler");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Object iVal1 = 127; // auto boxing: Integer.valueOf(127)
		Object iVal2 = 127; // auto boxing: Integer.valueOf(127)
		Object iVal3 = 128; // auto boxing: Integer.valueOf(128)
		Object iVal4 = 128; // auto boxing: Integer.valueOf(128)

		System.out.println(iVal1 == iVal2 ? "Aynı nesne" : "Farklı nesneler");
		System.out.println(iVal3 == iVal4 ? "Aynı nesne" : "Farklı nesneler");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		Integer iVal = 127; // auto boxing: Integer.valueOf(127)
		int val = iVal; // auto unboxing: iVal.intValue()

		System.out.println(val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Object iVal = 127; // auto boxing: Integer.valueOf(127)
        Object dVal = 3.4; // auto boxing: Double.valueOf(3.4)
        int a = (int)iVal; // auto unboxing: ((Integer)iVal).intValue()
        double b = (double)dVal; // auto unboxing: ((Double)dVal).doubleValue()

        System.out.printf("a = %d, b = %f%n", a, b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte auto boxing ve auto unboxing kullanılarak kod daha yalınlaştırılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;

import java.util.Scanner;

public class DemoObjectArrayGeneratorApp {
    private static void doForObjects(Object [] objects)
    {
        for (Object object : objects) {
            System.out.println("-----------------------------------------------------------------------------");
            String typeStr = object.getClass().getName();

            System.out.printf("Type:%s%n", typeStr);

            switch (object) {
                case Integer iVal -> {
                    int val = iVal;

                    System.out.printf("%d * %d = %d%n", val, val, val * val);
                }
                case String str -> System.out.printf("%s, %s%n", str, str.toUpperCase());
                case Point p -> System.out.printf("{x: %f, y: %f}%n", p.getX(), p.getY());
                case Circle c -> System.out.printf("{Radius:%f, Area:%f, Circumference:%f}%n", c.getRadius(), c.getArea(), c.getCircumference());
                case Complex z -> System.out.printf("Conjugate:%s%n", z.conjugate().toString());
                case Boolean b -> System.out.println(b ? "Married" : "Single");
                case Character c -> System.out.printf("ch = %c%n", c);
                default -> {}
            }

            System.out.println("-----------------------------------------------------------------------------");
        }
    }

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        ObjectArrayGenerator generator = new ObjectArrayGenerator();

        System.out.print("Input count:");
        int count = kb.nextInt();

        doForObjects(generator.createObjects(count));
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.generator;

import org.csystem.math.Complex;
import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;
import org.csystem.util.string.StringUtil;

import java.util.Random;

public class ObjectArrayGenerator {
    private final Random m_random = new Random();

    //String, Integer, Point, Circle, Complex, Boolean, Character
    private Object createObject()
    {
        return switch (m_random.nextInt(7)) {
            case 0 -> StringUtil.generateRandomTextTR(m_random, m_random.nextInt(5, 11));
            case 1 -> m_random.nextInt(-128, 127);
            case 2 -> Point.createCartesian(m_random.nextDouble(-100, 100), m_random.nextDouble(-100, 100));
            case 3 -> new Circle(m_random.nextDouble(-10, 10));
            case 4 -> m_random.nextBoolean();
            case 5 -> (char)((m_random.nextBoolean() ? 'A' : 'a') + m_random.nextInt(26));
            default -> new Complex(m_random.nextDouble(-10, 10), m_random.nextDouble(-10, 10));
        };
    }

    public Object [] createObjects(int count)
    {
        Object[] objects = new Object[count];

        while (count-- > 0)
            objects[count] = createObject();

        return objects;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    03.02.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte tür dönüştürme operatörüne yazılan tür long olduğundan derleyici yaklaşık olarak, Long sınıfına
	downcast yapılan kodu üretir. Bu da, örnekteki o referansının dinamik türü Integer olduğundan haksız dönüşümdür ve
	dolayısıyla exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Object o = 123;
        long a;

        System.out.println(o.getClass().getName());
        a = (long)o; //((Long)o).longValue()

        System.out.printf("a = %d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo örnek aşağıdaki gbi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Object o = 123;
        long a;

        System.out.println(o.getClass().getName());
        a = (int)o; //((Integer)o).intValue()

        System.out.printf("a = %d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte tür dönüştürme operatörünün sağdan sola ilişkili (right associative) olması özelliği kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Object o = 123;
        short a;

        System.out.println(o.getClass().getName());
        a = (short)(int)o; //(short)((Integer)o).intValue();

        System.out.printf("a = %d%n", a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Number sınıfının xxxValue metotları sarmalayan sınıflar için temel türler arasındaki tür dönüştürme kurallarına
    göre işlem yaparlar. Örneğin Long türden bir referans ile intValue metodu çağrıldığında long türünden int türüne
    yapılan explicit conversion kuralları geçerli olur. Yani sarmalanan long türden değerin yüksek anlamlı 4 byte'ı
    atılarak elde edilen 4 byte'lık değere geri dönülür. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Long lVal = 5_000_000_000L;
        long val = 5_000_000_000L;
        int a = lVal.intValue();
        int b = (int)val;

        System.out.printf("a = %d, b = %d%n", a, b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Garbage Collector: Programlamada heap'de tahsis edilen nesnelere genel olarak dinamik ömürlü nesneler denir. Bu
    anlamda heap'den yapılan tahsisatlara ise "dynamic memory allocation" denilmektedir. Stack'de tahsis edilen değişkenlere
    ise otomatik ömürlü değişkenler denir ve tahsis edilen alanlar otomatik olarak yaratılır ve yok edilir. Dinamik olarak
    yaratılan alanlar ise kullanımı bittikten sonra artık başka nesneler için de tahsis adilebilsin diye yok edilir. Bu
    yok etme işlemine "free" ya da "delete" etme işlemi denir. Heap'de tahsis edilen alanlar heap algoritması gereği
    stack gibi otomatik olarak yok edilmez. Bunu bazı programlama dillerinde ve ortamlarında programcı yapmak zorundadır.
    Java'da ise bu işlem "garbage collector (GC)" ayrı bir akış tarafından yapılır. Şüphesiz Java programıcısı açısından da
    bir otomatik yok etme söz konusudur ancak bu stack'teki gibi doğal olarak yapılmaz. Öyleyse GC için şu sorular
    sorulmalıdır:
    1. GC yok edilmesi gereken bir alanı nasıl anlayacaktır?
    2. Programcı dinamik olarak tahsis edilen bir alanı kendisi yok edebilir mi?
    3. Bir nesne yok edilebilir duruma geldiğinde GC hemen devreye girip bu alanı yok eder mi?

    Cevap 1: Bir nesneyi gösteren hiç bir referans kalmazsa bu durumda nesne "eligible/garbage collected" duruma gelir.
    Bir nesneyi gösteren referansların takip edilmesine yönelik pek çok algoritma kullanılmaktadır. Örneğin referans
    sayma (reference counting) algoritması her nesne için ayrı bir referans sayacı tutularak yapılır. Bu durumda nesnenin
    adresi bir referansa atandığında sayaç 1 artılır, nesne bir referanstan kopartıldığında sayaç 1 azaltılır. Bu durumda
    sayaç sıfıra düştüğünde artık hiç bir referans nesneyi göstermiyordur. Bu durumda artık nesne eligible duruma gelmiş
    olur.

    Cevap 2: Hayır. Programcı herhangi bir anda dinamik olarak tahsis edilmiş bir alanı yok edemez. Programcı akış içerisinde
    nesneyi eligible duruma getirir.

    Cevap 3: GC'nin ne zaman devreye gireceği yazanlara bırakılmıştır (implementation defined). Bu durumda bir nesne
    eligible olur olmaz GC'nin devreye gireceği garanti olmadığından nesnenin eligible olur olmaz yok edileceği de
    garanti değildir. Bu anlamda GC'nin etkinliğine güvenilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte reference counting yöntemi kullanıldığı varsayımıyla referansların takibi gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(); //rc1:1

        Mample.foo(s); //rc1:2 -> 3
        //rc1:1
        s = new Sample(); //rc1:0 (eligible), rc2:1
    }
}


class Mample {
    public static void foo(Sample s)
    {
        Sample k;

        k = s;

        //...
    }
}
class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Programcı isterse GC'nin devreye girmesini sağlayabilir. Bunu yapmanın birden fazla yöntemi olsa da tipik olarak
    System sınıfının gc metodu çağrılabilir. Ancak burada GC'nin programcı tarafından devreye sokulması çoğu zaman
    gerekmez. Bu anlamda GC'nin etkinliğine güvenilir. GC'nin sürekli ya da gereksiz yere devreye sokulması da performansı
    olumsuz etkileyebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(); //rc1:1

        Mample.foo(s); //rc1:2 -> 3
        //rc1:1
        s = new Sample(); //rc1:0 (eligible), rc2:1

        System.gc();
    }
}

class Mample {
    public static void foo(Sample s)
    {
        Sample k;

        k = s;

        //...
    }
}
class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi "null address" belleğin kullanılmayan adresidir. null adress Java'da null sabiti ile temsil edilir.
    null adresin kullanımına yönelik tipik durumlar şunlardır:
    - Kontrol amaçlı kullanılabilir. Örneğin bir referansın null olması durumuna göre işlem yapılabilir.

    - Bir metodun geri dönüş değeri bir referans ise ve metot akışına göre bir nesnenin referansına dönülemiyorsa
    null adrese geri dönülebilir. Örneğin, bir takım bilgilere göre arama işlemi yapan bir metot bilgilere ilişkin
    nesne bulunamıyorsa null değerine geri dönebilir.

    - Bir referansa derleyici açısında değer atanması gerekiyorsa ancak bir nesnenin adresi atanamıyorsa, null adres
    atanabilir. Bir sonraki demo örneği inceleyiniz

    Bu kullanımlar dışında da kullanım söz konusu olabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte * ile belirtilen noktada s'ye null değeri atanmazsa, ** ile belirtilen noktada error oluşur.
    Çünkü içerisine değer atanmayan bir değişkenin kullanımı error oluşturur. Derleyici de örnekteki switch deyiminde
    case bölümlerinden herhangi biri değeri yakalamazsa s'ye değer atanamaz düşüncesiyle error verecektir. Derleyici
    ilgili algoritmayı takip edip zaten her durumda bir case bölümünün yakalayacağını anlamaya çalışmaz. Bu durumda
    s referansına null değeri atanarak programcı bu hatadan kurtulmuş olur. Şüphesiz demo örneğimiz farklı yöntemlerle de
    yapılabilir. Burada null referansın kullanımına odaklanınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        int value = kb.nextInt();

        if (value < 3 || value > 5) {
            System.out.println("Geçersiz değer girdiniz!...");
            System.exit(1);
        }

        Sample s = null; //*

        switch (value) {
            case 3 -> s = new Sample(10);
            case 4 -> s = new Sample(20);
            case 5 -> s = new Sample(30);
        }

        System.out.println(s.getX()); //**
    }
}

class Sample {
    private int m_x;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        m_x = x;
    }

}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağı seviyede non-static metot kavramı yoktur. Tüm metotlar adeta static metotmuş gibi (aslında global fonksiyonlar
    olarak) ele alınır. Bu durumda non-static bir metodun aşağı seviyede ele alınabilmesi için o metodu çağıran referansın
    adresi türünden bir parametre değişkenine daha sahip olması gerekir. Bu durumda aslında aşağı seviyede non-static
    bir metodun ait olduğu sınıf türünden +1 tane referans parametresi vardır. Bu durumda non-static bir metot çağrısı da
    aşağı seviyede, metodun çağrılmasında kullanılan referansın, metodun aşağı seviyedeki karşılığına argüman olarak
    geçilmesi yoluyla yapılır. Anımsanacağı gibi ctor'da aslında non-static bir metottur. Aşağı seviyede ctor kavramı da
    olmadığından aslında ctor'da bir metot olarak ele alınır. Genel olara bu metodun ismi "init"'dir. Bu metoda da aslında
    aşağı seviyede +1 tane parametre geçilir. Aşağıdaki demo örnekte getX ve setX metotlarının aşağı seviyedeki yaklaşık
    karşılıkları yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(10);

        System.out.printf("Value:%d%n", s.getX());

        //Yukarıdaki getX çağrısının aşağı seviyedeki yaklaşık karşılığı
        System.out.printf("Value:%d%n", Sample.getX(s));

        s.setX(20);

        //Yukarıdaki setX çağrısının aşağı seviyedeki yaklaşık karşılığı
        Sample.setX(s, 20);
    }
}

class Sample {
    private int m_x;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX()
    {
        return m_x;
    }

    //getX non-static metodunun aşağı seviyedeki yaklaşık karşılığı
    public static int getX(Sample self)
    {
        return self.m_x;
    }

    public void setX(int x)
    {
        m_x = x;
    }

    //setX non-static metodunun aşağı seviyedeki yaklaşık karşılığı
    public static void setX(Sample self, int x)
    {
        self.m_x = x;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Non-static metoda gizlice geçirilen bu adrese metot içerisinde this anahtar sözcüğü ile erişilebilir. this, ilgili
    sınıf türünden bir referanstır ve metodun çağrılmasında kullanılan referansın gösterdiği nesnenin adresini temsil
    eder. Bu anlamda non-static bir metoda this geçirilir diyebiliriz. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample(10);

        System.out.printf("Value:%d%n", s.getX());
        s.setX(20);
    }
}

class Sample {
    private int m_x;

    public Sample(int x)
    {
        this.setX(x);
    }

    public int getX()
    {
        return this.m_x;
    }

    public void setX(int x)
    {
        this.m_x = x;
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    static metotlara this geçirilmez. Yani static bir metot içerisinde this referansı kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    private static int ms_x;
    public static void foo(int x)
    {
        this.ms_x = x; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    this aslında bir sabittir. Yani this referansı atama operatörünün solunda olamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    private int m_x;

    public Sample(int x)
    {
        this.setX(x);
    }

    public int getX()
    {
        return this.m_x;
    }

    public void setX(int x)
    {
        this = new Sample(10); //error
        this.m_x = x;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Biz genel olarak okunabilirliği etkilemediği sürece zorunlu durumlar dışında this kullanmamayı
    tercih edeceğiz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    this referansının kullanılması gerektiği durumlar olabilir. Örneğin sınıfın non-static veri elemanı ile aynı isimde
    bir parametre değişkenine sahip bir non-static metodu içerisinde ilgili veri elemanına erişmek için qualified olarak
    this referansı kullanılması gerekir. Aksi durumda yani unqualified kullanımda isim arama genel kurallarına göre
    parametre değişkeni kullanılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    private int x;

    public Sample(int x)
    {
        this.x = x;
    }

    public void setX(int x)
    {
        this.x = x;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    04.02.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bazı sınıfların metotlarının peşpeşe çağrılması çoğu zaman gerekli olabilir. Bu durumda programcının ilgili metotları
    bir zincir biçiminde çağırabilmesi için metotların çağıran referansa geri dönmesi gerekir. Örneğin StringBuilder
    sınıfının pek çok metodu bu şekilde çağrılabilmektedir. Bu durumda bu tarz metotların this referansına geri dönmesi
    gerekir. Bu tarz çağrıların yapılabildiği kalıba "fluent pattern" denilmektedir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        Scanner kb = new Scanner(System.in);
        StringBuilder sb = new StringBuilder();

        System.out.print("Bir yazıyı giriniz:");
        String s = kb.nextLine();

        System.out.print("Bir Sayı giriniz:");
        int count = Integer.parseInt(kb.nextLine());

        for (int i = 0; i < count; ++i)
            sb.append('[').append(s).append(']');

        System.out.printf("Yazı:%s%n", sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java'da bir sınıf default olarak türetmeye açıktır. Sınıfın türetmeye kapatılması için final olarak bildirilmesi
    gerekir. final olarak bildirilen bir sınıftan türetme yapmak error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B extends A { //error

}

final class A {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Her zaman olmasa da bazı durumlarda immutable sınıflar türetmeye kapatılabilir. Aslında bu durumun immutable olmakla
    her zaman doğrudan ilişkisi yoktur. Örneğin String sınıfı final olarak bildirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class StringEx extends String { //error
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi utility sınıfların ctor'ları bir convention olarak private yapılır. Zaten utility sınıfların
    non-static elemanları (member) olmaz. Bu durumda bu tarz sınıfların final yapılması da bir convention'dır. Örneğin
    Arrays, Math gibi sınıflar final olarak bildirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Arrays;

class A extends Arrays { //error
    //...
}

class B extends Math { //error
    //...
}

/*--------------------------------------------------------
	FILE NAME	: StringUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Utility class for string operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.string;

import java.util.Random;

public final class StringUtil {
	private static final String LETTERS_EN = "abcdefghijklmnopqrstuvwxyz";
	private static final String LETTERS_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
	private static final String LETTERS_CAPITAL_EN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	private static final String LETTERS_CAPITAL_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
	private static final String LETTERS_ALL_EN = LETTERS_EN + LETTERS_CAPITAL_EN;
	private static final String LETTERS_ALL_TR = LETTERS_TR + LETTERS_CAPITAL_TR;

	private StringUtil()
	{
	}

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;

		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String generateRandomTextEN(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_EN);
	}

	public static String generateRandomTextTR(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_TR);
	}

	public static String generateRandomText(Random random, int count, String sourceText)
	{
		StringBuilder sb = new StringBuilder(count);
		int len = sourceText.length();

		for (int i = 0; i < count; ++i)
			sb.append(sourceText.charAt(random.nextInt(len)));

		return sb.toString();
	}

	public static String [] generateRandomTextsEN(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_EN);
	}

	public static String [] generateRandomTextsTR(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_TR);
	}

	public static String [] generateRandomTexts(Random random, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		for (int i = 0; i < count; ++i)
			texts[i] = generateRandomText(random, random.nextInt(min, bound), sourceText);

		return texts;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_EN);
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_TR);
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static String padLeading(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : String.valueOf(ch).repeat(newLen - s.length()) + s;
	}

	public static String padLeading(String s, int newLen)
	{
		return padLeading(s, newLen, ' ');
	}

	public static String padTrailing(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : s + String.valueOf(ch).repeat(newLen - s.length());
	}

	public static String padTrailing(String s, int newLen)
	{
		return padTrailing(s, newLen, ' ');
	}

	public static String reverse(String s)
	{
		return new StringBuilder(s).reverse().toString();
	}
}

/*--------------------------------------------------------
	FILE NAME	: NumberUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Utility class for numeric operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.numeric;

public final class NumberUtil {
	private NumberUtil()
	{
	}

	public static int [] digits(long val)
	{
		int [] result = new int[digitsCount(val)];
		val = Math.abs(val);

		for (int i = result.length - 1; i >= 0; result[i--] = (int)(val % 10), val /= 10)
			;

		return result;
	}

	public static int digitsCount(long val)
	{
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}

	public static int digitsCount(int val)
	{
		return digitsCount((long)val);
	}

	public static int digitsSum(int val)
	{
		int total = 0;

		while (val != 0) {
			total += val % 10;
			val /= 10;
		}

		return Math.abs(total);
	}

	public static int factorial(int n)
	{
		int result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;

		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}

		return result;
	}

	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}

	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}


	public static int mid(int a, int b, int c)
	{
		if (a <= b && b <= c || c <= b && b <= a)
			return b;

		if (b <= a && a <= c || c <= a && a <= b)
			return a;

		return c;
	}

	public static long nextClosestPrime(long val)
	{
		while (!isPrime(++val))
			;

		return val;
	}

	public static int nextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 1, prev2 = 0;

		while (true) {
			int next = prev1 + prev2;

			if (next > val)
				return next;

			prev2 = prev1;
			prev1 = next;
		}
	}

	public static int nthFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;

		int prev1 = 1, prev2 = 0, val = prev1 + prev2;

		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}

		return val;
	}


	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;

		while (true) {
			if (isPrime(val))
				++count;

			if (count == n)
				return val;

			++val;
		}
	}


	public static long previousClosestPrime(long val)
	{
		while (!isPrime(--val))
			;

		return val;
	}


	public static int reversed(int val)
	{
		int result = 0;

		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}

		return result;
	}
}

/*--------------------------------------------------------
	FILE NAME	: MatrixUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Utility class for matrix operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.matrix;

import org.csystem.util.array.ArrayUtil;

import java.util.Random;

public final class MatrixUtil {
    private MatrixUtil()
    {
    }

    public static int [][] add(int [][] a, int [][] b)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] total = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                total[i][j] = a[i][j] + b[i][j];

        return total;
    }

    public static void addBy(int [][] a, int val)
    {
        ArrayUtil.addBy(a, val);
    }

    public static int [][] subtract(int [][] a, int [][] b)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] total = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                total[i][j] = a[i][j] - b[i][j];

        return total;
    }

    public static void subtractBy(int [][] a, int val)
    {
        ArrayUtil.subtractBy(a, val);
    }

    public static void multiplyBy(int [][] a, int val)
    {
        ArrayUtil.multiplyBy(a, val);
    }

    public static int [][] generateRandomMatrix(Random random, int row, int col, int origin, int bound)
    {
        int [][] a = new int[row][col];

        ArrayUtil.fillRandomArray(random, a, origin, bound);

        return a;
    }

    public static int [][] generateRandomSquareMatrix(Random random, int n, int origin, int bound)
    {
        return generateRandomMatrix(random, n, n, origin, bound);
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[0].length != a[i].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static int [][] transpose(int [][] a)
    {
        int [][] t = new int[a[0].length][a.length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                t[j][i] = a[i][j];

        return t;
    }

    //...
}

/*--------------------------------------------------------
	FILE NAME	: ArrayUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Utility class for array operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.array;

import java.util.Random;

public final class ArrayUtil {
    private ArrayUtil()
    {}

    private static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    private static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    private static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    private static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void addBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] += val;
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void fillRandomArray(Random random, int [] a, int origin, int bound)
    {
        fillRandomArray(random, a, a.length, origin, bound);
    }

    public static void fillRandomArray(Random random, int [] a, int count, int origin, int bound)
    {
        for (int i = 0; i < count; ++i)
            a[i] = random.nextInt(origin, bound);
    }

    public static void fillRandomArray(Random random, int [][] a, int origin, int bound)
    {
        for (int [] array : a)
            fillRandomArray(random, array, origin, bound);
    }

    public static int [] generateRandomArray(Random random, int count, int origin, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, origin, bound);

        return a;
    }

    public static int [] generateRandomArray(int count, int origin, int bound)
    {
        return generateRandomArray(new Random(), count, origin, bound);
    }

    public static int [] histogramData(int [] a, int n)
    {
        int [] result = new int[n + 1];

        for (int val : a)
            ++result[val];

        return result;
    }

    public static boolean isEmpty(int [] a)
    {
        return a.length == 0;
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.max(val, result);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.min(val, result);

        return result;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] *= val;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        print(n, a, a.length);
    }

    public static void print(int [] a, int count)
    {
        print(1, a, count);
    }

    public static void print(int n, int [] a, int count)
    {
        print(n, a, count, " ", "\n");
    }

    public static void print(int [] a, int count, String sep, String end)
    {
        print(1, a, count, sep, end);
    }

    public static void print(int n, int [] a, int count, String sep, String end)
    {
        String fmt = String.format("%%0%dd%%s", n);

        for (int i = 0; i < count; ++i)
            System.out.printf(fmt, a[i], sep);

        System.out.print(end);
    }

    public static void print(int [][] a)
    {
        print(1, a);
    }

    public static void print(int n, int [][] a)
    {
        for (int [] array : a)
            print(n, array);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static int [] reversed(int [] a)
    {
        int [] result = new int[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static char [] reversed(char [] a)
    {
        char [] result = new char[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean desc)
    {
        if (desc)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void subtractBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] -= val;
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Tüm ctor'ları private olarak bir sınıftan türetme yapılması zaten sentaks olarak hata olacağından bu tarz sınıfların
    final yapılması uygundur. Zaten utility sınıflarında ctor'ları private yapıldığından yine final yapılması uygundur.
----------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Immutable Point class that represents a 2-dimensional
	point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public final class Point {
	private final double m_x, m_y;

	private Point(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static Point createCartesian(double x, double y)
	{
		return new Point(x, y, false);
	}

	public static Point createPolar(double radius, double theta)
	{
		return new Point(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public double getY()
	{
		return m_y;
	}


	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: MutablePoint.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	MutablePoint class that represents a 2-dimensional point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public final class MutablePoint {
	private double m_x, m_y;

	private MutablePoint(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static MutablePoint createCartesian(double x, double y)
	{
		return new MutablePoint(x, y, false);
	}

	public static MutablePoint createPolar(double radius, double theta)
	{
		return new MutablePoint(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public void setX(double x)
	{
		m_x = x;
	}

	public double getY()
	{
		return m_y;
	}

	public void setY(double y)
	{
		m_y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(MutablePoint other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		m_x += dx;
		m_y += dy;
	}

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: IntValue.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 4th February 2024

	Wrapper class that use cache for values in [-128, 127]

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.primitive.wrapper;

public final class IntValue {
    private static final int CACHE_MIN_VALUE = -128;
    private static final int CACHE_MAX_VALUE = 127;
    private static final IntValue [] CACHE = new IntValue[CACHE_MAX_VALUE - CACHE_MIN_VALUE + 1];
    private final int m_value;

    private IntValue(int value)
    {
        m_value = value;
    }

    public static final IntValue ZERO = of(0);
    public static final IntValue ONE = of(1);

    public static IntValue of(int value)
    {
        if (value < CACHE_MIN_VALUE || value > CACHE_MAX_VALUE)
            return new IntValue(value);

        if (CACHE[value - CACHE_MIN_VALUE] == null)
            CACHE[value - CACHE_MIN_VALUE] = new IntValue(value);

        return CACHE[value - CACHE_MIN_VALUE];
    }

    public int getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Soru: final anahtar sözcüğü olmasaydı bir sınıfı türetmeye nasıl kapatırdınız? Implemente ederek gösteriniz?
    Cevap: Sınıfın ctor'u private yapılabilir. Bu durumda ilgili sınıf türünden nesne de yaratılamaz duruma gelir. Nesne
    yaratılmasını sağlamak için bir factory yazılabilir

    Şüphesiz final anahtar sözcüğü varken böylesi bir tasarıma pratikte gerek yoktur. Puzzle olarak sorulmuştur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A x = A.create();
    }
}

class B extends A { //error

}

class A {
    private A()
    {}

    public static A create()
    {
        return new A();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Algoritma Kavramı ve Algoritma Analizi:
    Algoritma bir problemin çözümüne ulaştıran doğru adımlara denir. Algoritmaların anlatımında belli bir formal yöntem
    yoktur. Genel olarak sahte kodlar (pseudo codes) kullanılarak açıklanır. Algoritmalar, açıklama bakımından genel olarak
    dilden bağımsızdır. Ancak ince noktalara gelindiğinde algoritmalar da dile bağımlı hale gelir. Örneğin, bir dilde
    belli bir işi daha kolay yapan deyimler bulunabilir. Bu durumda algoritma o deyimlerle implemente edilir.

    Bir algoritmanın işleyişinin masaya yatırılmasına "algoritma analizi (analysis of algorithm)" denir. Bu analiz
    genel olarak Matematiksel yöntemler kullanılarak yapılır. İki algoritmanın karşılaştırılabilmesi için kullanılan ölçüye
    "algoritmanın karmaşıklığı (complexity of algorithm)" denir. Algoritmanın karmaşıklığı için temel iki ölçüt kullanılır:
    Hız (speed), kaynak kullanımı (resource usage). Burada baskın ölçüt hızdır. Yani daha çok algoritmalar hızlarına
    göre karşılaştırılır. Ancak bazı durumlarda kaynak kullanımı da gözönüne alınır. Bu durumlar hıza göre az da olsa
    önemli durumlardır. Her iki ölçütün de en iyi olduğu durum çoğu zaman mümkün olmaz.

    Örneğin aşağıdaki gibi yazılmış, en büyük sayıyı bulma algoritması için:
    int [] a = {...};

    int max = a[0];

    n = a.length;

    for (int i = 1; i < n ++i)
        if (max < a[i])
            max = a[i];

    Burada toplam işlemin sayısı max = a[i] işlemine bağlıdır. Bu algoritma için dizinin elemanları bilinmeden bu işlemin
    ne kadar yapıldığı anlaşılamaz. İşte algoritma analizinde işlemlerin sayısı hesaplanırken üç durum dikkate alınır:

    1. Ortalama durum (average case condition)
    2. En kötü durum (worst case condition)
    3. En iyi durum (best case condition)

    En kötü durum olabileceklerinin en kötüsüdür. Yukarıdaki örnekte en kötü durumda max = a[i] işlemi "n - 1" kez
    yapılır. Ortalama durum tüm olasılıkların ortalamasını temsil eder. Buna göre yukarıdaki örnekte max = a[i] işlemi
    "(n - 1) / 2" kez yapılır. En iyi durum olabileceklerin en iyisini temsil eder. Yani max = a[i] işlemi hiç yapılmaz.
    Algoritma analizinde en iyi durumun çok yararı yoktur. Çünkü aşırı iyimserlik programlamada çok değerli değildir. En
    kötü durum senaryosu önemlidir. Bazı algoritmalar için en kötü duruma hazırlıklı olmak gerekebilir. En önemli durum
    ortalama durumdur. Ortalama durum algoritmanın karakterini en iyi belirten durumdur. Genel olarak algoritma analizi
    ortalama durum ve en kötü durum için yapılır

    Algoritmalarda işlem sayısına ilişkin analizler çok da kolay değildir. Özellikle ortalama durumu hesaplamak bazen çok
    karmaşık olabilmektedir. Algoritmaları pratik bakımdan karşılaştırmak için asimtotik notasyonlardan yararlanılır. Bu
    notasyonlardan en çok kullanılanı "Big O"'dur. Bu notasyonda belli karakterdeki algoritmalar aynı kategoride kabul
    edilir. Eğer bir algoritma birden fazla kategoriye sahipse en kötü duruma ilişkin kategori gerçek kategoridir.

    Anahtar Notlar: Bir program ömrünü genel olarak döngülerde geçirir. Dolayısıyla algoritmanın karşılaştırılmasında
    genel olarak döngüler kullanılır.

    Anahtar Notlar: Asimtotik gösterilişte iki algoritma aynı kategoride olsa da tam anlamıyla aynı sayıda işlem yapılmıyor
    olabilir. Örneğin bir dizinin en büyük elemanını bulma algoritması ile dizinin elemanlarının toplamını bulma algoritmalarının
    her ikisi de tek bir döngü içerdiği için aynı kategoridedir. Şüphesiz her ikisinin işlem sayısı aynı değildir. Yine
    örneğin bir algoritma içiçe iki döngü içerip, devamında tekil n tane döngü içeriyorsa, bu algoritma yalnızca içiçe
    iki döngü içeren algoritma ile aynı kategoridedir anca işlem sayısı aynı değildir

    Algorimanın karmaşıklığının Big O notasyonu ile iyiden kötüye doğru kategorileri şunlardır:
    - Polinomsal (polynomial) karmaşıklar
    O(1)		-> Sabit karmaşıklık: Döngü yok. Bir üçgenin alanının bulunması, Dizinin bir elemanına erişim.

    O(logn)		-> logaritmik karmaşıklık (2 tabanında): Tek bir döngü var, her adımda dönme sayısı yarı yarıya azalıyor.
    Örneğin binary search

    O(n)		-> doğrusal karmaşıklık: Tek döngü. Örnğin bir dizinin elemanları toplamının bulunması, bir dizinin en büyük
    elemanının bulunması

    O(n * logn)	-> nlogn karmaşıklık (2 tabanında): İçiçe iki döngü var birisinde her adımda dönme sayısı yarı yarıya düşüyor.
    Örneğin, quick sort

    O(n ^ 2)	-> Karesel karmaşıklık: İçiçe iki döngü var. Örneğin, bir matrisin elemanları toplamının bulunması, bubble
    sort ve selection sort algoritmaları, iki matrisin toplanması

    O(n ^ 3)	-> Küpsel karmaşıklık: İçiçe üç döngü var. Örneğin, matris çarpımı, bir dikdörtgen prizmanın tüm noktalarının
    dolaşılması.

    ...

    O(n ^ k)	-> k-sal karmaşıklık (k sabit): İçiçe k tane döngü var

    - Polinomsal olmayan (non-polynomial ya da kısaca NP) karmaşıklar
    O(k ^ n)	-> Üstel karmaşıklık (k sabit). Örneğin n elemanlı bir kümenin tüm alt kümelerini dolaşan bir algoritma
    O(n!)		-> Faktoriyel karmaşıklık. Örneğin, gezgin satıcı problemi

    Anahtar Notlar: NP algoritmlara ilişkin kesin çözümler günümüzdeki bilgisayarlarla bile ya çok uzun zamanda
    yapılabilmekte ya da yapılamamaktadır. Bu sebeple bu problemlerin çözümleri sezgisel (heuristic) olarak yani
    en yakın çözüm olacak şekilde tasarlanır. Halen bu tip problemlerin çözümleri üzerinde çalışılmaktadır.

    Bir algoritma çoğu zaman herhangi bir karmaşlıktayken, bazı zamanlar (bu az olmalıdır) üst bir karmaşıklıkta çalışıyorsa,
    bu tarz karmaşıklıklara "amortized (time) complexity" ya da "amortized time cost" denir. Örneğin bir algoritma çoğu
    zaman O(1), bazı zamanlarda O(n) karmaşıklıkta çalışıyor ise "constant amortized (time) complexity/cost" denir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir dizinin uzunluğu değiştirilemez. Bir diziyi büyütmek için yeni bir dizi yaratılmalı, eski
    dizideki elemanlar yeni diziye kopyalanmaı ve eski diziyi gösteren referans yeni diziyi gösterir duruma getirilmelidir.
    Burada diziye eklenmesi gereken eleman sayısı kadar ekleme yapılması durumunda her eklemede karmaşıklık O(N) olacaktır.
    Bu durumda dizinin elemanına erişmin O(1) karmaşıklıkta olması avantajı ortadan kalkacaktır. Böylesi durumlarda
    sabit zaman karmaşıklığından daha fazla yararlanabilmek için dizi eklenecek sayısından biraz daha fazla büyütülür. Bu
    tarz bir büyütme işlemiyle birlikte bu diziye eleman eklenmsi çoğu zaman O(1), büyütüleceği zaman O(n) karmaşıklıkta
    olur. Bu karmaşıklığa "amortized constant time complexity/cost" denir. Diziyi gerektiğinde büyüten veri yapılarına
    (yani kabaca bir dizi içerisinde istenildiği kadar eleman tutulmasını sağlayan veri yapılarına) "dynamic array" veya
    "resizeable array" denilmektedir. JavaSE'de veri yapılarına genel olarak "collections" denilmektedir ve hazır olarak
    bulundurulan pek çok collection sınıf vardır. Burada dinamik büyüyen dizi veri yapısını temsil eden ArrayList ve
    belirli ölçüde Vector sınıflarını ele alacağız. Diğer collection sınıflar "Java ile Uygulama Geliştirme 1" kursunda
    incelenecektir. Dinamik büyüyen dizi veri yapıları büyütme işlemini eklenen eleman sayısından genel olarak fazla
    yaptıklarından iki önemli kavram söz konusudur: capacity, size. capacity dizinin gerçek uzunluğudur, size ise o dizi
    ele tutulan (eklenen) eleman sayısıdır. capacity değeri en az size kadar olur. size'dan küçük olamaz. ArrayList
    sınıfında capacity değerinin büyütme politikasının (growth policy) nasıl olduğu belirtilmemiştir. Ancak capacity
    değeri kullandığı belirtilmiştir. ArrayList sınıfının içsel olarak tuttuğu dizinin uzunluğu yani capacity değerini
    veren bir metodu yoktur. Yani programcı o anki capacity değerinin kaç olduğu bilgisini elde edemez. Capacity değeri
    gerektiren örneklerimizde ArrayList sınıfına çok benzeyen Vector sınıfını kullanacağız. Vector sınıfının o anki capacity
    değerini döndüren capacity isimli metodu bulunmaktadır. Vector sınıfı büyük ölçüde ArrayList ile benzer metotlara
    sahiptir ancak şüphesiz kendine özgü metotları da vardır. Vector sınıfı gerekmedikçe kullanılması önerilmeyen yerine
    ArrayList kullanılması önerilen dinamik büyüyen bir dizi sınıfıdır. Gerekmedikçe kullanılmamasının gerekçeleri şu
    an için önemsizdir. Biz de burada capacity değeri gerektiği yerlerde Vector sınıfını kullanacağız.

    Anahtar Notlar: ArrayList/Vector sınıfları aslında generic sınıflardır. Java'da generic sınıflar generic değilmiş gibi
    de kullanılabilmektedir. Bu durum aslında tavsiye edilmese de konu anlatımı açısından generic değilmiş gibi kullanacağız.
    Generic sınıflar konusunda ayrıca detaylar ele alınacaktır. Generic sınıflar, generic değilmiş gibi kullanıldığında
    static kod analizi araçları genel olarak uyarı mesajları verirler. Buradaki örneklerde bu uyarı dikkate alınmayacaktır.

    ArrayList/Vector sınıfları içsel olarak Object türden dizi tutarlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının default ctor'u ile capacity değerini 10 olan bir nesne yaratılır. ArrayList/Vector sınıfının
    tek parametreli add metodu sona ekleme (append) yapar. Vector sınıfının capacity metodu ile o anki capacity değeri
    elde edilebilir. ArrayList/Vector sınıfının size metodu ile tutulan eleman sayısı elde edilebilir. ArrayList/Vector
    sınıfının get metodu ile belirli bir indeksteki eleman elde edilebilir. get metoduna verilen indeks numarası [0, size)
    aralığında olmalıdır. Aksi durumda exception oluşur. aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String[] args)
    {
        Vector vec = new Vector();
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            vec.add(StringUtil.generateRandomTextTR(random, n));
            Console.writeLine("Size:%d, Capacity:%d", vec.size(), vec.capacity());
        }

        int size = vec.size();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < size; ++i) {
            String s = (String)vec.get(i);

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının initialCapacity parametreli ctor'u ile başlangıç capacity değeri belirlenebilir. initialCapacity
    değeri negatif olarak verilirse exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String[] args)
    {
        Vector vec = new Vector(Console.readInt("Capacity değerini giriniz:"));
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            vec.add(StringUtil.generateRandomTextTR(random, n));
            Console.writeLine("Size:%d, Capacity:%d", vec.size(), vec.capacity());
        }

        int size = vec.size();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < size; ++i) {
            String s = (String)vec.get(i);

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfı for-each döngü deyimi ile dolaşılabilir (iterable)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList texts = new ArrayList(Console.readInt("Capacity değerini giriniz:"));
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            texts.add(StringUtil.generateRandomTextTR(random, n));
        }

        StringBuilder sb = new StringBuilder();

        for (Object o : texts) {
            String s = (String)o;

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının iki parametreli add metodu aldığı indekse ekleme yapar (insert). Bu metot O(n) karmaşıklıktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList texts = new ArrayList();
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            String text = StringUtil.generateRandomTextTR(random, n);

            Console.writeLine(text);

            texts.add(0, text);
        }

        StringBuilder sb = new StringBuilder();

        for (Object o : texts) {
            String s = (String)o;

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının set metodu ilgili indeksteki elemanı değiştirmek kullanılır. Bu metot O(1) karamaşıklıktadır.
    Indeks olarak [0, size) aralığı dışında bir değer verildiğinde exception oluşur. Metot değiştirme yapmadan önce tutulan
    elemana ilişkin referansa geri döner
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList texts = new ArrayList();
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            String text = StringUtil.generateRandomTextTR(random, n);

            Console.writeLine(text);

            texts.add(text);
        }

        StringBuilder sb = new StringBuilder();

        for (Object o : texts) {
            String s = (String)o;

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());

        String oldText = (String)texts.set(2, "ankara");


        Console.writeLine("Old text:%s", oldText);

        sb = new StringBuilder();

        for (Object o : texts) {
            String s = (String)o;

            sb.append(s).append(" ");
        }

        Console.writeLine(sb.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    10.02.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının int parametreli remove metodu parametresi ile aldığı index numarasındaki elemanı siler ve silinmiş
    olan elemana ilişkin referansa geri döner. Bu metot O(n) karmaşıklıktadır. index numarası [0, size) aralığı dışında
    verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.ArrayList;

class App {
    public static void main(String[] args)
    {
        ArrayList numbers = new ArrayList();
        int val;

        while ((val = Console.readInt("Bir sayı giriniz:")) != 0)
            numbers.add(val);

        for (Object o : numbers) {
            int a = (int)o;

            Console.write("%d ", a);
        }

        Console.writeLine();

        int oldVal = (int)numbers.remove(2);

        Console.writeLine("Old value:%d", oldVal);

        for (Object o : numbers) {
            int a = (int)o;

            Console.write("%d ", a);
        }

        Console.writeLine();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının toString metodu elemanlara ilişkin değerlerden oluşan yazıyı liste formatındea geri dönmektedir.
    Elemanlara ilişkin değerlerin yazı karşılıklarının nasıl elde edildiği ileride ele alınacaktır. Liste biçimi [ ile
    ] arasında değerlerin virgül ile ayrılmış halidir. Eğer ArrayList boş ile liste de boş olarak elde edilecektir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.ArrayList;

class App {
    public static void main(String[] args)
    {
        ArrayList numbers = new ArrayList();
        int val;

        while ((val = Console.readInt("Bir sayı giriniz:")) != 0)
            numbers.add(val);

        Console.writeLine(numbers.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının isEmpty metodu ile dizinin boş olup olmadığı test edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.ArrayList;

class App {
    public static void main(String[] args)
    {
        ArrayList numbers = new ArrayList();
        int val;

        while ((val = Console.readInt("Bir sayı giriniz:")) != 0)
            numbers.add(val);

        Console.writeLine(numbers.isEmpty() ? "Hiç değer girilmedi" : numbers.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının ensureCapacity metodu ile capacity değeri büyütülebilir. ensureCapacity metodunun
    parametresi olan minCapacity değerine göre büyütme işlemi aşağıdaki gibi yapılır (adımları else if biçiminde değerlendiriniz):
    1. miCapacity değeri varolan capacity değerinden küçükse herhangi bir değişiklik yapılmaz
    2. minCapacity değeri, capacity değeri artması gerektiğinde artırılacak değerden küçükse artırılması gereken değere
    çekilir
    3. minCapacity değeri artması gereken değerden büyükse artık o değere çekilir

    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.Vector;

class App {
    public static void main(String[] args)
    {
        Vector numbers = new Vector();

        Console.writeLine("Capacity:%d", numbers.capacity());

        numbers.ensureCapacity(5);
        Console.writeLine("Capacity:%d", numbers.capacity());

        numbers.ensureCapacity(15);
        Console.writeLine("Capacity:%d", numbers.capacity());

        numbers.ensureCapacity(45);
        Console.writeLine("Capacity:%d", numbers.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   ArrayList sınıfının trimToSize metodu capacity değerini size değerine çeker. Bu metot O(n) karmaşıklıktadır. Bu metot
   çağrıldıktan sonra ekleme yapılması şüphesiz O(n) karmaşıklıktadır. Bu durumda bu metodun dikkatli kullanılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.Vector;

class App {
    public static void main(String[] args)
    {
        Vector numbers = new Vector();
        int val;

        while ((val = Console.readInt("Bir sayı giriniz:")) != 0)
            numbers.add(val);

        Console.writeLine("Size:%d, Capacity:%d", numbers.size(), numbers.capacity());
        numbers.trimToSize();
        Console.writeLine("Size:%d, Capacity:%d", numbers.size(), numbers.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   ArrayList sınıfının clear metodu diziyi boşaltır. Bu metot da O(n) karmaşıklıktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.ArrayList;

class App {
    public static void main(String[] args)
    {
        ArrayList numbers = new ArrayList();
        int val;

        while ((val = Console.readInt("Bir sayı giriniz:")) != 0)
            numbers.add(val);

        Console.writeLine("Size:%d",  numbers.size());

        numbers.clear();
        Console.writeLine("Size:%d",  numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: ArrayList/Vector sınıfının silme yapan metotları (remove, clear vb) capacity değerini değiştirmez.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Sınıf Çalışması: Klavyeden quit girilene kadar alınan yazıları bir ArrayList'e ekleyiniz. Bu işlemden sonra yazıların
   arasında - karakteri olacak şekilde birleştirilmiş yeni bir yazı elde ediniz
----------------------------------------------------------------------------------------------------------------------*/

package org.csystem.app.string;

import org.csystem.util.array.ArrayUtil;
import org.csystem.util.console.Console;

import java.util.ArrayList;

public class JoinWithHyphenApp {
    public static void run()
    {
        ArrayList texts = new ArrayList();
        String text;

        while (!(text = Console.readString("Input text:")).equals("quit"))
            texts.add(text);

        Console.writeLine(texts.toString());
        String str = ArrayUtil.join(texts, '-');
        Console.writeLine(str);
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: StringBuilder sınıfı da aslında bir dinamik büyüyen dizi veri yapısıdır. StringBuilder'da her ekleme
    işleminde içsel olarak tuttuğu diziyi büyütür. Büyütme işlemini yine amortize edilmiş sabit zamanlı karmaşıklıkta
    yapar dolayısıyla StringBuilder sınıfı da capacity kullanır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
   Polymorphism: Biyolojiden programlamaya aktarılmıştır. Biyoloji'de polymorphism, "farklı doku ya da organların evrim
   süreci içerisinde temel işlevi aynı kalacak şekilde o işlevi yerine getirme biçiminin değişebilmesi" şeklinde
   tanımlanabilir. Yani bir canlı için görme işlevinin yapılış şekli, o canlıdan türemiş olan bir canlıda değişiklik
   gösterebilir. Ancak temel hedef görmektir.

   Polymorphism özellikle NYPT'de iki biçimde düşünülür: runtime polymorphism (RTP), compile time polymorphism (CTP)
   Bu bölümde RTP ele alınacaktır. CTP generics konusunda ele alınacaktır. Polymorphism dendiğinde ilk akla RTP gelir.

   RTP ile ilgili pek çok tanım ve betimleme yapılabilse de şu 3 tanıma indirgenebilir:
   1. Biyolojik Tanım: Taban sınıfının bir fonksiyonun türemiş sınıfta yeniden gerçekleştirilmesidir.
   2. Yazılım Mühendisliği Tanımı: Türden bağımsız kod yazmaktır.
   3. Aşağı Seviyeli Tanım: Önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesidir.

   Anahtar Notlar: Özellikle RTP destekleyen bir programlama dili NYPT destekleyen bir dil olur. Nesnenin var olduğu
   ancak RTP'nin olmadığı dillere genel olarak "Nesne tabanlı (object based)" diller denilmektedir. Bu anlamda RTP
   aslında dile NYPT özelliğini katmış olur.

   Anahtar Notlar: Polymorphism SOLID ilkelerinden, L yani "Liskov Substitution Principle"'ın en iyi uygulanışıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Java'da RTP "sanal metotlar (virtual methods)" kullanılarak gerçekleştirilir. Non-static bir metot, final olarak
   bildirilmemişse veya abstract olarak bildirilmişse sanaldır. Bazı dillerde non-static olan, final olmayan ve abstract
   olmayan bir metot default olarak sanal olmaz. İlgili metodun sanal olması için ayrı bir şekilde bildirilmesi gerekir.
   Bu kavrama "virtual dispatching" denir. Bu durumda Java'da virtual dispatching yoktur.

   Sanal bir metodun aynı imza ve aynı geri dönüş değeri ile birlikte (erişim belirleyici kısmını ileride ele alacağız)
   türemiş sınıfta yazılmasına "override" denir. Sanal bir metodun türemiş sınıfta override etme zorunluluğu yoktur.

   Derleyici sanal bir metot çağrısı gördüğünde şu şekilde bir kod üretir: "Çalışma zamanında ilgili referansın dinamik
   türüne bak, dinamik türe ilişkin sınıfta ilgili sanal metot override edilmişse onu çağır, edilmemişse taban sınıfına
   bak orada override edilmişse onu çağır, edilmemişse taban sınıfına bak onu çağır ...".

   Bazen override edilmiş bir metot içerisinde taban sınıfın metodun da işinin yapılması gerekebilir. Bu duruma genel
   olarak "augmentation" denilmektedir. Bu işlem tipik olarak super referansı ile ilgili metot çağrılarak yapılır. super
   referansı türemiş sınıf nesnesinin taban sınıf kısmının adresidir. super referansı kullanıldığı sınıfın taban sınıfı
   türündendir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örnekte dikkat edilirse RTP'ye ilişkin 3 tanım da gerçeklenmiş olur:
   - foo metodu türemiş sınıflarda override edilmiştir (Biyolojik tanım).
   - Util sınıfının doWork metodu ve main metodu A hiyerarşisi açısından türden bağımsız yazılmıştır (Yazılım mühendididliği tanımı).
   - A hiyerarşisine yeni bir tür eklense bile doWork metodu bu türleri de kullanabilir durumdadır (aşağı seviyeli tanım).
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.thread.ThreadUtil;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Factory factory = new Factory();

        while (true) {
            A x = factory.create();

            Util.doWork(x);
            ThreadUtil.sleep(1000);
        }
    }
}

class Util {
    public static void doWork(A a)
    {
        Console.writeLine("---------------------------------------------------------------");

        Console.writeLine("Dynamic type:%s", a.getClass().getName());
        a.foo();
        Console.writeLine("---------------------------------------------------------------");
    }
}

class Factory {
    private final Random m_random = new Random();

    public A create()
    {
        return switch (m_random.nextInt(5)) {
            case 0 -> new B();
            case 1 -> new C();
            case 2 -> new D();
            case 3 -> new E();
            default -> new F();
        };
    }
}

class F extends D {
    public void foo() //override
    {
        Console.writeLine("F.foo");
    }
}

class E extends C {
    public void foo() //override
    {
        Console.writeLine("E.foo");
    }
}

class D extends A {
    public void foo() //override
    {
        Console.writeLine("D.foo");
    }
}

class C extends B {
    public void foo() //override
    {
        Console.writeLine("C.foo");
    }
}

class B extends A {
    public void foo() //override
    {
        Console.writeLine("B.foo");
    }
}

class A {
    public void foo() //virtual method
    {
        Console.writeLine("A.foo");
    }

    public final void bar() //not a virtual method
    {
        Console.writeLine("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.thread.ThreadUtil;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Factory factory = new Factory();

        while (true) {
            A x = factory.create();

            Util.doWork(x);
            ThreadUtil.sleep(1000);
        }
    }
}

class Util {
    public static void doWork(A a)
    {
        Console.writeLine("---------------------------------------------------------------");

        Console.writeLine("Dynamic type:%s", a.getClass().getName());
        a.foo();
        Console.writeLine("---------------------------------------------------------------");
    }
}

class Factory {
    private final Random m_random = new Random();

    public A create()
    {
        return switch (m_random.nextInt(5)) {
            case 0 -> new B();
            case 1 -> new C();
            case 2 -> new D();
            case 3 -> new E();
            default -> new F();
        };
    }
}

class F extends D {

}

class E extends C {
    public void foo() //override
    {
        Console.writeLine("E.foo");
    }
}

class D extends A {

}

class C extends B {
}

class B extends A {
    public void foo() //override
    {
        Console.writeLine("B.foo");
    }
}

class A {
    public void foo() //virtual method
    {
        Console.writeLine("A.foo");
    }

    public final void bar() //not a virtual method
    {
        Console.writeLine("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.thread.ThreadUtil;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Factory factory = new Factory();

        while (true) {
            A x = factory.create();

            Util.doWork(x);
            ThreadUtil.sleep(1000);
        }
    }
}

class Util {
    public static void doWork(A a)
    {
        Console.writeLine("---------------------------------------------------------------");

        Console.writeLine("Dynamic type:%s", a.getClass().getName());
        a.foo();
        Console.writeLine("---------------------------------------------------------------");
    }
}

class Factory {
    private final Random m_random = new Random();

    public A create()
    {
        return switch (m_random.nextInt(5)) {
            case 0 -> new B();
            case 1 -> new C();
            case 2 -> new D();
            case 3 -> new E();
            default -> new F();
        };
    }
}

class F extends D {
    public void foo() //override
    {
        Console.writeLine("F.foo");
        super.foo();
    }
}

class E extends C {
    public void foo() //override
    {
        Console.writeLine("E.foo");
        super.foo();
    }
}

class D extends A {
    public void foo() //override
    {
        Console.writeLine("D.foo");
        super.foo();
    }
}

class C extends B {
    public void foo() //override
    {
        Console.writeLine("C.foo");
        super.foo();
    }
}

class B extends A {
    public void foo() //override
    {
        Console.writeLine("B.foo");
        super.foo();
    }
}

class A {
    public void foo() //virtual method
    {
        Console.writeLine("A.foo");
    }

    public final void bar() //not a virtual method
    {
        Console.writeLine("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    11.02.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Polymorphism'e ilişkin bazı örnekler:
    1. Sürekli devam eden (endless) bir oyunda bir karakter kendisine gelen toplara vurmakta olsun. Bu karaktere gelen
    topların çeşitlerine göre vurduktan sonraki davranışları değişiklik göstersin. Böyle bir ıyun uygulamasında vurma
    esnasında gelen topa göre işlem yapmak yerine, bu davranışı topa ait kabul edip bir taban sınıf ve bir sanal metot
    (örneğin Ball sınıfı ve kick metodu gibi) ile karaktere gelen topa yalnızca vurma kodu yazılıp vurma işleminden sonra
    dinamik türe göre metodun çağrılması sağlanabilir. Bu durumda oyuna yeni bir top da eklense topun karaktere gelip
    vurulması kodlarında değişiklik gerekmez.

    2. Popüler tuğla kırma oyununda (birick world) top tuğlaya çarptığında tuğlanın şekline göre olay gerçekleşmektedir.
    Bu durumda çeşitli tuğlalar için çeşitli davranışlar söz konusu olmaktadır. Bu durumda topun tuğlaya çarptığı sırada
    tuğlanın ne olduğuna işlem yapmak yerine bir taban sınıf ve bir sanal metot (örneğin Brick sınıf ve hit metodu gibi)
    ile tüm tuğlalar bir matris düşünülüp ilgili elema top çarptığında sanal metot çağrılarak dinamik türe işlem yapılması
    sağlanabilir. Bu durumda yeni bir tuğla eklense de topun tuğlaya çarpması kodlarınde değişiklik gerekmez

    3. Popüler "angry birds" oyununda çeşitli kuşlar bir sapandan atılmaktadır. Oyunda atıldığında değişik davranışlar
    gösteren kulşar bulunmaktadır. Bu durumda kuşun davranışının atıldıktan sonra kuşun türüne bakarak gerçekleştirilmesi
    yerine kuş için bir taban sınıf ve bir sanal metot (örneğin Bird sınıfı ve throwBird gibi) belirlenerek fırlatma işlemi
    için taban sınıf referansı kullanılarak yapılabilir. Bu durumda dinamik türe göre işlem yapılmış olur. Yeni bir kuş
    türü eklendiğinde fırlatma kodlarında değişiklik gerekmez.

    Şüphesiz yukarıdaki örnekler dışında pek çok örnek verilebilir.

    Programlamada temel amaç mümkün olduğunca yeni eklentilerin eski kodlara dokunmadan yapılabilmesidir. Bu işlem adeta
    bir logonun parçası ya da bir plugin gibi yapılabilmelidir. Böyle bir tasarım ile ürünün yeni versiyonu daha çabuk ve
    daha sistematik bir şekilde elde edilebilir. RTP de bunu sağlayan araçlardan biridir. Aslında bir ürünün kod kalitesi
    için şu cümle söylenebilir: "Bir ürünün yeni versiyonu çıkartılırken eski kodlara ilişkin senaryolarda ve algoritmalarda
    değişiklik olmadıktan sonra, eski kodlara ne kadar az müdahale ediliyorsa ürün o kadar kaliteli yazılmıştır". Algoritmanın
    tekrar daha etkin yazılması kodun daha önce kalitesiz yazılmış olması anlamına gelmeyebilir. Çünkü örneğin yeni bir
    sisteme göre eklenen bazı araçlar ile yazılan algoritmalar daha efektif olma eğilimindeyse değişiklik gerekebilir.
    Bu da zaten daha kaliteli yazmak içindir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Object sınıfının toString isimli sanal bir metodu vardır. Bu metot bir nesneye ilişkin yazı karşılığı olması durumunda
   override edilmesi bir convention olan metottur. Aslında biz sınıflarımız içerisinde toString metodunu hep override
   ettik. toString metodu JavaSE ve çeşitli üçüncü parti kütüphaler tarafından da duruma göre Object sınıfı üzerinden
   çağrılmaktadır. Örneğin print ve println metotlarının Object parametreli overload'ları standart output'a yani ekrana
   basacakları yazıyı toString metodunu çağrırarak elde ederler. Benzer şekilde printf (ve String sınıfının format metodu()
   metodu s format karakteri ile verilen bir argüman için yazı karşılığını toString metodunu çağırarak elde eder
   metodu s format karakteri ile verilen bir argüman için yazı karşılığını toString metodunu çağırarak elde eder.

   Temel bir tür için de printf metodu (ve String sınıfının format metodu) s format karakteri için dolaylı olarak
   toString metodunu çağırarak değerin yazı karşılığını elde eder. Çünkü temel türden bir ifadenin değeri printf metoduna
   geçilirken parametre türü Object olduğundan otomatik kutulama yapılır, sonrasında ilgili sarmalayan sınıfın toString
   metodu çağrılmış olur.

   Anımsanacağı gibi + operatörünün bir operandı String türündense diğer operandının yazı karşılığı elde edilerek yazı
   birleştirmesi işlemi yapılır. Diğer türün yazı karşılığı yine toString metodu çağrılarak elde edilir. Diğer tür temel
   türlerden biriyse önce otomatik kutulanır sonra ilgili sarmalayan sınıfın toString metodu çağrılarak yazı karşılığı
   elde edilir.

   ArrayList sınıfının toString metodu elemanlara ilişkin yazı karşılığını yine her bir eleman için toString metodunu
   çağırarak elde eder

   Object sınıfının toString metodu nesneye özgü tekil (unique) bir bilgiye ilişkin yazı döndürür. Bu yazının nasıl elde
   edildiğinin ve ne anlama geldiğinin önemi yoktur.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;

class App {
    public static void main(String[] args)
    {
        Circle c = new Circle(13);
        Point p = Point.createCartesian(4.5, 6.7);

        System.out.printf("Circle -> %s%n", c);
        System.out.printf("Point -> %s%n", p);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;

class App {
    public static void main(String[] args)
    {
        Circle c = new Circle(13);
        Point p = Point.createCartesian(4.5, 6.7);

        System.out.println(c);
        System.out.println(p);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        int a = Console.readInt("Birinci sayıyı giriniz:");
        double b = Console.readDouble("İkinci sayıyı giriniz:");

        System.out.printf("a = %s, b = %s%n", a, b);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        int a = Console.readInt("Birinci sayıyı giriniz:");
        double b = Console.readDouble("İkinci sayıyı giriniz:");

        System.out.println("a = " + a + " b = " + b); //System.out.println("a = " + Integer.valueOf(a).toString() + "b = " + Double.valueOf(b).toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.Point;

class App {
    public static void main(String[] args)
    {
        Circle c = new Circle(13);
        Point p = Point.createCartesian(4.5, 6.7);

        System.out.println("Circle ->" + c);
        System.out.println("Point ->" + p);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Object o1 = new Sample();
        Object o2 = new Sample();

        System.out.println(o1);
        System.out.println(o2);
    }
}

class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Random r = new Random();

        System.out.println(r);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
   Object sınıfının equals isimli Object parametreli ve geri dönüş değeri boolean olan sanal bir metodu vardır. Bu metot
   aynı türden iki nesne için mantıksal eşitlik karşılaştırmasında kullanılır. İki nesne için eşitlik kavramı söz konusuysa
   equals metodu override edilir. Bu da Java'da bir convention'dır. Object sınıfının equals metodu klasik adres karşılaştırması
   yapar. JavaSE ve üçüncü parti pek çok kütüphane içerisinde equals metodunu Object türü üzerinden çağıran sınıflar ve
   dolayısıyla metotları bulunmaktadır. Örneğin ArrayList sınıfının indexOf ve lastIndexOf metotları arama işlemini
   null adres araması yapılmıyorsa equals metodunu çağrırarak yaparlar. Bu durumda ArrayList içerisinde tutulan referansın
   dinamik türüne göre override edilmişse, override edilen equals çağrılmış olur. Bu durumda ilgili tür için mantıksal
   eşitlik karşılaştırması yapılmış olur.

   equals metodu override edilirken aldığı Object referansına ilişkin dinamik türün ilgili sınıf türünden olup olmadığına
   da genel olarak bakılır. Özel bir durum yoksa bu bir convention olarak düşünülmeldir. Pek çok static kod analizi aracı
   default konfigürasyonda bu kontrolün yapılmadığı durumlarda uyarı vermektedir. Bu kontrol tipik olarak instanceof
   operatörü ile yapılabilir.

   Anahtar Notlar: Bir sınıfta equals metodu override ediliğinde, Object sınıfının hashCode metodu da override edilir veya
   tersine hashCode metodu override edildiğinde equals metodu da override edilir. Yani bu iki metot bir sınıf içerisinde
   ya ikisi birden override edilir ya da ikisi de override edilmez. hashCode metodu "Java ile Uygulama Geliştirme 1"
   kursunda elde alınacaktır. Buradaki equals metodu override edilmiş sınıflarda override edilmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte Point sınıfının equals metodu olmasaydı hiç bir zaman origin noktası bulunamazdı. Örneği
    Point sınıfınınn equals metodunu kaldırarak da çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.factory.RandomPointFactory;
import org.csystem.math.geometry.Point;
import org.csystem.util.console.Console;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList points = new ArrayList();
        Random random = new Random();
        RandomPointFactory factory = new RandomPointFactory(random);
        Point origin = Point.createCartesian();

        while (random.nextInt(-1000, 10001) != 0)
            points.add(factory.create(-2, 2));

        System.out.println(points);
        Console.writeLine("Size:%d", points.size());
        int index = points.indexOf(origin);

        Console.writeLine(index != -1 ? "Found" : "Not found");
    }
}

/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	Immutable Point class that represents a 2-dimensional
	point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public final class Point {
	private final double m_x, m_y;

	private Point(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static Point createCartesian()
	{
		return createCartesian(0, 0);
	}

	public static Point createCartesian(double x, double y)
	{
		return new Point(x, y, false);
	}

	public static Point createPolar()
	{
		return createPolar(0, 0);
	}

	public static Point createPolar(double radius, double theta)
	{
		return new Point(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public double getY()
	{
		return m_y;
	}


	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(Point other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public boolean equals(Object other)
	{
		return other instanceof Point p && PointCommon.equals(m_x, m_y, p.m_x, p.m_y);
	}

	//hashCode

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: MutablePoint.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	MutablePoint class that represents a 2-dimensional point

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public final class MutablePoint {
	private double m_x, m_y;

	private MutablePoint(double a, double b, boolean polar)
	{
		m_x = PointCommon.getXBy(polar, a, b);
		m_y = PointCommon.getYBy(polar, a, b);
	}

	public static MutablePoint createCartesian(double x, double y)
	{
		return new MutablePoint(x, y, false);
	}

	public static MutablePoint createPolar(double radius, double theta)
	{
		return new MutablePoint(radius, theta, true);
	}

	public double getX()
	{
		return m_x;
	}

	public void setX(double x)
	{
		m_x = x;
	}

	public double getY()
	{
		return m_y;
	}

	public void setY(double y)
	{
		m_y = y;
	}

	public double distance()
	{
		return distance(0, 0);
	}

	public double distance(MutablePoint other)
	{
		return distance(other.m_x, other.m_y);
	}

	public double distance(double x, double y)
	{
		return PointCommon.distance(m_x, m_y, x, y);
	}

	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}

	public void offset(double dx, double dy)
	{
		m_x += dx;
		m_y += dy;
	}

	public boolean equals(Object other)
	{
		return other instanceof MutablePoint p && PointCommon.equals(m_x, m_y, p.m_x, p.m_y);
	}

	//hashCode

	public String toString()
	{
		return PointCommon.toString(m_x, m_y);
	}
}

/*--------------------------------------------------------
	FILE NAME	: PointCommon.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	Friendly common utility class for Point and MutablePoint
	classes

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.*;

class PointCommon {
    private PointCommon()
    {
    }

    static final double DELTA = 0.000001;

    static double getXBy(boolean polar, double a, double b)
    {
        return polar ? a * cos(b) : a;
    }

    static double getYBy(boolean polar, double a, double b)
    {
        return polar ? a * sin(b) : b;
    }

    static double distance(double x1, double y1, double x2, double y2)
    {
        return sqrt(pow(x1- x2, 2) + pow(y1 - y2, 2));
    }

    static boolean equals(double x1, double y1, double x2, double y2)
    {
        return Math.abs(x1 - x2) < PointCommon.DELTA && Math.abs(y1 - y2) < PointCommon.DELTA;
    }

    static String toString(double x, double y)
    {
        return String.format("(%f, %f)", x, y);
    }
}

/*--------------------------------------------------------
	FILE NAME	: Circle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	Circle class that represents a circle

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    private static final double DELTA = 0.000001;
    private double m_radius;

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
    }

    public double getRadius()
    {
        return m_radius;
    }

    public double getArea()
    {
        return Math.PI * m_radius * m_radius;
    }

    public double getCircumference()
    {
        return 2 * Math.PI * m_radius;
    }

    public boolean equals(Object other)
    {
        return other instanceof Circle c && Math.abs(m_radius - c.m_radius) < DELTA;
    }

    //hashCode

    public String toString()
    {
        return String.format("Radius:%f, Area:%f, Circumference:%f", m_radius, getArea(), getCircumference());
    }
}

/*--------------------------------------------------------
	FILE NAME	: Circle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	Circle class that represents a circle

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    protected static final double DELTA = 0.000001;
    private double m_radius;

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public void setRadius(double radius)
    {
        m_radius = Math.abs(radius);
    }

    public double getRadius()
    {
        return m_radius;
    }

    public double getArea()
    {
        return Math.PI * m_radius * m_radius;
    }

    public double getCircumference()
    {
        return 2 * Math.PI * m_radius;
    }

    public boolean equals(Object other)
    {
        return other instanceof Circle c && Math.abs(m_radius - c.m_radius) < DELTA;
    }

    //hashCode

    public String toString()
    {
        return String.format("Radius:%f, Area:%f, Circumference:%f", m_radius, getArea(), getCircumference());
    }
}

/*--------------------------------------------------------
	FILE NAME	: AnalyticalCircle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	AnalyticalCircle class that represents a circle
	in cartesian plane

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package com.baturhansahin.math;

import org.csystem.math.geometry.Circle;
import org.csystem.math.geometry.MutablePoint;

public class AnalyticalCircle extends Circle {
    private final MutablePoint m_center;

    public AnalyticalCircle()
    {
        this(0);
    }

    public AnalyticalCircle(double radius)
    {
        this(radius, 0, 0);
    }

    public AnalyticalCircle(double x, double y)
    {
        this(0, x, y);
    }

    public AnalyticalCircle(double radius, double x, double y)
    {
        super(radius);
        m_center = MutablePoint.createCartesian(x, y);
    }

    public double getX()
    {
        return m_center.getX();
    }

    public void setX(double x)
    {
        m_center.setX(x);
    }

    public double getY()
    {
        return m_center.getY();
    }

    public void setY(double y)
    {
        m_center.setY(y);
    }

    public void setCenter(double x, double y)
    {
        setX(x);
        setY(y);
    }

    public void offset(double dxy)
    {
        offset(dxy, dxy);
    }

    public void offset(double dx, double dy)
    {
        m_center.offset(dx, dy);
    }

    public double centerDistance(AnalyticalCircle other)
    {
        return m_center.distance(other.m_center);
    }

    public boolean isTangent(AnalyticalCircle other)
    {
        return Math.abs(centerDistance(other) - getRadius() - other.getRadius()) < DELTA;
    }

    public boolean equals(Object other)
    {
        return other instanceof AnalyticalCircle c && super.equals(other) && m_center.equals(c.m_center);
    }

    //hashCode

    public String toString()
    {
        return String.format("%s, Center:%s", super.toString(), m_center);
    }
}

/*--------------------------------------------------------
	FILE NAME	: Complex.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 1tth February 2024

	Complex class that represents a complex number

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math;

public class Complex {
	private static final double DELTA = 0.000001;
	private double m_real, m_imag;

	private static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}

	private static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}

	private static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}

	public Complex()
	{
	}

	public Complex(double re)
	{
		m_real = re;
	}

	public Complex(double re, double im)
	{
		m_real = re;
		m_imag = im;
	}

	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.m_real, z.m_imag);
	}

	public Complex add(double val)
	{
		return add(m_real, m_imag, val, 0);
	}

	public Complex add(Complex other)
	{
		return add(m_real, m_imag, other.m_real, other.m_imag);
	}

	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.m_real, z.m_imag);
	}

	public Complex subtract(double val)
	{
		return subtract(m_real, m_imag, val, 0);
	}

	public Complex subtract(Complex other)
	{
		return subtract(m_real, m_imag, other.m_real, other.m_imag);
	}

	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.m_real, z.m_imag);
	}

	public Complex multiply(double val)
	{
		return multiply(m_real, m_imag, val, 0);
	}

	public Complex multiply(Complex other)
	{
		return multiply(m_real, m_imag, other.m_real, other.m_imag);
	}

	public Complex conjugate()
	{
		return new Complex(m_real, -m_imag);
	}

	public Complex negate()
	{
		return new Complex(-m_real, -m_imag);
	}

	public void inc()
	{
		++m_real;
	}

	public void dec()
	{
		--m_real;
	}

	public boolean equals(Object other)
	{
		return other instanceof Complex c && Math.abs(m_real - c.m_real) < DELTA && Math.abs(m_imag - c.m_imag) < DELTA;
	}

	//hashCode

	public String toString()
	{
		return String.format("%f + %f * i", m_real, m_imag);
	}
}

/*--------------------------------------------------------
	FILE NAME	: IntValue.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 11th February 2024

	Wrapper class that use cache for values in [-128, 127]

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.primitive.wrapper;

public final class IntValue {
    private static final int CACHE_MIN_VALUE = -128;
    private static final int CACHE_MAX_VALUE = 127;
    private static final IntValue [] CACHE = new IntValue[CACHE_MAX_VALUE - CACHE_MIN_VALUE + 1];
    private final int m_value;

    private IntValue(int value)
    {
        m_value = value;
    }

    public static final IntValue ZERO = of(0);
    public static final IntValue ONE = of(1);

    public static IntValue of(int value)
    {
        if (value < CACHE_MIN_VALUE || value > CACHE_MAX_VALUE)
            return new IntValue(value);

        if (CACHE[value - CACHE_MIN_VALUE] == null)
            CACHE[value - CACHE_MIN_VALUE] = new IntValue(value);

        return CACHE[value - CACHE_MIN_VALUE];
    }

    public int getValue()
    {
        return m_value;
    }

    public boolean equals(Object other)
    {
        return other instanceof IntValue v && m_value == v.m_value;
    }

    //hashCode

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    17.02.2024
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıflar ve abstract metotlar:
    Bazı sınıflar türünden doğrudan nesne yaratmanın anlamı yoktur. Bu sınıflar tipik olarak bir kavramı soyut (abstract)
    olarak temsil ederler. Bu sınıftan türemiş olan sınıflar türünden nesnelerin anlamı vardır. Örneğin, DemoCompanyApp
    uygulamasında Employee sınıfı böyle bir sınıftır. Burada Employee sınıfından türetilen sınıflar ile birlikte Employee
    nesnesi anlamlıdır. Ayrıca bu tarz sınıflarda sanal bazı metotların gövdesinin olması gerekmez. Bu metotlar türemiş
    sınıfta override edilir. İşte böylesi sınıflara soyut (abstract) sınıflar ve gövdesi olması gerekmeyen sanal metotlara da
    soyut metotlar denir. Doğrudan nesne özelliği gösteren sınıflara ise somut (concrete) sınıflar denir.

    Programcı soyut bir sınıf gördüğünde şunu anlamalıdır: "Bu sınıf bir kavramı temsil ediyor, bu sınıf türünden bir
    nesneyi doğrudan yaratamam çünkü anlamsız. Bu sınıftan türetilen sınıflar yazmalıyım ve bu sınıfın içerisinde
    bulunan abstract metotları (veya belki abstract olmayan sanal metotları da) override etmeliyim". Benzer şekilde
    programcı bir sınıf hiyararşisi için soyut bir kavramı temsil eden sınıfı abstract sınıf olarak düşünmelidir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Soyut bir sınıf abstract anahtar sözcüğü ile bildirilir. Bir metot abstract olarak bildirildiğinde metoda gövde
    yazılmaz. Yazılması error oluşturur. Bir sınıfın en az bir tane abstract metodu varsa sınıf abstract olarak
    bildirilmelidir. Aksi durumda error oluşur. abstract bir sınıfın abstract metodu olmak zorunda değildir. abstract
    bir sınıfın abstract olmayan metotları da olabilir. abstract bir sınıfın da veri elemanları olabilir. abstract
    bir sınıf türünden nesne new operatörü ile yaratılamaz. abstract bir sınıf türünden nesne türemiş sınıf nesnesi
    içerisinde yaratılır. abstract bir sınıfın ctor'u da olabilir.  abstract bir sınıfın ctor'unun public yapılmasının
    anlamı yoktur. Çünkü zaten sınıf dışından nesne yaratılamaz. Bu durumda ctor'un protected yapılması daha uygundur.
    Şüphesiz duruma göre private ya da no-modifier ctor'lar da olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A a = new A(); //error
    }
}

abstract class D {
    //...
}

class C {
    abstract void foo(); //error
}
abstract class B {
    public abstract void foo() //error
    {}
}

abstract class A {
    private static int m_y;
    private int m_x;

    protected A(int x)
    {
        //...
        m_x = x;
    }

    public abstract void foo();

    public void bar()
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.company;

import org.csystem.app.company.employee.Employee;
import org.csystem.app.company.factory.EmployeeFactory;
import org.csystem.app.company.hr.HumanResources;
import org.csystem.util.console.Console;
import org.csystem.util.thread.ThreadUtil;

public class DemoCompanyApp {
    public static void run()
    {
        HumanResources hr = new HumanResources();
        EmployeeFactory ef = new EmployeeFactory();

        while (true) {
            Employee e = ef.getEmployee();

            Console.writeLine("------------------------------------------------------");
            Console.writeLine(e.getClass().getName());
            hr.payInsurance(e);
            Console.writeLine("------------------------------------------------------");

            ThreadUtil.sleep(1000);
        }
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.app.company.factory;

import org.csystem.app.company.employee.*;

import java.util.Random;

public class EmployeeFactory {
    private final Random m_random = new Random();

    private Worker getWorker()
    {
        //...
        return new Worker("Ali", "12345678", "Mecidiyeköy", 8, 900);
    }

    private Manager getManager()
    {
        //...
        return new Manager("Veli", "123456786", "Şişli", "Pazarlama", 200000);
    }

    private Manager getSalesManager()
    {
        //...
        return new SalesManager("Selami", "1234567868", "Fulya", "Pazarlama", 200000, 10000);
    }

    private ProjectWorker getProjectWorker()
    {
        //...
        return new ProjectWorker("Ali", "12345678", "Mecidiyeköy", 8, 900, "Mobile", 234);
    }

    public Employee getEmployee()
    {
        return switch (m_random.nextInt(4)) {
            case 0 -> getWorker();
            case 1 -> getManager();
            case 2 -> getProjectWorker();
            default -> getSalesManager();
        };
    }
}

package org.csystem.app.company.employee;

public abstract class Employee {
    private String m_name;
    private String m_citizenId;
    private String m_address;

    //...

    protected Employee(String name, String citizenId, String address)
    {
        m_name = name;
        m_citizenId = citizenId;
        m_address = address;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        m_citizenId = citizenId;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        m_address = address;
    }

    //...

    public abstract double calculateInsurancePayment();

    public String toString()
    {
        return String.format("[%s]%s", m_citizenId, m_name);
    }
}


package org.csystem.app.company.hr;

import org.csystem.app.company.employee.Employee;
import org.csystem.util.console.Console;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        Console.writeLine("Citizen Id:%s, Name:%s", employee.getCitizenId(), employee.getName());
        Console.writeLine("Insurance payment:%f", employee.calculateInsurancePayment());
    }
}

package org.csystem.app.company.employee;

public class Manager extends Employee {
    private String m_department;
    private double m_salary;

    //...

    public Manager(String name, String citizenId, String address, String department, double salary)
    {
        super(name, citizenId, address);
        m_department = department;
        m_salary = salary;
    }

    public String getDepartment()
    {
        return m_department;
    }

    public void setDepartment(String department)
    {
        m_department = department;
    }

    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        m_salary = salary;
    }

    //...

    public double calculateInsurancePayment()
    {
        return m_salary * 1.5;
    }

    public String toString()
    {
        return String.format("%s, %s, %s", super.toString(), m_salary, m_department);
    }
}

package org.csystem.app.company.employee;

public class ProjectWorker extends Worker {
    private String m_projectName;
    private double m_extraFee;

    //...

    public ProjectWorker(String name, String citizenId, String address, int hourPerDay, double feePerHour, String projectName, double extraFee)
    {
        super(name, citizenId, address, hourPerDay, feePerHour);
        m_projectName = projectName;
        m_extraFee = extraFee;
    }

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        m_projectName = projectName;
    }

    public double getExtraFee()
    {
        return m_extraFee;
    }

    public void setExtraFee(double extraFee)
    {
        m_extraFee = extraFee;
    }

    //...

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() + m_extraFee * 30;
    }

    public String toString()
    {
        return String.format("%s, %s, %f", super.toString(), m_projectName, m_extraFee);
    }
}

package org.csystem.app.company.employee;

public class SalesManager extends Manager {
    private double m_extraFee;

    //...

    public SalesManager(String name, String citizenId, String address, String department, double salary, double extraFee)
    {
        super(name, citizenId, address, department, salary);
        m_extraFee = extraFee;
    }

    public double getExtraFee()
    {
        return m_extraFee;
    }

    public void setExtraFee(double extraFee)
    {
        m_extraFee = extraFee;
    }

    //...

    public double calculateInsurancePayment()
    {
        return super.calculateInsurancePayment() + m_extraFee;
    }

    public String toString()
    {
        return String.format("%s, %f", super.toString(), m_extraFee);
    }
}

package org.csystem.app.company.employee;

public class Worker extends Employee {
    private int m_hourPerDay;
    private double m_feePerHour;

    //...

    public Worker(String name, String citizenId, String address, int hourPerDay, double feePerHour)
    {
        super(name, citizenId, address);
        m_hourPerDay = hourPerDay;
        m_feePerHour = feePerHour;
    }

    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        m_feePerHour = feePerHour;
    }

    public double calculateInsurancePayment()
    {
        return m_feePerHour * m_hourPerDay * 30;
    }

    //...

    public String toString()
    {
        return String.format("%s, %d, %f", super.toString(), m_hourPerDay, m_feePerHour);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Non-static bir metot final olarak bildirildiğinde o metot artık override edilemez. Bu durumda final bir metot sanal
    değildir. Bir metot override edildikten sonra da final yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class D extends C {
    public void bar() //error
    {
        //...
    }
}

class C extends A {
    public final void bar()
    {
        //...
    }
}
class B extends A {
    public void foo() //error
    {

    }
}
class A {
    public final void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal bir metot override edilirken erişim belirleyicisi erişim anlamında yükseltilebilir ancak düşürülemez. Yani
    örneğin protected olarak bildirilmiş bir sanal metot public olarak override edilebilir. protected olarak da override
    edilebilir ancak no-modifier olarak override edilemez. Bu durumda public olarak bildirilmiş sanal bir metot yalnızca
    public olarak override edilebilir. private metotlar sanal olmazlar, dolayısıyla override edilmeleri söz konusu değildir.
    Türemiş sınıf içerisinde private metot ile aynı geri dönüş değerine ve aynı imzaya sahip bir metot olabilir. Ancak
    bu override etmek değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class D extends A {
    void foo() //error
    {
        //...
    }

    protected void bar() //error
    {

    }
}

class C extends A {
    public void foo()
    {
        //...
    }
}

class B extends A {
    protected void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }

    private void tar()
    {
        //...
    }
}

class A {
    private void tar()
    {
        //...
    }

    protected void foo()
    {
        //...
    }
    public void bar()
    {
        //...
    }
}

/*--------------------------------------------------------
	FILE NAME	: Console.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 10th February 2024

	Utility class for console operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.console;

import java.util.Scanner;

public final class Console {
    private static final Scanner KB = new Scanner(System.in);

    private Console()
    {
    }

    public static int readInt(String prompt)
    {
        write(prompt);
        return Integer.parseInt(KB.nextLine());
    }

    public static long readLong(String prompt)
    {
        write(prompt);
        return Long.parseLong(KB.nextLine());
    }

    public static double readDouble(String prompt)
    {
        write(prompt);
        return Double.parseDouble(KB.nextLine());
    }

    public static String readString(String prompt)
    {
        write(prompt);
        return KB.nextLine();
    }

    public static void write(String fmt, Object...params)
    {
        System.out.printf(fmt, params);
    }

    public static void write(Object o)
    {
        write("%s", o);
    }

    public static void writeLine()
    {
        System.out.println();
    }

    public static void writeLine(String fmt, Object...params)
    {
        write(fmt + "\n", params);
    }

    public static void writeLine(Object o)
    {
        writeLine("%s", o);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Exception işlemleri: Anımsanacağı gibi programın çalışma zamanı sırasında oluşan genel olarak hatalı durumlara
    "exception" ya da "runtime error" denir. Bir exception oluştuğunda akışın oluşan exception'a göre yönlendirilmesine
    "exception handling" denir. Örneğin bir konum bilgisi veren uygulamanın, konum bilgisi elde edilemediğinde oluşan
    exception'a göre kullanıcıyı uygun mesajla bilgilendirmesi işlemi exception handling yapılarak gerçekleştirilebilir.

    Exception işlemleri Java'da 5 tane anahtar sözcük ile gerçekleştirilir: throw, try, catch, finally, throws.

    Akış içerisinde bir exception oluşturulması (fırlatılması) için throw deyimi kullanılır. throw deyiminin genel
    biçimi şu şekildedir:

        throw <referans>;

    Burada referansa ilişkin türün Throwable sınıfından doğrudan ya da dolaylı olarak türetilmiş bir sınıf türünden
    olması zorunludur. Akış, throw deyimine geldiğinde metodu terkeder. Bu terkediş return deyimi ya da void metotlardaki
    gibi metodun sonuna gelindiğinde akışın çağrılan noktaya geri dönmesi biçiminde bir sonlanma değildir.

    Anahtar Notlar: Throwable sınıfından doğrudan ya da dolaylı olarak türetilmiş sınıflara "exception sınıfları (exception classes)"
    denir. Bir convention olarak Error sınıfınden doğrudan ya da dolaylı olarak türetilen sınıflar dışındaki exception
    sınıflarının isimlendirmesinde son kelime olarak "Exception" kullanılır.

    Akış exception bakımından ele alınacaksa (handling) try deyimi (try statement) içerisinde yazılmalıdır. try deyimi
    tek başına olamaz. try deyiminden sonra bir catch bloğu veya blokları veya finally bloğu veya catch blokları ile
    birlikte finally bloğu olabilir. try deyiminde bu bloklar arasında herhangi bir deyim yazılamaz. Yani try deyimi
    takip eden bloklarla birlikte tek bir deyimdir.

    catch bloğu parantezi içerisinde bir referans bildirilir. Bu referansa catch parametresi de denilmektedir. Bu
    parametre bir exception sınıfı türünden olmalıdır. Aksi durumda error oluşur.

    Anahtar Notlar: catch parametre referansı catch bloğu içerisinde kullanılmayacaksa yine bir convention isimlendirmede
    "ignore" yada "ignored" kullanılması okunabilirlik açısından iyi bir tekniktir.

    try deyimi içerisinde bir exception oluştuğunda akış try bloğunu bir daha geri dönmemek üzere (non-resumptive) terkeder.
    Bu durumda try deyimine ilişkin ilk catch bloğuna dallanır. catch blokları yukarıdan aşağıya taranır ve ilk uygun
    catch bloğu çalıştırılır. Uygun catch bloğu fırlatılan exception nesnesine ilişkin referansın atanabildiği ilk
    catch bloğudur. Bu durumda bir catch bloğu çalıştırıldıktan sonra o try deyimine ilişkin diğer catch blokları
    atlanır ve akış devam eder. Uygun catch bloğunun bulunamaması durumunda akışın nasıl ilerleyeceği ileride ele
    alınacaktır. Akış try bloğunun sonuna gelirse yani try bloğunda hiç exception oluşmazsa akış tüm catch blokları
    atlanarak devam eder. try bloğu içerisinde bir exception oluşur ve uygun catch bloğu bulunamazsa yani exception
    yakalanamazsa bu durumda varsa onu kapsayan try bloğuna ilişkin catch bloklarına bakılır. Bu durum uygun catch
    bloğu bulununcaya veya hiç bulunamayıncaya kadar devam eder. Uygun catch bloğu bulunamazsa program abnormal bir biçimde
    sonlanır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneke fırlatılan referansa ilişkin sınıf Throwable olmadığından yani doğrudan ya da dolaylı olarak
    Throwable sınıfından türetilmediğinden error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {

    }
}


class MathUtil {
    public static double log(double a)
    {
        if (a <= 0)
            throw new MathException(); //error

    }
}

class MathException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            double val = Console.readDouble("Input a value:");
            double result = MathUtil.log(val);

            Console.writeLine("log(%f) = %f", val, result);
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        catch (IndeterminateException ignore) {
            Console.writeLine("Indeterminate!...");
        }
        Console.writeLine("main ends!...");
    }
}


class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte dolaylı olarak içiçe try blokları vardır. run metodunu yazan programcı dökumanı içerisinde
    fırlattığı exception'ları belirtir. Dikkat edilirse run metodu IndeterminateException fırlatmamaktadır. Bu metot
    dökumanında UndefinecException ve NumberFormatException fırlattığını söyler. Örnekte NumberFormatException
    fırlatıldığında yakalayan uygun bir catch bloğu bulunamadığından program abnormal bir biçimde sonlanır. Örneği
    çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }

        Console.writeLine("main ends!...");
    }
}


class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");
            double result = MathUtil.log(val);

            Console.writeLine("log(%f) = %f", val, result);
        }
        catch (IndeterminateException ignore) {
            Console.writeLine("run:Indeterminate!...");
        }

        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    18.02.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Bazen bir metot bir exception oluştuğunda onu handle eder ancak o metodu çağıran metodun da o exception'dan haberi
    olmasını ister. Bu durumda catch bloğunda ilgili işlem yapıldıktan sonra aynı referansın yeniden fırlatılması gerekir.
    Bu işleme "re-throw" denir. Şüphesiz re-throw yapan metodun dökumanlarında ilgili exception'ı da fırlattığı
    söylenmelidir. Ancak dökümanlarda re-throw ettiği söylenmeyebilir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        catch (IndeterminateException ex) {
            Console.writeLine("main:Indeterminate!...");
        }

        Console.writeLine("main ends!...");
    }
}


class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");
            double result = MathUtil.log(val);

            Console.writeLine("log(%f) = %f", val, result);
        }
        catch (IndeterminateException ex) {
            Console.writeLine("run:Indeterminate!...");
            throw ex; //re-throw
        }

        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Taban sınıf türünden parametreli catch bloğu ile türemiş sınıf türünden bir exception'ı yakalanabilir. Bu işlem
    aslında upcasting işlemidir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ignore) {
            Console.writeLine("Math exception occurred!...");
        }

        Console.writeLine("main ends!...");
    }
}


class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");
            double result = MathUtil.log(val);

            Console.writeLine("log(%f) = %f", val, result);
        }
        catch (IndeterminateException ex) {
            Console.writeLine("run:Indeterminate!...");
            throw ex;
        }
        catch (NumberFormatException ignore) {
            Console.writeLine("Invalid number format!...");
        }

        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends MathException {
    //...
}

class IndeterminateException extends MathException {
    //...
}

class MathException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte UndefinedException fırlatıldığında ayrı catch bloğu ile yakalanmıştır. Çünkü uygun catch
    bloğu araması yukarıdan aşağıya yapılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        catch (MathException ignore) {
            Console.writeLine("Math exception occurred!...");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (NumberFormatException ignore) {
            Console.writeLine("Invalid number format!...");
        }

        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends MathException {
    //...
}

class IndeterminateException extends MathException {
    //...
}

class MathException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf parametreli catch bloğu taban sınıf parametreli catch bloğundan önce yazılmalıdır. Aksi durumda akış
    hiç bir zaman türemiş sınıf catch bloğuna gelemeceğinden error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ignore) {
            Console.writeLine("Math exception occurred!...");
        }
        catch (UndefinedException ignore) { //error
            Console.writeLine("Undefined!...");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (NumberFormatException ignore) {
            Console.writeLine("Invalid number format!...");
        }

        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends MathException {
    //...
}

class IndeterminateException extends MathException {
    //...
}

class MathException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable parametreli catch bloğu ile tüm exception'lar yakalanabilir. Bu durumda Throwable parametreli catch
    bloğunun en son catch bloğu olarak yazılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        catch (Throwable ignore) {
            Console.writeLine("Exception occurred!...");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        double val = Console.readDouble("Input a value:");

        Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    finally bloğu akış try bloğundan nasıl çıkarsa çıksın çalıştırılan bloktur. finally bloğu tüm catch bloklarından
    sonra gelmelidir. Eğer exception oluşmuşsa ve yakalanmışsa catch bloğundan sonra çalıştırılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (IndeterminateException ignore) {
            Console.writeLine("Indeterminate!...");
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    finally bloğunda tipik olarak akış içerisinde exception oluşsa da oluşmasa da yapılacak ortak bir işe ilişkin kodlar
    yazılır. Örneğin bir dosya açıldığında dosya ile işlemler yapıldıktan sonra dosyanın kapatılması gerekir. Bu durumda
    dosya ile işlemler yapılırken bir exception oluşursa da dosyanın kapatılabilmesi için kapatmaya ilişkin kodlar finally
    bloğunda yazılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    try deyiminde finaly bloğu hiç catch bloğu olmadan da yazılabilir. Bu durumda programce exception oluşsa da oluşmasa
    da yapacağı işi finally bloğuna yazmıştır. Ancak fırlatılan exceptionn'ı yakalamamıştır. Aşağıdaki demo örneği
    inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (IndeterminateException ignore) {
            Console.writeLine("Indeterminate!...");
        }
        catch (UndefinedException ignore) {
            Console.writeLine("Undefined!...");
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new UndefinedException();

        if (a < 0)
            throw new IndeterminateException();

        return Math.log(a);
    }
}

class UndefinedException extends RuntimeException {
    //...
}

class IndeterminateException extends RuntimeException {
    //...
}
/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        Console.writeLine(Sample.foo("foo")); //fooreturnfinally
    }
}

class Sample {
    public static StringBuilder foo(String str)
    {
        StringBuilder sb = new StringBuilder(str);

        try {
            return sb.append("return");
        }
        finally {
            sb.append("finally");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        Console.writeLine(Sample.foo("foo")); //fooreturn
    }
}

class Sample {
    public static String foo(String str)
    {
        StringBuilder sb = new StringBuilder(str);

        try {
            return sb.append("return").toString();
        }
        finally {
            sb.append("finally");
        }
    }
}

/*--------------------------------------------------------
	FILE NAME	: Console.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 18th February 2024

	Utility class for console operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.console;

import java.util.Scanner;

public final class Console {
    private static final Scanner KB = new Scanner(System.in);

    private Console()
    {
    }

    public static int readInt()
    {
        return readInt("");
    }

    public static int readInt(String prompt)
    {
        return readInt(prompt, "");
    }

    public static int readInt(String prompt, String errorPrompt)
    {
        while (true) {
            try {
                write(prompt);
                return Integer.parseInt(KB.nextLine());
            }
            catch (NumberFormatException ignore) {
                write(errorPrompt);
            }
        }
    }

    public static long readLong()
    {
        return readLong("");
    }

    public static long readLong(String prompt)
    {
        return readLong(prompt, "");
    }

    public static long readLong(String prompt, String errorPrompt)
    {
        while (true) {
            try {
                write(prompt);
                return Long.parseLong(KB.nextLine());
            }
            catch (NumberFormatException ignore) {
                write(errorPrompt);
            }
        }
    }

    public static double readDouble()
    {
        return readDouble("");
    }

    public static double readDouble(String prompt)
    {
        return readDouble(prompt, "");
    }

    public static double readDouble(String prompt, String errorPrompt)
    {
        while (true) {
            try {
                write(prompt);
                return Double.parseDouble(KB.nextLine());
            }
            catch (NumberFormatException ignore) {
                write(errorPrompt);
            }
        }
    }

    public static short readShort()
    {
        return readShort("");
    }

    public static short readShort(String prompt)
    {
        return readShort(prompt, "");
    }

    public static short readShort(String prompt, String errorPrompt)
    {
        while (true) {
            try {
                write(prompt);
                return Short.parseShort(KB.nextLine());
            }
            catch (NumberFormatException ignore) {
                write(errorPrompt);
            }
        }
    }

    public static byte readByte()
    {
        return readByte("");
    }

    public static byte readByte(String prompt)
    {
        return readByte(prompt, "");
    }

    public static byte readByte(String prompt, String errorPrompt)
    {
        while (true) {
            try {
                write(prompt);
                return Byte.parseByte(KB.nextLine());
            }
            catch (NumberFormatException ignore) {
                write(errorPrompt);
            }
        }
    }

    public static boolean readBoolean()
    {
        return readBoolean("");
    }

    public static boolean readBoolean(String prompt)
    {
        return readBoolean(prompt, "");
    }

    public static boolean readBoolean(String prompt, String errorPrompt)
    {
        while (true) {
            write(prompt);
            String str = KB.nextLine();

            if (str.equalsIgnoreCase("false") || str.equalsIgnoreCase("true"))
                return Boolean.parseBoolean(str);

            write(errorPrompt);
        }
    }

    public static char readChar()
    {
        return readChar("");
    }

    public static char readChar(String prompt)
    {
        return readChar(prompt, "");
    }

    public static char readChar(String prompt, String errorPrompt)
    {
        while (true) {
            write(prompt);
            String str = KB.nextLine();

            if (str.length() <= 1)
                return str.isEmpty() ? '\n' : str.charAt(0);

            write(errorPrompt);
        }
    }

    public static String readString(String prompt)
    {
        write(prompt);
        return KB.nextLine();
    }

    public static void write(String fmt, Object...params)
    {
        System.out.printf(fmt, params);
    }

    public static void write(Object o)
    {
        write("%s", o);
    }

    public static void writeLine()
    {
        System.out.println();
    }

    public static void writeLine(String fmt, Object...params)
    {
        write(fmt + "\n", params);
    }

    public static void writeLine(Object o)
    {
        writeLine("%s", o);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir exception sınıfı içerisinde çeşitli veriler tutularak kullanılabilir. Bu anlamda Throwable sınıfı içerisinde de
    bazı veri elemanları tutulmaktadır. Bunlardan en tipik olarak String türden olan ve message (detail message) elemanıdır.
    Bu anlamdaThrowable sınıfının message parametreli ctor'ları bulunur. Ayrıca message değerini elde etmek için de
    getMessage isimli bir metot da vardır. Bu sınıftan türetilen sınıflarda genel olarak message parametreli ctor veya
    ctor'lar bulundurulur. Örneğin Exception, RuntimeException ve Error sınıflarında da message parametreli ctor'lar vardır.
    Programcı da isterse kendi exception sınıfına başka veri elemanları ekleyebilir. getMessage metodu sanaldır. İstenirse
    override edilebilir. Throwable sınıfı içerisinde Throwable türünden bir referans da tutulmaktadır. Yani Throwable
    sınıfı aslında bir exception referansını da tutabilmektedir. Tututlan bu exception referansına cause denilmektedir.
    Ayrıca Throwable parametreli ctor'ları ve getCause metodu da vardır. Cause bilgisi bir exception içerisinde exception
    oluşmasına sebep olan bir exception referansının tutulması için düşünülmüştür. Bu kavrama "inner exception" da
    denilmektedir. Cause kullanımı ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) {
            Console.writeLine("Message:%s, Status:%s", ex.getMessage(), ex.getMathExceptionStatus());
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new MathException("Undefined", MathExceptionStatus.NEGATIVE_INFINITY);


        if (a < 0)
            throw new MathException("Indeterminate", MathExceptionStatus.NAN);

        return Math.log(a);
    }
}

class MathException extends RuntimeException {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz. Örnekte MathException sınıfında getMessage metodu override edildiğinden, MathException
    fırlatıldığında, Throwable parametreli catch bloğunda RTP gereği MathException sınıfının getMessage metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (Throwable ex) {
            Console.writeLine(ex.getMessage());
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new MathException("Undefined", MathExceptionStatus.NEGATIVE_INFINITY);

        if (a < 0)
            throw new MathException("Indeterminate", MathExceptionStatus.NAN);

        return Math.log(a);
    }
}

class MathException extends RuntimeException {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) {
            Console.writeLine(ex.getMessage());
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends RuntimeException {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfının printStackTrace metotları exception oluşma noktalarını bir stack olarak gösteren bir mesajı
    ilgili output'a gönderir. Parametresiz printStackTrace metodu ekrana (aslında stderr'ye) basmak için kullanılabilir.
    Basılan mesaj exception'dan dolayı akış sonlanırken basılan mesaja çok benzer. Bu mesajlar tipik olarak geliştirme
    aşamasında debug etmek için kullanılabilmektedir

    Anahtar Notlar: Bir takım bilgilerin daha sonra incelenmek üzere saklanmasına yazılım geliştirmede "logging" denir.
    Örneğin uygulama test aşamasında çalıştırılırken bir takım hata mesajları saklanarak daha sonra incelenebilir. Bunun
    için her ne kadar printStackTrace metotları kullanılabilese de daha detaylı durumlar için bu mesajlar yetersiz
    kalabilmektedir. Bu durumda bazı "logger" denilen üçüncü parti kütüphaneler kullanılır. Bu sebeple printStackTrace
    kullanımında bazı static kod analizi araçları uyarı mesajı verebilirler. Logger'lar Java ile Uygulama kurslarında
    kullanılacak ve çeşitli düzeylerde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceliyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) {
            ex.printStackTrace();
        }
        finally {
            Console.writeLine("main:finally");
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends RuntimeException {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Java'da exception'lar kategori olarak iki gruba ayrılmaktadır: checked, unchecked

    checked exception: Bir exception sınıfının doğrudan taban sınıfı ya da dolaylı taban sınıflarından biri, RuntimeException
    ve Error sınıflarından biri değilse sınıf checked exception sınıfıdır.

    unchecked exception: checked exception olmayan exception sınıflarıdır

    Bu tanımlara göre türemiş exception sınıfın kategorisi, taban sınıfının kategorisi ile aynıdır ve değiştirilemez.

    Anahtar Notlar: Bir exception'ın checked ya da unchecked olması çalışma zamanına ilişkin bir kavramm değildir. Derleme
    zamanında checked exception'lar bazı zorunluluklar bulunmaktadır. Kategori ne olursa olsun çalışma zamanında exception
    işlemlerine ilişkin bir değişiklik yoktur.

    Anahtar Notlar: Bir convention olarak bir exception sınıfı doğrudan Throwable sınıfından türetilmez. Ya Exception,
    ya RuntimeException ya da Error sınıfından doğrudan ya da dolaylı olarak türetilir. Bu convention'a göre Throwable
    sınıfı exception sınıflarının dolaylı taban sınıfı olur.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Bir sınıf checked bir sınıfı ise bu durumda, bu exception'ın fırlatılma potansiyeli olan bir akışın ya try deyimi
   içerisinde olup uygun catch bloğunun bulunması ya da akışa ilişkin meotta throws bildirimi yapılması gerekir. Aksi
   durumda error oluşur. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) {
            Console.writeLine(ex.getMessage());
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run() throws NaNException
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (NegativeInfinityException ex) {
            Console.writeLine("run:%s", ex.getMessage());
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a) throws NegativeInfinityException, NaNException
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
   throws listesinde taban exception sınıfı varsa ondan türemiş exception listeye konmayabilir. Konması error oluşturmaz.
   Ancak böyle durumda bir koymamayı tercih edeceğiz. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) {
            Console.writeLine(ex.getMessage());
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run() throws MathException
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (NegativeInfinityException ex) {
            Console.writeLine("run:%s", ex.getMessage());
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a) throws MathException
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
   Bir catch bloğunun parametresi checked bir exception türündense ilgili try bloğu içerisinde o exception'ın fırlatabileceği
   en az bir deyimin bulunması gerekir. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (MathException ex) { //error
            Console.writeLine(ex.getMessage());
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (MathException ex) {
            Console.writeLine("run:%s", ex.getMessage());
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a) throws MathException
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kural Exception ve Throwable sınıfları geçersizdir. Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (Exception ex) {
            Console.writeLine(ex.getMessage());
        }

        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        try {
            double val = Console.readDouble("Input a value:", "Invalid value!...");

            Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
        }
        catch (MathException ex) {
            Console.writeLine("run:%s", ex.getMessage());
        }
        finally {
            Console.writeLine("run:finally");
        }
        Console.writeLine("run ends!...");
    }
}

class MathUtil {
    public static double log(double a) throws MathException
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: throws bildirimi metodun imzasına dahil değildir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	24.02.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	throws listesi olan sanal bir metot override edildiğinde, throws listesi anlamında şu kurallar söz konusudur
	- throws listesine ilişkin sınıflar override edilen metotta yazılmayabilir. Bu durumda hiç throws bildirimi de
	yapılmayabilir.

	- override edilen metotta throws listesine, sanal metodun throws listesinde bulunan sınıflar veya bu sınıflardan
	doğrudan ya da dolaylı olarak türetilmiş exception sınıfları yazılabilir.

	Bu kurallara göre override edilen metotta, sanal metodun throws listesinde bulunmayan bir checked exception sınıfı
	throws listesinde yazıldığında error oluşur

	Aşağıdaki demo örnekte E sınıfının foo metodunda MathException fırlatıldığından ya throws listesine yazılması ya da
	foo metodu içerisinde yakalanıp işlenmesi gerekir. Bu durumda throws listesine yazılması error oluşturur. Çünkü taban
	türdeki sanal metodun throws listesinde MathException'ın kendisi veya doğrudan ya da dolaylı taban sınıflarından biri
	yoktur. Demo örnekte abstract sınıfın ve doWork metodunun değiştirilemedğini varsayınız
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public static void doWork() throws MathException
    {
        //...
    }
}

class E extends A {
    public void foo() throws MathException //error
    {
        //...

        Sample.doWork();
    }
}

class E extends A {
    public void foo() throws MathException //error
    {
        //...
    }
}

class D extends A {
    public void foo() throws IndeterminateException
    {
        //...
    }
}

class C extends A {
    public void foo()
    {
        //...
    }
}

class B extends A {
    public void foo() throws NaNException
    {
        //...
    }
}


abstract class A {
    public abstract void foo() throws NegativeInfinityException, NaNException;
}

class IndeterminateException extends NaNException {
    public IndeterminateException(String message)
    {
        super(message);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki gibi bir durumda programcı abstract sınıfı değiştiremeyeceğine göre E sınfında algoritmasını değiştirilmeldir.
    Örnekte unchecked bir exception sınıfı ile checked exception sınıfı sarmalanarak (cause) fırlatılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public static void doWork() throws MathException
    {
        //...
    }
}

class E extends A {
    public void foo()
    {
        //...
        try {
            Sample.doWork();
        }
        catch (MathException ex) {
            throw new WrapperException("foo", ex);
        }
    }
}

class D extends A {
    public void foo() throws IndeterminateException
    {
        //...
    }
}

class C extends A {
    public void foo()
    {
        //...
    }
}

class B extends A {
    public void foo() throws NaNException
    {
        //...
    }
}

abstract class A {
    public abstract void foo() throws NegativeInfinityException, NaNException;
}

class WrapperException extends RuntimeException {
    public WrapperException(String message, Throwable cause)
    {
        super(message, cause);
    }

    public String getMessage()
    {
        Throwable cause = getCause();

        return String.format("Message:%s%s", super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
    }
}

class IndeterminateException extends NaNException {
    public IndeterminateException(String message)
    {
        super(message);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukardaki örnekte abstract sınıf değiştirilebilseydi aşağıdaki gibi bir yaklaşımla da problem çözülebilirdi. Örnekte
    abstract metodun throws bildiriminde Exception sınıfı yazıldığından ve tüm "checked exception" sınıfları Exception
    sınıfından doğrudan ya da dolaylı olarak türetildiğinden artık her checked exception throws listesine yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
    public static void doWork() throws MathException
    {
        //...
    }
}

class E extends A {
    public void foo() throws MathException
    {
        //...
        Sample.doWork();
    }
}

class D extends A {
    public void foo() throws IndeterminateException
    {
        //...
    }
}

class C extends A {
    public void foo()
    {
        //...
    }
}

class B extends A {
    public void foo() throws NaNException
    {
        //...
    }
}

abstract class A {
    public abstract void foo() throws Exception;
}

class IndeterminateException extends NaNException {
    public IndeterminateException(String message)
    {
        super(message);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends Exception {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Dikkat edilirse checked exception sınıfları her ne kadar programcıyı "handle" etmeye zorlasa da
    yani bu durum iyi olarak düşünülebilse de bazı noktalarda strateji değiştirmek zorunda kalması programcı açısından
    kod yazma bütünlüğünü etkileyebilmektedir. Bu sebeple bazı programcılar checked exception kavramını eleştirirler.
    Ayrıca exception kavramının çalışma zamanına ilişkin olması dolayısıyla, checked exception kavramında derleme
    zamanına özgü kısıtlamaların olması da bazı programcılar tarafından eleştirilmesine yol açar. Java'nın exception
    kavramını örnek aldığı C++ programlama dilinde ve Java'yı örnek alan popüler programlama dillerinin hiç birisinde
    exception kavramı checked ve unchecked olarak ayrılmamıştır. Her ne kadar eleştirilse de bir Java programcısının
    checked ve unchecked ayrımını iyi bilmesi ve kodlarını da ona göre uygun düzenlemesi gerekir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bütün bu anlatılanlara göre aşağıdaki iki soru sorulabilir:
	1. Programcı bir exception sınıfını ne zaman yazacaktır yani yazıp yazmacağına nasıl karar verecektir? JavaSE'de
	pek çok exception sınıfı bulunur. Bu durumda programcı bir exception fırlatması gerektiğinde önce JavaSE'de domain'ine
	uygun bir exception sınıfı olup olmadığına bakmalıdır. Eğer varsa onu kullanmalıdır. Yoksa kullandığı teknolojiye
	ilişkin kütüphanelerde domain'ine uygun bir exception sınıfı varsa onu kullanmalıdır. Yoksa artık exception sınıfı
	yazmalıdır.

	2. Programcı bir exception yazacaksa, sınıfı checked veya unchecked yapacağına nasıl karar verecektir? Aslında bu
	durum, programcıdan programcıya yaklaşımsal olarak farklıdır. Bazı programcılar eğer bir zorunluluk yoksa checked
	exception sınıfı yazmazlar. Burada zorunlu durumlardan biri, bir checked exception sınıfından türetme yapmaktır. Biz de
	zorunlu olmadıkça checked exception kategorisinde bir sınıf yazmayacağız. Bazı programcılar ise genel olarak kritik
	gördükleri yani hemen her durumda handle edilmesi gereken exception sınıflarını checked yapma eğilimindedir. Buradaki
	iki teknik için de kötü ya da iyi denemez. Bunlar birer yaklaşımdır ve programcıdan programcıya değişiklik gösterebilir.
	Ancak, checked exception sınıflarının bazı durumlarda programcının strateji değiştirmesine sebep olduğu da unutlmamalıdır.
	Bu anlamda birinci yaklaşımı benimseyen programcılar, "Bir exception'ın kritik olup olmayacağına zaten programcı
	karar vermek durumundadır. Bu durumda zorunlu bırakılması anlamsızdır" şeklinde düşünürler. İkinci yaklaşımı benmseyen
	programcılar ise, "Önemli exception'lar	checked yapılarak programcının handle etmesi gerektiğinin farkına vardırırlar"
	şeklinde düşünürler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	JavaSE'de bulunan çok kullanılan bazı exception sınıfları:
	IllegalArgumentException: Genel olarak bir metodun parametresine geçilen argümanın geçersiz olması durumunda fırlatılan
	exception sınıfıdır. Konuya özgü olarak bu sınıftan türetilmiş exception sınıfları da bulunmaktadır.

	ClassCastException: Downcasting işleminde haksız dönüşüm olduğunda JVM tarafından fırlatılır. Haksız dönüşümün
	kontrolü için handle edilebilir ancak bunun yerine instanceof operatörü ve benzeri araçlarla kullanımı tavsiye
	edilir. Bu exception programcı tarafından bir metot içerisinde fırlatılmaz.

	NumberFormatException: IllegalArgumentException sınıfından türetilmiştir. Sarmalayan sınıfların parseXXX metotları
	(Boolean sınıfının parseBoolean metodu hariç) yazıyı ilgili temel türe çeviremezlerse bu exception'ı fırlatırlar.

	NoSuchElementException: Tipik olarak bir elemanın yokluğu durumunda kullanılır.

	InputMismatchException: Bu sınıf tipik olarak bir girdinin geçersizliği durumunda kullanılır. Örneğin Scanner sınıfının
	çeşitli metotları (nextInt, nextDouble, nextLong gibi) bu exception'ı fırlatırlar. Bu sınıf NoSuchElementException
	sınıfından türetilmiştir.

	ArrayIndexOutOfBoundsException: Bu exception özel olarak dizinin indeks numarasının geçersiz olduğu durumlarda JVM
	tarafından fırlatılır.

	IndexOutOfBoundsException: Bu exception sınıfı indeks taşmalarında kullanılır. Örneğin ArrayList sınıfının bazı
	metotları bu exception'ı fırlatırlar.

	NullPointerException: Bir referansın null değeri tutması durumunda o referans ile non-static bir elemana erişilmeye
	çalışıldığında fırlatılır. Bu exception sınıfının programlamada handle edilmesi tavsiye edilmez. Genel olarak bu
	duruma yol açabilecek kod parçaları yazılmamalıdır ya da yazılmışsa da düzeltilmelidir.

	UmSupportedOperationException: Tipik olarak bir metodun o tür için desteklenmediği ancak bulunması gerektiği durumda
	kullanılır.

	IOException: Input ve/veya output durumlarında kullanılan checked bir exception sınıfıdır. Bu exception sınıfından da
	önemli bazı exception sınıfları türetilmiştir.

	Yukarıdaki exception sınıfları dışında da pek çok exception sınıfı bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: Circle.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 24th February 2024

	Circle class that represents a circle

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    protected static final double DELTA = 0.000001;
    private double m_radius;

    public Circle()
    {
    }

    public Circle(double radius)
    {
        setRadius(radius);
    }

    public void setRadius(double radius)
    {
        if (radius < 0)
            throw new IllegalArgumentException(String.format("Radius must be non-negative:%f", radius));

        m_radius = radius;
    }

    public double getRadius()
    {
        return m_radius;
    }

    public double getArea()
    {
        return Math.PI * m_radius * m_radius;
    }

    public double getCircumference()
    {
        return 2 * Math.PI * m_radius;
    }

    public boolean equals(Object other)
    {
        return other instanceof Circle c && Math.abs(m_radius - c.m_radius) < DELTA;
    }

    //hashCode

    public String toString()
    {
        return String.format("Radius:%f, Area:%f, Circumference:%f", m_radius, getArea(), getCircumference());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aralarında türetme ilişkisi olmayan birden fazla exception sınıfı fırlatma ihtimali olan bir akışta, tüm bu exception'lar
    için ortak bir işlem yapılacaksa catch bloğunda exception sınıfları | atomu ile birbirinden ayrılabilir. Bu durumda
    catch bloğu içerisinde exception sınıflarına ilişkin yalnızca ortak elemanlara erişilebilir. Bu sentaksa yazılan
    exception sınıflarının aralarında türetme ilişkisi olması error oluşturur. Bu sentaks Java 7 ile dile eklenmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.InputMismatchException;
import java.util.Scanner;

class App {
    public static void main(String[] args)
    {
        try {
            DemoApp.run();
        }
        catch (InputMismatchException | MathException ex) {
            String message = ex.getMessage();

            Console.writeLine("Exception occurred%s", message != null ? ":" + message : "");
        }
        Console.writeLine("main ends!...");
    }
}

class DemoApp {
    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Input a number:");
        double val = kb.nextDouble();

        Console.writeLine("log(%f) = %f", val, MathUtil.log(val));
    }
}

class MathUtil {
    public static double log(double a)
    {
        if (a == 0)
            throw new NegativeInfinityException("Undefined");

        if (a < 0)
            throw new NaNException("Indeterminate");

        return Math.log(a);
    }
}

class NaNException extends MathException {
    public NaNException(String message)
    {
        super(message, MathExceptionStatus.NAN);
    }
}

class NegativeInfinityException extends MathException {
    public NegativeInfinityException(String message)
    {
        super(message, MathExceptionStatus.NEGATIVE_INFINITY);
    }
}

class MathException extends RuntimeException {
    private final MathExceptionStatus m_mathExceptionStatus;

    public MathException(String message, MathExceptionStatus mathExceptionStatus)
    {
        super(message);
        m_mathExceptionStatus = mathExceptionStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_mathExceptionStatus);
    }

    public MathExceptionStatus getMathExceptionStatus()
    {
        return m_mathExceptionStatus;
    }
}

enum MathExceptionStatus {
    NAN, INFINITY, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED, INDETERMINATE
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın içerisinde tüm metotların dışında static anahtar sözcüğü ile bildirilen bloklara "static initializer"
    denilmektedir. Sınıfın static initializer'ı sınıfın bir elemanı ilk kez kullanıldığında bir kez olmak üzere
    çalıştırılır. Sınıf içerisinde birden fazla static initializer bildirilebilir. Çalıştırılma sırası bildirim sırası
    ile aynıdır. static initializer static metot etkisindedir. Sınıfın static initializer'ı içerisinde final ve static
    olarak bildirilmiş veri elemanlarına değer verilebilir. Sınıfın birden fazla static initializer'ı varsa şüphesiz
    yalnızca bir tanesinde değer verilebilir.

    Bir sınıfın içerisinde tüm metotlşarın dışında bildirilen bloklara "non-static initializer" denilmektedir. Sınıfın
    non-static initializer'ı herhangi bir ctor'dan önce çalıştırılır. Yani ctor'un başına gizlice non-static initializer
    kodları yerleştirilir. Sınıf içerisinde birden fazla non-static initializer bildirilebilir. Çalıştırılma sırası
    bildirim sırası ile aynıdır. Non-static initializer non-static metot etkisindedir. Sınıfın non-static initializer'ı
    içerisinde final olarak bildirilmiş non-static veri elemanlarına değer verilebilir. Sınıfın birden fazla non-static
    initializer'ı varsa şüphesiz yalnızca bir tanesinde değer verilebilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        Sample.foo();
        Console.writeLine("-------------------------------");
        Sample.foo();
        Console.writeLine("-------------------------------");
        Sample s = new Sample();
        Console.writeLine("-------------------------------");
        Sample k = new Sample(10);

    }
}

class Sample {
    static {
        Console.writeLine("static initializer-1");
    }
    static {
        Console.writeLine("static initializer-2");
    }

    {
        Console.writeLine("non-static initializer-1");
    }

    {
        Console.writeLine("non-static initializer-2");
    }

    public Sample()
    {
        Console.writeLine("I am a default ctor");
    }

    public Sample(int a)
    {
        Console.writeLine("I am a ctor with parameter type int");
    }

    public static void foo()
    {
        Console.writeLine("foo");
    }
}

/*--------------------------------------------------------
	FILE NAME	: StringUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 24th February 2024

	Utility class for string operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.string;

import java.util.Random;

public final class StringUtil {
	private static final String LETTERS_EN;
	private static final String LETTERS_TR;
	private static final String LETTERS_CAPITAL_EN;
	private static final String LETTERS_CAPITAL_TR;
	private static final String LETTERS_ALL_EN;
	private static final String LETTERS_ALL_TR;

	static {
		LETTERS_EN = "abcdefghijklmnopqrstuvwxyz";
		LETTERS_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
		LETTERS_CAPITAL_EN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		LETTERS_CAPITAL_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
		LETTERS_ALL_EN = LETTERS_EN + LETTERS_CAPITAL_EN;
		LETTERS_ALL_TR = LETTERS_TR + LETTERS_CAPITAL_TR;
	}

	private StringUtil()
	{
	}

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;

		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String generateRandomTextEN(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_EN);
	}

	public static String generateRandomTextTR(Random random, int count)
	{
		return generateRandomText(random, count, LETTERS_ALL_TR);
	}

	public static String generateRandomText(Random random, int count, String sourceText)
	{
		StringBuilder sb = new StringBuilder(count);
		int len = sourceText.length();

		for (int i = 0; i < count; ++i)
			sb.append(sourceText.charAt(random.nextInt(len)));

		return sb.toString();
	}

	public static String [] generateRandomTextsEN(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_EN);
	}

	public static String [] generateRandomTextsTR(Random random, int count, int min, int bound)
	{
		return generateRandomTexts(random, count, min, bound, LETTERS_ALL_TR);
	}

	public static String [] generateRandomTexts(Random random, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		for (int i = 0; i < count; ++i)
			texts[i] = generateRandomText(random, random.nextInt(min, bound), sourceText);

		return texts;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_EN);
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_TR);
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static String padLeading(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : String.valueOf(ch).repeat(newLen - s.length()) + s;
	}

	public static String padLeading(String s, int newLen)
	{
		return padLeading(s, newLen, ' ');
	}

	public static String padTrailing(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : s + String.valueOf(ch).repeat(newLen - s.length());
	}

	public static String padTrailing(String s, int newLen)
	{
		return padTrailing(s, newLen, ' ');
	}

	public static String reverse(String s)
	{
		return new StringBuilder(s).reverse().toString();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    Arayüzler (Interfaces): Bir arayüz bildirimi aslında bir UDT bildirimidir. Bir arayüz interface anahtar sözcüğü
    ile bildirilir. Arayüzler en çok abstract sınıflara benzeseler de sentaks ve semantik olarak farklı kuralları vardır.
    Arayüzler Java'da multiple inheritance'ın da belirli ölçüde kullanılabilmesini sağlar. Arayüzle, özellikle Java 8
    ile birlikte eklenen bazı özellikler ile daha yetenekli hale getirilmişlerdir.

    Arayüzler nesne özelliği göstermez. Yani bir arayüz türünden nesne hiç bir şekilde yaratılamaz ve yaratılmaz. Arayüzler
    aslında bir anlaşma (contract) belirtmek için kullanılır.

    Anahtar Notlar: Arayüzleri diğer tür bildirimlerinden ayırmak için isimlendirmede I ile başlatılması bazı programcılar
    tarafınden bir convantion olarak kullanılmaktadır. Biz de arayüz isimlerimizi I ile başlatacağız. JavaSE'deki arayüzlerde
    bu isimlendirme biçimine uyulmamaktadır.

    Bir arayüz içerisinde veri elemanı olabilir. Arayüz içerisinde bildirilen veri elemanları yazılsa da yazılmasa da
    public, static ve final olarak bildirilmiş olur. Yani bir arayüz içerisinde public olmayan veya non-static olan veya
    final olmayan veri elemanı bildirimi yapılamaz. Biz bu anahtar sözcükleri yazmayacağız. Bir arayüz içerisinde
    public abstract metotlar yazılabilir. Arayüz içerisindeki abstract bir metot için public ve abstract anahtar sözcükleri
    yazılmayabilir. Biz yine yazmamayacağız. Java 8 ile birlikte non-static bir metodun gövdesi de yazılabilmektedir. Bu
    durumda metodun default anahtar sözcüğü ile bildirilmesi gerekir. default metotlar public ve sanaldır. Java 8 ile
    birlikte static bir metot bildirimi de yapılabilmektedir. Şüphesiz static metotların gövdesi olmalıdır. Java 9 ile
    birlikte bir arayüz içerisinde private olarak bildirilmiş static ve non-static metotlar yazılabilmektedir. Şüphesiz
    bu metotların da gövdeleri olmalıdır.

    Anahtar Notlar: Bir arayüz içerisinde sınıflardaki "friendly" anlamına gelen no-modifier bir eleman olamaz. Bir arayüz
    içerisindeki no-modifier bir eleman public olarak bildirilmiş olur. Bir arayüz içerisinde protected bir eleman
    bildirilemez.

    Hiç abstract metodu olmayan arayüzlere "marker interfaces" denilmektedir. Genel olarak bir marker interface'in
    içerisinde hiç eleman bulundurulmaz.

    Anahtar Notlar: Java 5 ile eklenen annotation'lar ile marker arayüzlere çok ihtiyaç kalmamıştır. Ancak Java 5 öncesinden
    gelen ve önemli bazı sınıflarda kullanılan bazı marker interface'ler bulunmaktadır. Java programcısı Java 5 sonrasında
    kendisi bir marker interface yazma ihtiyacı genel olarak duymaz. Annotation bir UDT'dir ve Java ile Uygulama Geliştirme 1
    kursunda ele alanacaktır.

    Java 8 ile birlikte içerisinde bir yalnız bir tane abstract metodu olan arayüzler "functional interface" olarak
    kullanılabilmektedir. Functional interface'ler Java'da fonksiyonel programlama tekniği daha gelişmiş biçimde
    kullanılabilir hale gelmiştir.

    Anahtar Notlar: Java 8 ile birlikte "Lambda expressions ve method references" dile eklenmiştir. Lambda ifadeleri
    ve method referansları fonksiyonel arayüzler ile kullanılabilmektedir. Bu anlamda fonksiyonel arayüzler Java'da
    yeni nesil programlama tekniğini de kullanılabilir hale getirmiştir. Lambda ifadeleri ve method referansları
    Java ile Uygulama Geliştirme 1 kursunda ele alınacaktır.

    Bir arayüz abstract anahtar sözcüğü ile bildirilebilir. abstract yazmakla yazmamak arasında bir fark yoktur. Yine
    yazmayacağız.

    Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation). Bir sınıf istenildiği kadar arayüzü
    destekleyebilir. Bu durumda arayüzler virgül atomu ile listelenir. Bu durumda arayüzlerin listede sırasının önemi
    yoktur. Anımsanacağı gibi bir sınıf yalnızca tek bir sınıftan türetilebilir ancak istediği kadar arayüzü destekleyebilir.
    Bir arayüzü destekleyen bir sınıf arayüzün en az bir tane abstract metodunu override etmezse sınıfın abstract olarak
    bildirilmesi gerekir. Bu durumda bir sınıfın concrete olabilmesi için tüm abstract metotları (taban sınıftan gelen
    veya arayüzlerden gelen) override etmiş olması gerekir. Aksi durumda sınıf abstract olarak bildirilmelidir.

    Bir interface referansı taban sınıf referansı olarak kullanılabilir. Bu anlamda RTP gerçekleştirilmiş olur. Aslında
    bir sınıfın birden fazla arayüzü desteklemesi ile tüm arayüzlere ilişkin RTP yapılabilir. Bu da belirli ölçüde de
    olsa multiple inheritance'a benzetilebilir.

    Bir sınıf bir arayüzü destekliyorsa ondan türeyen sınıflar da o arayüzü destekler. Bu durumda türemiş sınıf arayüz
    listesine ilgili interface'in yazılması gerekmez. Ancak istenirse yazılabilir.

    Bir sınıfın desteklediği arayüzlerin geri dönüş değeri ve imzası aynı olan bir sanal metodu varsa, override
    edildiğinde metoda tüm arayüzler için geçerli olur.

    Arayüzler birbirlerinden türetilebilirler. Bu sentaks olarak extends anahtar sözcüğü ile yapılır. Burada inheritance
    teriminin kullanıldığına, implementation teriminin kullanılmadığına dikkat ediniz. Arayüzler arasında çoklu türetme de
    geçerlidir. Türemiş bir arayüz içerisinde taban arayüzün tüm public elemanları da bulunur. Türemiş bir arayüzü
    destekleyen bir sınıf taban arayüzlerini de desteklemiş olur. Taban arayüzlerin arayüz listesine yazılması gerekmez.
    İstenirse yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    int VAL = 10;

    private static void car() //Since Java 9
    {
        //...
    }

    private void zar() //Since Java 9
    {
        //...
    }

    static void tar() //Since Java 8
    {
        //...
    }

    void foo();

    default void bar() //Since Java 8
    {
        //...
    }
}

interface IY { //Marker interface

}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class C extends B implements IX, IY, IZ {
    //...

    public void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }
}

class A extends B implements IX, IY, IZ { //error
    //...
}

class B {
    //...
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}

interface IZ {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	25.02.2024
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.thread.ThreadUtil;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        Factory factory = new Factory();

        while (true) {
            IX ix = factory.create();

            Util.doWork(ix);
            ThreadUtil.sleep(1000);
        }
    }
}

class Util {
    public static void doWork(IX ix)
    {
        Console.writeLine("---------------------------------------------------------------");

        Console.writeLine("Dynamic type:%s", ix.getClass().getName());
        ix.foo();
        Console.writeLine("---------------------------------------------------------------");
    }
}

class Factory {
    private final Random m_random = new Random();

    public IX create()
    {
        return switch (m_random.nextInt(5)) {
            case 0 -> new B();
            case 1 -> new C();
            case 2 -> new D();
            case 3 -> new E();
            default -> new F();
        };
    }
}

class F extends D {
    public void foo()
    {
        Console.writeLine("F.foo");
        super.foo();
    }
}

class E extends C {
    public void foo()
    {
        Console.writeLine("E.foo");
        super.foo();
    }
}

class D extends A {
    public void foo()
    {
        Console.writeLine("D.foo");
        super.foo();
    }
}

class C extends B {
    public void foo()
    {
        Console.writeLine("C.foo");
        super.foo();
    }
}

class B extends A {
    public void foo()
    {
        Console.writeLine("B.foo");
        super.foo();
    }
}

class A implements IX {
    public void foo()
    {
        Console.writeLine("A.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örnekte A sınıfı foo metotlarını override etmiştir. A sınıfı içerisinde foo metodu overload edilmiş olur.
   Dolayısıyla bu durum geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX, IY {
    public void foo()
    {
        //...
    }

    public void foo(int a)
    {
        //...
    }
}

interface IX {
    void foo();
}

interface IY {
    void foo(int a);
}

/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki demo örnekte A sınıfı IX ve IY'yi desteklemek için override etmek zorunda olduğu metotlar overload edilemedği
   için error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX, IY {
    public void foo() //error
    {
        //...
    }

    public int foo() //error
    {
        //...

        return 0;
    }
}

interface IX {
    void foo();
}

interface IY {
    int foo();
}

/*----------------------------------------------------------------------------------------------------------------------
   Yukarıdaki gibi bir durumda iki tane çözüm aşağıdaki gibi olabilir. Şüphesiz sınıflar arayüzleri doğrudan destekleyemez.
   Farklı çözümler de söz konusu olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class B implements IX {
    private final IY m_iy;

    public B()
    {
        m_iy = new Y();
    }

    public void foo()
    {
        //...
    }

    public int fooY()
    {
        return m_iy.foo();
    }
}

class A  {
    private final IX m_ix;
    private final IY m_iy;

    public A()
    {
        m_ix = new X();
        m_iy = new Y();
    }

    public void fooX()
    {
        m_ix.foo();
    }

    public int fooY()
    {
        return m_iy.foo();
    }
}

class X implements IX {
    public void foo()
    {
        //...
    }
}

class Y implements IY {
    public int foo()
    {
        //...

        return 0;
    }
}

interface IX {
    void foo();
}

interface IY {
    int foo();
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {

    }
}

class B implements IZ, IX, IY {
    public void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }

    public void tar()
    {
        //...
    }
}


class A implements IZ {
    public void foo()
    {
        //...
    }

    public void bar()
    {
        //...
    }

    public void tar()
    {
        //...
    }
}

interface IZ extends IX, IY {
    void tar();
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Arayüzler ile abstract sınıflar arasındaki farklar şunlardır:
	- Bir arayüz interface anahtar sözcüğü ile, (abstract) bir sınıf class anahtar sözcüğü ile bildirilir.

	- Bir sınıf tek bir sınıftan türetilebilirken, istediği kadar arayüzü destekleyebilir.

	- Bir arayüz içerisinde yalnızca private metotlar ve public elemanlar olabilir, (asbtract) sınıf içerisinde protected
	veya friendly elemanlar da olabilir.

	- Bir arayüzün non-static veri elemanı olamaz. Bir abstract sınıfın olabilir.

	- Bir arayüz nesne özelliği göstermez. Bir abstract sınıf türünden nesne, türemiş sınıf nesnesi içerisinde
	yaratılır. Bu durumda bir arayüzün ctor'u da olamaz.

	- Bir arayüzün gövdesiz metodu abstract'dır, abstract bir sınıfın gövdesiz bir metodu abstract olarak bildirilmelidir.

	- Bir arayüzün gövdeli metodu default anahtar sözcüğü ile bildirilmelidir, abstract bir sınıfın gövdeli metodu
	doğrudan yazılır.

	- Bir abstract sınıf içerisinde no-modifier bir eleman friendly anlamındadır, bir interface içerisinde public
	anlamındadır.

	- Arayüzler arasında çoklu türetme yapılabilir, sınıflar arasında yapılamaz.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Programcı bir soyutlama (abstraction) yapmak istediğinde soyutlayacağı türü interface'mi yoksa abstract sınıf mı
	yazacağına nasıl karar verecektir? Programcı bu durumda ilk olarak interface düşünmelidir. Eğer interface o türe
	ilişkin ihtiyacı karşılamıyorsa abstract sınıf olarak tasarlamalıdır. Eğer interface yapılabildiği durumda programcı
	abstract sınıf olarak türü soyutlarsa, hem okunabilirlik/algılanabilirlik olumsuz olarak etkilenebilir hem de
	o abstract sınıftan türetilen bir sınıf başka bir sınıftan türetilemez. Halbuki, interface yapılırsa, bir sınıf
	başka bir sınıftan türetilip o arayüzü de destekleyebilir
----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    CompanyApp demo uygulaması aşağıdaki gibi de tasarlanabilir. Burada Employee sınıfının interface olamayacağına dikkat
    ediniz. Örnekte yalnızca değişiklikler buraya eklenmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app.company.employee;

public interface IInsurance {
    double calculateInsurancePayment();
    String getId();
}

package org.csystem.app.company.employee;

public abstract class Employee implements IInsurance {
    private String m_name;
    private String m_citizenId;
    private String m_address;

    //...

    protected Employee(String name, String citizenId, String address)
    {
        m_name = name;
        m_citizenId = citizenId;
        m_address = address;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        m_citizenId = citizenId;
    }

    public String getAddress()
    {
        return m_address;
    }

    public void setAddress(String address)
    {
        m_address = address;
    }

    //...

    public String getId()
    {
        return m_citizenId;
    }

    public String toString()
    {
        return String.format("[%s]%s", m_citizenId, m_name);
    }
}

package org.csystem.app.company.hr;

import org.csystem.app.company.employee.IInsurance;
import org.csystem.util.console.Console;

public class HumanResources {
    //...
    public void payInsurance(IInsurance insurance)
    {
        Console.writeLine("Citizen Id:%s", insurance.getId());
        Console.writeLine("Insurance payment:%f", insurance.calculateInsurancePayment());
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Arayüzlerle İlgili Tür Dönüştürmeleri
    Arayüzlerle ilgili tür dönüştürmeleri 4 durumda incelenebilir:
    1. Bir sınıf referansının onun desteklediği (implementation) bir arayüz referansına dönüştürülmesi
    2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi
    3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi
    4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    Bir sınıf referansının onun desteklediği (implementation) bir arayüz referansına dönüştürülmesi doğrudan (implicit)
    yapılabilir. Bu durum çok aşikar bir durumdur. Arayüz referansının taban sınıf referansı gibi kullanılmasıdır. Zaten
    interface'in hedeflerinden biri de budur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IX ix;

		ix = a;
	}
}


class A implements IX {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
    Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi explicit olarak yani tür dönüştürme operatörü
    ile yapılır. Ancak çalışma zamanı sırasında arayüz referansının dinamik türünün dönüştürülecek sınıfı kapsayıp
    kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür, akış devam eder. Kapsamıyorsa haksız dönüşümdür, ClassCastException
    fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IX ix;

		ix = a;

		B b = (B)ix; //haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A extends B implements IX {
	//...
}

class B  {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
    Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi explicit olarak yani tür dönüştürme operatörü
    ile yapılır. Ancak çalışma zamanı sırasında arayüz referansının dinamik türünün dönüştürülecek sınıfı kapsayıp
    kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür, akış devam eder. Kapsamıyorsa haksız dönüşümdür, ClassCastException
    fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IX ix;

		ix = a;

		B b = (B)ix; //haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IX {
	//...
}

class B  {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
	Bir arayüz referansının başka başka bir arayüz referansına dönüştürülmesi iki şekilde incelenebilir:
	1. Kaynak arayüz hedef arayüzden türetilmişse doğrudan yapılablir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IY iy = a;
		IX ix;

		ix = iy; //upcasting


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IY {
	//...
}

interface IY extends IX {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
     Bir arayüz referansının başka başka bir arayüz referansına dönüştürülmesi iki şekilde incelenebilir:
     2. Kaynak arayüz hedef arayüzden türetilmemişse explicit olarak yapılablir. Bu durumda çalışma zamanı sırasında
     kaynak arayüz referansının dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı
     dönüşümdür. Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IY iy = a;
		IX ix;

		ix = (IX)iy; //haklı dönüşüm


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IX, IY {
	//...
}

interface IY {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
     Bir arayüz referansının başka başka bir arayüz referansına dönüştürülmesi iki şekilde incelenebilir:
     2. Kaynak arayüz hedef arayüzden türetilmemişse explicit olarak yapılablir. Bu durumda çalışma zamanı sırasında
     kaynak arayüz referansının dinamnik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı
     dönüşümdür. Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new A();
		IY iy = a;
		IX ix;

		ix = (IX)iy; //haksız dönüşüm


		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IY {
	//...
}

interface IY {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
     Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
     Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın dinamik türünün hedef
     arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür. Desteklemiyorsa haksız dönüşümdür
     ClassCastException fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String[] args)
	{
		A a = new B();
		IX ix;

		ix = (IX)a; //haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class B extends A implements IX {
	//...
}

class A  {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
     Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
     Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın dinamik türünün
     hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür. Desteklemiyorsa haksız dönüşümdür
     ClassCastException fırlatılır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A a = new B();
		IX ix;

		ix = (IX)a; //haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class B extends A {
	//...
}

class A  {
	//...
}

interface IX {
	//...
}

/*-----------------------------------------------------------------------------------------------------------------------
     JavaSE'de CharSequence arayüzünde karakterlerin dizilimine ilişkin çeşitli metotlar bulunur. Bu arayüzü String ve
     StringBuilder destekler. charAt, length gibi metotlar bu arayüzden gelirler, String ve StringBuilder sınıfları
     aslında bu metotları override ederler. Pek çok geliştirme ortamına ilişkin kütüphanelerde bu arayüzü referansını
     isteyen metotlar bulunur.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
     Aşağıdaki demo örneği ve demo sınıfı inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import com.baturhansahin.string.MyString;
import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        String str = Console.readString("Input a text:");
        MyString myStr = new MyString(Console.readString("Input a text:"));

        Console.writeLine(str.contains(myStr) ? "Found" : "Not found");
    }
}

package com.baturhansahin.string;

public class MyString implements CharSequence {
    private final char [] m_chars;

    public MyString(String str)
    {
        m_chars = str.toCharArray();
    }

    public int length()
    {
        return m_chars.length;
    }

    public char charAt(int index)
    {
        if (index < 0 || index >= m_chars.length)
            throw new IndexOutOfBoundsException("Invalid index");

        return m_chars[index];
    }

    public CharSequence subSequence(int start, int end)
    {
        return String.valueOf(m_chars).subSequence(start, end);
    }

    public String toString()
    {
        return String.valueOf(m_chars);
    }

    //...
}

/*-----------------------------------------------------------------------------------------------------------------------
    Java 17 ile birlikte rasgele sayı üretimine ilişkin RandomGenerator denilern bir arayüz eklenmiştir. Bu anlamda
    bu arayüz ile birlikte farklı farklı rasgele sayı üretimi algoritmaları kullanılabilmektedir. Random gibi daha önce
    var olan pek çok sınıf da bu arayüzü desteklemektedir. Dolayısıyla bazı metotlar da Random sınıfına dolaylı olarak
    eklenmiştir. Örneğin iki parametre nextInt metodu aslında Random sınıfına RandomGenerator'dan gelmektedir. Aslında
    bu arayüzün bir tane abstract metodu vardır (nextLong). Diğerleri default olarak bildirilmiştir. Bu arayüzün of
    factory metotları ile çeşitli algoritmalara yönelik rasgele sayı üretimi yapan nesne referansları elde edilebilir.
    Bu anlamda artık Java'da rasgele sayı üretimi daha genel ve yetenekli hale gelmiştir
-----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: StringUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 25th February 2024

	Utility class for string operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.string;

import java.util.random.RandomGenerator;

public final class StringUtil {
	private static final String LETTERS_EN;
	private static final String LETTERS_TR;
	private static final String LETTERS_CAPITAL_EN;
	private static final String LETTERS_CAPITAL_TR;
	private static final String LETTERS_ALL_EN;
	private static final String LETTERS_ALL_TR;

	static {
		LETTERS_EN = "abcdefghijklmnopqrstuvwxyz";
		LETTERS_TR = "abcçdefgğhıijklmnoöprsştuüvyz";
		LETTERS_CAPITAL_EN = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		LETTERS_CAPITAL_TR = "ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ";
		LETTERS_ALL_EN = LETTERS_EN + LETTERS_CAPITAL_EN;
		LETTERS_ALL_TR = LETTERS_TR + LETTERS_CAPITAL_TR;
	}

	private StringUtil()
	{
	}

	public static String capitalize(String s)
	{
		return s.isEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase();
	}

	public static int countString(String s1, String s2)
	{
		int count = 0;
		int index = -1;

		while ((index = s1.indexOf(s2, index + 1)) != -1)
			++count;

		return count;
	}

	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}

	public static String generateRandomTextEN(RandomGenerator randomGenerator, int count)
	{
		return generateRandomText(randomGenerator, count, LETTERS_ALL_EN);
	}

	public static String generateRandomTextTR(RandomGenerator randomGenerator, int count)
	{
		return generateRandomText(randomGenerator, count, LETTERS_ALL_TR);
	}

	public static String generateRandomText(RandomGenerator randomGenerator, int count, String sourceText)
	{
		StringBuilder sb = new StringBuilder(count);
		int len = sourceText.length();

		for (int i = 0; i < count; ++i)
			sb.append(sourceText.charAt(randomGenerator.nextInt(len)));

		return sb.toString();
	}

	public static String [] generateRandomTextsEN(RandomGenerator randomGenerator, int count, int min, int bound)
	{
		return generateRandomTexts(randomGenerator, count, min, bound, LETTERS_ALL_EN);
	}

	public static String [] generateRandomTextsTR(RandomGenerator randomGenerator, int count, int min, int bound)
	{
		return generateRandomTexts(randomGenerator, count, min, bound, LETTERS_ALL_TR);
	}

	public static String [] generateRandomTexts(RandomGenerator randomGenerator, int count, int min, int bound, String sourceText)
	{
		String [] texts = new String[count];

		for (int i = 0; i < count; ++i)
			texts[i] = generateRandomText(randomGenerator, randomGenerator.nextInt(min, bound), sourceText);

		return texts;
	}

	public static boolean isPalindrome(String s)
	{
		int left = 0;
		int right = s.length() - 1;

		while (left < right) {
			char cLeft = Character.toLowerCase(s.charAt(left));

			if (!Character.isLetter(cLeft)) {
				++left;
				continue;
			}

			char cRight = Character.toLowerCase(s.charAt(right));

			if (!Character.isLetter(cRight)) {
				--right;
				continue;
			}

			if (cLeft != cRight)
				return false;

			++left;
			--right;
		}

		return true;
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_EN);
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), LETTERS_TR);
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (s.indexOf(alphabet.charAt(i)) == -1)
				return false;

		return true;
	}

	public static String padLeading(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : String.valueOf(ch).repeat(newLen - s.length()) + s;
	}

	public static String padLeading(String s, int newLen)
	{
		return padLeading(s, newLen, ' ');
	}

	public static String padTrailing(String s, int newLen, char ch)
	{
		int len = s.length();

		return newLen <= len ? s : s + String.valueOf(ch).repeat(newLen - s.length());
	}

	public static String padTrailing(String s, int newLen)
	{
		return padTrailing(s, newLen, ' ');
	}

	public static String reverse(String s)
	{
		return new StringBuilder(s).reverse().toString();
	}
}

/*--------------------------------------------------------
	FILE NAME	: ArrayUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 25th February 2024

	Utility class for array operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.array;

import java.util.ArrayList;
import java.util.random.RandomGenerator;


public final class ArrayUtil {
    private ArrayUtil()
    {}

    private static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    private static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    private static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    private static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void addBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] += val;
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [] a, int origin, int bound)
    {
        fillRandomArray(randomGenerator, a, a.length, origin, bound);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [] a, int count, int origin, int bound)
    {
        for (int i = 0; i < count; ++i)
            a[i] = randomGenerator.nextInt(origin, bound);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [][] a, int origin, int bound)
    {
        for (int [] array : a)
            fillRandomArray(randomGenerator, array, origin, bound);
    }

    public static int [] generateRandomArray(RandomGenerator random, int count, int origin, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, origin, bound);

        return a;
    }

    public static int [] histogramData(int [] a, int n)
    {
        int [] result = new int[n + 1];

        for (int val : a)
            ++result[val];

        return result;
    }

    public static boolean isEmpty(int [] a)
    {
        return a.length == 0;
    }

    public static String join(ArrayList list, char separator)
    {
        return join(list, String.valueOf(separator));
    }

    public static String join(ArrayList list, String separator)
    {
        StringBuilder sb = new StringBuilder();

        for (Object o : list)
            sb.append((String)o).append(separator);

        return sb.substring(0, sb.length() - separator.length());
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.max(val, result);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.min(val, result);

        return result;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] *= val;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        print(n, a, a.length);
    }

    public static void print(int [] a, int count)
    {
        print(1, a, count);
    }

    public static void print(int n, int [] a, int count)
    {
        print(n, a, count, " ", "\n");
    }

    public static void print(int [] a, int count, String sep, String end)
    {
        print(1, a, count, sep, end);
    }

    public static void print(int n, int [] a, int count, String sep, String end)
    {
        String fmt = String.format("%%0%dd%%s", n);

        for (int i = 0; i < count; ++i)
            System.out.printf(fmt, a[i], sep);

        System.out.print(end);
    }

    public static void print(int [][] a)
    {
        print(1, a);
    }

    public static void print(int n, int [][] a)
    {
        for (int [] array : a)
            print(n, array);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static int [] reversed(int [] a)
    {
        int [] result = new int[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static char [] reversed(char [] a)
    {
        char [] result = new char[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean desc)
    {
        if (desc)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void subtractBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] -= val;
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}

/*--------------------------------------------------------
	FILE NAME	: MatrixUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 25th February 2024

	Utility class for matrix operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.matrix;

import org.csystem.util.array.ArrayUtil;

import java.util.random.RandomGenerator;


public final class MatrixUtil {
    private MatrixUtil()
    {
    }

    public static int [][] add(int [][] a, int [][] b)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] total = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                total[i][j] = a[i][j] + b[i][j];

        return total;
    }

    public static void addBy(int [][] a, int val)
    {
        ArrayUtil.addBy(a, val);
    }

    public static int [][] subtract(int [][] a, int [][] b)
    {
        int row = a.length;
        int col = a[0].length;
        int [][] total = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                total[i][j] = a[i][j] - b[i][j];

        return total;
    }



    public static int [][] generateRandomMatrix(RandomGenerator randorandomGenerator, int row, int col, int origin, int bound)
    {
        int [][] a = new int[row][col];

        ArrayUtil.fillRandomArray(randorandomGenerator, a, origin, bound);

        return a;
    }

    public static int [][] generateRandomSquareMatrix(RandomGenerator randomGenerator, int n, int origin, int bound)
    {
        return generateRandomMatrix(randomGenerator, n, n, origin, bound);
    }

    public static boolean isMatrix(int [][] a)
    {
        for (int i = 1; i < a.length; ++i)
            if (a[0].length != a[i].length)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        ArrayUtil.multiplyBy(a, val);
    }
    public static void subtractBy(int [][] a, int val)
    {
        ArrayUtil.subtractBy(a, val);
    }

    public static int sumDiagonal(int [][] a)
    {
        int total = 0;

        for (int i = 0; i < a.length; ++i)
            total += a[i][i];

        return total;
    }

    public static int [][] transpose(int [][] a)
    {
        int [][] t = new int[a[0].length][a.length];

        for (int i = 0; i < a.length; ++i)
            for (int j = 0; j < a[i].length; ++j)
                t[j][i] = a[i][j];

        return t;
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo MyRandom sınıfını inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import com.baturhansahin.random.MyRandom;
import org.csystem.util.array.ArrayUtil;
import org.csystem.util.console.Console;

import java.util.Random;
import java.util.random.RandomGenerator;

class App {
    public static void main(String[] args)
    {
        int count = Console.readInt("Input count:", "Invalid value!...");
        MyRandom myRandom = new MyRandom();
        Random random = new Random();
        RandomGenerator randomGenerator = RandomGenerator.getDefault();

        int [] a = ArrayUtil.generateRandomArray(myRandom, count, 0, 100);
        int [] b = ArrayUtil.generateRandomArray(random, count, 0, 100);
        int [] c = ArrayUtil.generateRandomArray(randomGenerator, count, 0, 100);

        ArrayUtil.print(2, a);
        ArrayUtil.print(2, b);
        ArrayUtil.print(2, c);
    }
}

package com.baturhansahin.random;

import java.util.random.RandomGenerator;

public class MyRandom implements RandomGenerator {
    private long m_seed;

    public MyRandom()
    {
        m_seed = System.currentTimeMillis();
    }

    public MyRandom(long seed)
    {
        m_seed = seed;
    }

    public long nextLong()
    {
        return (m_seed = m_seed * 123456789L / 23456789L) * 100;
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    02.03.2024
----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    Bazı sınıflar bir kaynağı (resource) kullanırlar. Bu kaynakların kullanılmaya başlamadan önce mantıksal olarak
    açılması (open) gerekir. Burada "açma işlemi", o kaynağı kullanmadan önce yapılması geereken işlemleri tamamlamak
    anlamında kullanılır. Bu tip kaynakların işlem bittikten sonra mantıksal olarak kapatılması (close) yani geri
    bırakılması (free/release) ile ilgili işlemlerin tamamlanması gerekir. Örneğin bir dosyanın verileri üzerinde işlem
    yapmak için dosyanın açılması gerekir, işlem bittikten sonra da kapatılması gerekir. Bir dosyanın açılması işletim
    sistemi düzeyinde aşağı seviyeli bir takım işlemlerin yapılması demektir, kapatılması ise yine işletim sistemi düzeyinde
    bir takım işlemlerin yapılması demektir.

    İşte böylesi durumlar için Java dünyasında Closeable arayüzü kullanılır. Bu arayüzün aşağıdaki prototipe sahip
    close isimli abstract bir metodu vardır:

        void close() throws IOException;

    Bu durumda ilgili sınıf kaynağı geri bırakma (release) işlemini bu metot içerisinde yapar. Kaynağı mantıksal olarak
    açma işlemi sınıftan sınıfa yani senarayoya göre değişebilir. Örneğin bazı sınıflar kaynağı açma işlemi ctor içerisinde
    yaparlar. Senaryo ne olursa bir Java programcısı için Closeable arayüzünü destekleyen bir sınıfı kullanmak onun
    close metodunun da genel olarak çağrılması gerektiği anlamına gelir. Benzer şekilde programcı böylesi kaynak kullanan
    bir sınıf yazdığında da Closeable arayüzünü destekler. JavaSE'de Closeable arayüzünü destekleyen çok fazla sınıf
    vardır. Java 7 ile birlikte tamamen aynı metoda sahip olan AutoCloseable isimli bir arayüz eklenmiştir ve Java 7 ile
    birlikte Closeable arayüzü AutoCloseable arayüzünden türetilmiştir. Bu arayüz ileride ele alınacaktır.

    Anahtar Notlar: Closeable arayüzünü destekleyen bazı sınıfların close metotları throws IOException bildirerek
    override edilse de bu exception'ın handle edilmesi gerekmeyebilir ya da handle edilse de anlamlı olmayabilir. Örneğin
    açık olan bir dosyanın kapatılamaması durumunda oluşacak exception için programın içerisinde yapılacak çok da bir şey
    yoktur. Yani programcı açısından bu exception'ın handle edilmesi bir anlam ifade etmez ancak close metodu IOException'ı
    throws listesinde içerecek biçimde override edildiğinden programcının bu exception akış içerisinde handle etmesi veya
    metodu çağırdığı yerde throws bildirimi yapması gerekir. Her iki durumda da gereksiz kod olması açısından clean code
    yazılmamış olur. Bu durumda programcının strateji değiştirirek daha clean code yazması gerekir.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz. Örnekte IOException handle edilmesine rağmen herhangi bir işlem yapılmamıştır ancak
    error oluşmaması için handle edilmiştir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            Image image = null;

            try {
                String name = Console.readString("Input image name:");
                image = new Image(name);

                image.makeBinary(Console.readInt("Input threshold:"));

                //...

            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
            finally {
                if (image != null) {
                    try {
                        image.close();
                    }
                    catch (IOException ignore) {

                    }
                }
            }
        }
    }
}

class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki demo örnek aşağıdaki gibi de yapılabilirdi
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args) throws IOException
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run() throws IOException
    {
        while (true) {
            Image image = null;

            try {
                String name = Console.readString("Input image name:");
                image = new Image(name);

                image.makeBinary(Console.readInt("Input threshold:"));

                //...

            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
            finally {
                if (image != null)
                    image.close();
            }
        }
    }
}

class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened!...", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki demo örnek Java 7'den önce aşağıdaki gibi daha clean bir şekilde yazılabilir. Bu yaklaşım yukarıdaki
    yaklaşıma göre daha clean olmasıyla birlikte aynı zamanda close metodunun da handle edilmesi gerektiği durumda da
    kullanılabilir
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            try {
                ImageUtil.doBinary();
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class ImageUtil {
    public static void doBinary() throws IOException
    {
        Image image = null;

        try {
            String name = Console.readString("Input image name:");
            image = new Image(name);

            image.makeBinary(Console.readInt("Input threshold!..."));

            //...
        }
        finally {
            if (image != null)
                image.close();
        }
    }
}

class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki yaklaşımlarda checked exception dolayısıyla programcının strateji değiştirmesi söz konusudur ayrıca kod
    içerisinde close metodunun çağrılmasının gözden kaçtığı durumlar olabilir ve bu da senaryoya göre çeşitli bug'ların
    oluşmasına sebep olabilir.

    Java 7 ile birlikte AutoCloseable arayüzü eklenmiş, Closeable arayüzü AutoCloseable
    arayüzünden türetilmiştir. Yani Java 7 ile birlikte Closeable arayüzünü destekleyen her sınıf aynı zamanda AutoCloseable
    arayüzünü de destekler duruma gelmiştir. Java 7 ile birlikte ismine "try with resources (TWR)" denilen bir deyim
    eklenmiştir. Bu deyimin genel biçimi şu şekildedir:
        try (<AutoCloseable arayüzü türünden referans>[; <AutoCloseable arayüzü türünden referans>; ...]) {
            //...
        }
        [
            catch blokları VEYA finally bloğu VEYA catch blokları ile finally bloğu
        ]
    Bu deyim ile close metodu otomatik olarak çağrılır. Yani programcının bu deyim ile birlikte close metodunu çağırması
    gerekmez. Bu durumda programcı ne strateji değiştirmek zorunda kalır ne de close metodunun çağrılmasının gözden
    kaçabileceği durumlar oluşabilir. Java 9'dan önce bu deyimin parantezi içerisinde referansa ilk değer verilmesi
    zorunluydu yani referansın değerinin parantez içerisinde verilmesi gerekiyordu. Java 9 ile birlikte parantez içerisinde
    daha önce değer verilmiş referanslar da kullanılabilir duruma gelmiştir. TWR parantezi içerisindeki referansın AutoCloseable
    arayüzünü destekleyen bir sınıf türünden ya da AutoCloseable arayüzü türünden ya da AutoCloseable arayüzünden türetilmiş
    bir interface referansı türünden olması gerekir. Yani kısaca söylemek gerekirse buradaki referansın AutoCloseable olması
    gerekir. Closeable arayüzü de AutoCloseable'dan türetildiğinden TWR ile kullanılabilmektedir. Programcının özel bir
    durum yoksa TWR kullanması tavsiye edilir. Bu deyim ile close metodunun fırlattığı exception'da handle edilebilir.
    Genel biçime dikkat edilirse TWR bloğundan sonra herhangi bir catch bloğu ya da finally bloğu gelmek zorunda değildir.

    TWR deyiminde parantez içerisinde kullanılan referans'ın faaliyet alanı TWR deyiminin try bloğu boyuncadır. Ayrıca
    bu referans final kabul edilir.

    Anahtar Notlar: Bir değişkenin final olarak bildirilmemesine rağmen faaliyet alanı içerisinde final olarak kabul
    edilmesine genel olarak "effectively final" denilmektedir.

    TWR deyiminin parantezi içerisinde birden fazla referans kullanılması durumunda close metodu kullanım ile ters sırada
    çağrılır.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki demo örnek aşağıdaki gibi TWR ile de yapılabilir. Bu yaklaşım diğer yaklaşaımlara göre en iyisidir ve
    programcı özel bir durum yoksa kesinlikle TWR kullanmalıdır
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            try (Image image = new Image(Console.readString("Input image name:"))) {
                image.makeBinary(Console.readInt("Input threshold:"));

                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte Image sınıfı AutoCloseable arayüzünü desteklemediğinden error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.IOException;

class DemoApp {
    public static void run()
    {
        while (true) {
            try (Image image = new Image(Console.readString("Input image name:"))) { //error
                image.makeBinary(Console.readInt("Input threshold:"));

                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class Image {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte image referansı final olarak kabul edildiğinden error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class DemoApp {
    public static void run()
    {
        while (true) {
            try (Image image = new Image(Console.readString("Input image name:"))) {
                image.makeBinary(Console.readInt("Input threshold:"));

                image = null; //error

                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            try (Image image = new Image(Console.readString("Input image name:"));
                 ImageProcessing imageProcessing = new ImageProcessing(image)) {

                //...
                imageProcessing.faceRecognition();
                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class ImageProcessing implements Closeable {
    private final Image m_image;
    //...

    public ImageProcessing(Image image)
    {
        m_image = image;
    }

    public void faceRecognition()
    {
        //...
        m_image.makeBinary(Console.readInt("Input threshold:"));
        Console.writeLine("Identify people by faces in image!...");
    }

    public void close() throws IOException
    {
        Console.writeLine("Image released!...");
        m_image.close();
    }
}
class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            try  {
                Image image = new Image(Console.readString("Input image name:"));
                ImageProcessing imageProcessing = new ImageProcessing(image);

                ImageUtil.doWork(image, imageProcessing);
                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class ImageUtil {
    public static void doWork(Image image, ImageProcessing imageProcessing)
    {
        try (image; imageProcessing) { //Since Java 9

            //...
            imageProcessing.faceRecognition();
            //...
        }
        catch (Throwable ex) {
            Console.writeLine(ex.getMessage());
        }
    }
}

class ImageProcessing implements Closeable {
    private final Image m_image;
    //...

    public ImageProcessing(Image image)
    {
        m_image = image;
    }

    public void faceRecognition()
    {
        //...
        m_image.makeBinary(Console.readInt("Input threshold:"));
        Console.writeLine("Identify people by faces in image!...");
    }

    public void close() throws IOException
    {
        Console.writeLine("Image released!...");
        m_image.close();
    }
}
class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.io.Closeable;
import java.io.IOException;

class App {
    public static void main(String[] args)
    {
        DemoApp.run();
    }
}

class DemoApp {
    public static void run()
    {
        while (true) {
            try  {
                Image image = new Image(Console.readString("Input image name:"));
                ImageProcessing imageProcessing = new ImageProcessing(image);

                ImageUtil.doWork(image, imageProcessing);
                //...
            }
            catch (Throwable ex) {
                Console.writeLine(ex.getMessage());
            }
        }
    }
}

class ImageUtil {
    public static void doWork(Image image, ImageProcessing imageProcessing) throws IOException
    {
        try (image; imageProcessing) { //Since Java 9

            //...
            imageProcessing.faceRecognition();
            //...
        }
    }
}

class ImageProcessing implements Closeable {
    private final Image m_image;
    //...

    public ImageProcessing(Image image)
    {
        m_image = image;
    }

    public void faceRecognition()
    {
        //...
        m_image.makeBinary(Console.readInt("Input threshold:"));
        Console.writeLine("Identify people by faces in image!...");
    }

    public void close() throws IOException
    {
        Console.writeLine("Image released!...");
        m_image.close();
    }
}
class Image implements Closeable {
    private final String m_imageName;
    //...

    public Image(String imageName)
    {
        //...
        m_imageName = imageName;
        Console.writeLine("%s image opened:", m_imageName);
    }

    public void makeBinary(int threshold)
    {
        if (threshold < 0 || threshold > 255)
            throw new IllegalArgumentException("threshold value must be between 0(zero) and 255");

        Console.writeLine("Image processing!...");
        Console.writeLine("%s image changed!...", m_imageName);
    }

    public void close() throws IOException
    {
        Console.writeLine("Release image!...");
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Generics: Generic'ler derleme zamanı çok biçimliliğini (compile time polymorphism) (CTP) gerçekleştirmek için
    kullanılır. Generic'ler Java 5 ile dile eklenmiştir. Generic'ler genel olarak iki gruba ayrılabilir:
    Generic türler (generic types), generic metotlar (generic methods). Şu ana kadar görmüş olduğumuz tür bildirimleri
    içerisinde sınıflar ve arayüzler generic olarak bildirilebilirler. Bu anlamda exception sınıfları generic olarak
    bildirilemezler. Generic konusuna ilişkin bazı detaylı durumlar Java ile Uygulama Geliştirme 1 Kursu'nda ele alınacakır.

    Generic bir sınıf bildiriminde sınıf isminde sonra açılsal parantezler içerisinde yazılan isimlere generic tür
    parametreleri (generic type parameters) ya da kısaca tür parametreleri (type parameters) denilmektedir. Açısal
    parantez içerisinde bildirilen isimler virgül ile listelenir. Bu isimler değişken isimlendirme kurallarına uygun
    olmalıdır. Bu parametreler aslında bir tür belirtirler. Bu isimler tür belirttiklerinden "upper camel case" olarak
    yazılırlar. Bu isimler çoğu zaman tek bir karakterden oluşur. Örneğin, T, K, E gibi karakterler verilebilir.

    Anahtar Notlar: Generic türlere "parameterized type" da denilmektedir.

    Generic tür parametrelerine ilişkin isimlerin faaliyet alanı ilgili tür boyuncadır ve ilgili tür içerisinde tür
    olarak kullanılabilir.

    Generic bir tür ismi iki şekilde kullanılabilir: Açılım (intantiation) yapılarak, doğrudan.
    Açılım yapılarak kullanımda tür ismi ile beraber açısal parantez içerisinde generic tür parametrelerine ilişkin
    türler açıkça belirtilir. Birden fazla generic parametre için türler yine virgül ile ayrılacak şekilde belirtilir.
    Açılım ile aslında sınıfın ilgili generic parametrelerinin yerine geçen türler belirtilmiş olur. Bu durumda bu generic
    tür parametrelerinin kullanıldığı her yerde derleme zamanında açılıma ilişkin türlere göre işlem yapılır. Açılımda
    generic tür parametre sayısı kadar tür açılımı yapılmalıdır. Generic bir tür açılım yapılmadan yani açısal
    parantezsiz kullanıldığında generic tür parametreleri Object olarak ele alınır.

    Anahtar Notlar: Çalışma zamanında açılıma ilişkin türler Object olarak ele alınır. Bu anlamda aslında generic'ler
    derleme zamanında tür kontrolü açısından önemlidir.

    Anahtar Notlar: Generic türlerin doğrundan yani açılım yapılmadan ya da daha geneş bir ifade ile açısal parantez
    olmadan kullanılması tavsiye edilen bir durum değildir. Bir generic tür parametresinin Object olması isteniyorsa
    Object açılımı yapılması tavsiye edilir. Zaten bir çok static kod analizi aracı da generic sınıfların açılımsız yani
    doğrudan kullanılması durumunda uyarı vermektedir.

    Generic bir sınıf türünden nesne yaratılırken yine açısal parantez kullanılır. (Burada yine açısal parantez olmadığı
    durum tavsiye edilmez). Açılım yapılırken, açılıma ilişkin türler açısal parantez içerisinde yazılır. Java 7 ile
    birlikte new operatörü ile nesne yaratılırken, atanacak referans'da açılım yapılmışsa, açısal parantez içerisi boş
    bırakılabilir. Burada yine de açısal parantez kullanılması tavsiye edilir. Bu kullanıma "diamond syntax" da denir.

    Generic parametreler temel türler olarak açılamazlar. Generic tür parametresi için temel tür kullanımı söz konusu ise
    ilgili temel türe karşılık gelen sarmalayan sınıf açılımı yapılır. Bu durumda temel türden kullanımlarda bir otomatik
    kutulama (auto boxing) söz konusudur. Bu da duruma göre maliyetli olabilir. Buna göre programcı temel tür için ayrı
    bir tür de yazabilir. Bu durum ileride ele alınacaktır. Çalışma zamanında generic bir türün her açılımı ayrı bir tür
    belirtmez.
-----------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        A<String> as;
        B<String, Random> bsr;
        A a; //Dikkat tavsiye etmiyoruz (gönlümüzün error'u)
        A<Object> ao; //Object açılımı için Tavsiye edilen kullanım

        as = new A<String>("ankara");
        bsr = new B<String, Random>("istanbul");

        bsr.doWork(new Random());

        a = new A(10); //Dikkat tavsiye etmiyoruz (gönlümüzün error'u)

        ao = new A<Object>(10);

        //...
    }
}

class A<T> {
    private T m_value;
    //...

    public A(T t)
    {
        m_value = t;
    }

    public void setValue(T value)
    {
        m_value = value;
    }

    public T getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

class B<T, K> {
    private T m_value;

    public B(T value)
    {
        m_value = value;
    }

    public void doWork(K k)
    {
        Console.writeLine("%s, %s", m_value, k);
    }

    public T getValue()
    {
        return m_value;
    }

    public void setValue(T value)
    {
        m_value = value;
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.Random;

class App {
    public static void main(String[] args)
    {
        A<String> as;
        B<String, Random> bsr;
        A<Object> ao;

        as = new A<>("ankara"); //Since Java 7
        bsr = new B<>("istanbul"); //Since Java 7

        bsr.doWork(new Random());

        ao = new A<>(10); //Since Java 7

        //...
    }
}

class A<T> {
    private T m_value;
    //...

    public A(T t)
    {
        m_value = t;
    }

    public void setValue(T value)
    {
        m_value = value;
    }

    public T getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

class B<T, K> {
    private T m_value;

    public B(T value)
    {
        m_value = value;
    }

    public void doWork(K k)
    {
        Console.writeLine("%s, %s", m_value, k);
    }

    public T getValue()
    {
        return m_value;
    }

    public void setValue(T value)
    {
        m_value = value;
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte temel türden açılım yapıldığında error oluşur
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        A<int> as; //error

        //...
    }
}

class A<T> {
    private T m_value;
    //...

    public A(T t)
    {
        m_value = t;
    }

    public void setValue(T value)
    {
        m_value = value;
    }

    public T getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örneği inceleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        A<Integer> a;

        a = new A<>(10);

        a.setValue(10);

        //...
    }
}

class A<T> {
    private T m_value;
    //...

    public A(T t)
    {
        m_value = t;
    }

    public void setValue(T value)
    {
        m_value = value;
    }

    public T getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

/*-----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte her açılımın ayrı bir tür belirtmediğini programı çalıştırıp gözlemleyiniz
-----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        A<Integer> ai;
        A<String> as;


        ai = new A<>(10);
        as = new A<>("ankara");

        Console.writeLine(ai.getClass().getName());
        Console.writeLine(as.getClass().getName());

        //...
    }
}

class A<T> {
    private T m_value;
    //...

    public A(T t)
    {
        m_value = t;
    }

    public void setValue(T value)
    {
        m_value = value;
    }

    public T getValue()
    {
        return m_value;
    }

    public String toString()
    {
        return String.valueOf(m_value);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfı da generic bir sınıftır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList<String> texts = new ArrayList<>(Console.readInt("Capacity değerini giriniz:"));
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            texts.add(StringUtil.generateRandomTextTR(random, n));
        }

        StringBuilder sb = new StringBuilder();

        for (String s : texts)
            sb.append(s).append(" ");

        Console.writeLine(sb);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte otomatik kutulama söz konusudur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

import java.util.ArrayList;
import java.util.Random;

class App {
    public static void main(String[] args)
    {
        ArrayList<Integer> numbers = new ArrayList<>();
        Random random = new Random();

        while (true) {
            int n = Console.readInt("Bir sayı giriniz:");

            if (n <= 0)
                break;

            numbers.add(random.nextInt(n));
        }

        StringBuilder sb = new StringBuilder();

        for (int val : numbers)
            sb.append(val).append(" ");

        Console.writeLine(sb);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    03.03.2024
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Generic sınıflarla ilgili türetme işlemi şu şekilde incelenebilir:
    - Generic olmayan bir sınıf generic bir sınıfın bir açılımından türetilebilir: Bu durumda taban sınıfın sanal metotları
    türemiş sınıfta açılıma uygun olarak override edilmelidir

    - Generic bir sınıf generic olmayan bir sınıftan türetilebilir: Bu durumda derleme zamanı açısından türemiş sınıfın
    her açılımı o generic olmayan taban sınıftan türetilmiş olur.

    - Generic bir sınıf başka bir generic sınıfın bir açılımından türetilebilir: Bu durumda derleme zamanı açısından
    türemiş sınıfın her açılımı ilgili taban sınıftan türetilmiş olur. Yine taban sınıfın generic tür parametrelerini
    kullanan sanal metotları türemiş sınıfta açılıma uygun olarak override edilmelidir.

    - Generic bir sınıf başka bir generic sınıftan türetilebilir: Bu durumda derleme zamnı açısından türemiş sınıfın
    bir açılımı taban sınıfın da ilgili açılımından türetilmiş olur. Yine taban sınıfın generic tür parametrelerini
    kullanan sanal metotları türemiş sınıfta generic tür parametrelerine uygun olarak override edilmelidir.

    Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B<String> bs = new B<>();
        B<Integer> bi = new B<>();
        X x;

        x = bi;
        x = bs;

        C<String> cs = new C<>();
        C<Boolean> cb = new C<>();

        bs = cs;
        bs = cb;

        D<Long> dl = new D<>();
        D<Float> df = new D<>();
        B<Long> bl;
        B<Float> bf;

        bl = dl;
        bf = df;

        E<Integer, String> eis = new E<>();
        A<Integer, String> ais;

        ais = eis;
    }
}

class E<T, K> extends A<T, K> {
    public K foo(T t)
    {
        //...
        return null;
    }
}

class D<T> extends B<T> {
    //...
}

class C<T> extends B<String> {
    //...
}

class B<T> extends X {
    //...
}

class X extends A<String, Integer> {
    public Integer foo(String str)
    {
        //...

        return str.length();
    }
}

abstract class A<T, R> {
    public abstract R foo(T t);
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir arayüz generic olabilir. Bu durumda bu arayüzü impelemnte eden sınıfların arayüzün sanal metotlarını generic
    tür parametrelerine uygun olarak override etmesi gerekir. Generic arayüzler programalada çok kullanıldığından bazı
    durumlarda bu arayüzü kullanan sınıflar açısında otomatik kutulama ve otomatik kutu açma maliyeti olmaması için
    generic arayüzün temel ilgili temel türler için benzer arayüzleri de kütüphane içerisinde bulundurulur. Şüphesiz bu
    durum generic sınıflar için de duruma göre yapılabilmektedir. Örneğin, Java 8'de çok kullanışan Predicate<T> arayüzünün
    kullanıldığı yerlerde kutulama bir maliyet oluşturabileceğinden JavaSE'de ayrıca IntPredicate, LongPredicate ve
    DoublePredicate gibi 3 tane daha benzer arayüz bulunur. Bu gruptaki arayüzlerin test isimli abstract metotları
    Predicate<T> için T türden, IntPredicate için int türden, LongPredicate için long türden ve DoublePredicate için
    double türden prametreye sahiptir.

    Generic arayüzlerin de açılımsız kullanımı tavsiye edilmez. Generic bir arayüz taban sınıf referansı olarak
    kullanıldığında yine uygun açılım yapılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        B b = new B();
        IX<String> xo;

        xo = b;
    }
}

class C implements IX<Object> {
    public void foo(Object o)
    {
        //...
    }
}

class B implements IX<String> {
    public void foo(String str)
    {
        //...
    }
}
class A<T> implements IX<T> {
    public void foo(T t)
    {

    }
}

interface IX<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte gerneric bir türün her açılımı ayrı bir tür belitmediğinden A sınıfı aynı interface'i implemente
    etmiş olur ve bu durum da geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX<Integer>, IX<String> { //error
    //...
    public void foo(Integer i)
    {
        //...
    }

    public void foo(String s)
    {
        //...
    }
}

interface IX<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnek geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX<Integer>, IY<Integer> {
    //...
    public void foo(Integer i)
    {
        //...
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte aynı metot yazıldığı için error oluşur. Çünkü ilgili metotların parametreleri çalışma zamanında
    Object olarak değerlendirilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class A implements IX<Integer>, IY<String> {
    //...
    public void foo(Integer i)
    {
        //...
    }

    public void foo(String s)
    {
        //...
    }
}
interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
    enum sınıfları ve exception sınıfları generic olarak bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class MyException<T> extends RuntimeException { //error

}

enum Color<T> { //error

}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metot generic olarak bildirilebilir. Generic bir metodun generic tür pametreleri metodun geri dönüş değerinden
    önce açısal parantez içerisinde bildirilir. Generic bir metot çağrısında generic parametrelerin türleri çağrı
    sırasında tespit edilebiliyorsa (type inference/deduction) bu durumda açılım yapmaya gerek yoktur. Açılım metot
    isminden önce açısal parantez içerisinde yapılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();

        s.foo(6, "ankara");
        s.<Integer, String>foo(6, "ankara");
    }
}

class Sample {
    public <T, K> void foo(T t, K k)
    {
        Console.writeLine(t);
        Console.writeLine(k);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki demo örnekte açılım yapılarak generic metodun çağrılması sağlanamaz. Bu durumda derleyici argümanın
    türüne göre seçim yapar. Örnekte generic metodun ilgili int türden argüman ile çağrılabilmesi için kutulama
    yapılabilir. Örnekte Sample sınıfının foo metotlarını yazan programcı int türü için foo işlemini özelleştirmiştir.
    Bu anlamda bu kavrama "generic parameter type specialization" da denebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.console.Console;

class App {
    public static void main(String[] args)
    {
        Sample s = new Sample();

        s.foo(10);
        s.<Integer>foo(10);
        s.foo(Integer.valueOf(10));
    }
}

class Sample {
    public <T, K> void foo(T t)
    {
        Console.writeLine("Generic");
        Console.writeLine(t);
    }

    public void foo(int a)
    {
        Console.writeLine("int");
        Console.writeLine(a);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Generic bir sınıfın generic metodu olabilir. Buna "member generic" de denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample<String> ss = new Sample<>();
        Sample<Integer> si = new Sample<>();

        ss.foo("ankara", true);
        ss.foo("istanbul", "ankara");
        ss.foo("zonguldak", 67);

        si.foo(6, "ankara");
    }
}

class Sample<T> {
    public <K> void foo(T t, K k)
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Generic bir sınıfın generic tür parametresi static bir metot içerisinde kullanılamaz. Yani generic sınıfın generic
    tür parametre isminin faaliyet alanına (scope) static metotlar dahil değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample<T> {
    public static void foo(T t) //error
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem static metot generic yapılarak çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample.foo(10);
        Sample.foo("ankara");
    }
}

class Sample<T> {
    public static <K> void foo(K k)
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte metodun generic tür paramtre ismi sınıfın generic tür parametre ismi ile aynı olabilir. Faaliyet
    alanı kuralları böylesi isimlendirme geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String[] args)
    {
        Sample.foo(10);
        Sample.foo("ankara");
    }
}

class Sample<T> {
    public static <T> void foo(T t)
    {
        //...
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    Programlamada bir n-liyi (n-ary) temsil eden veri yapılarına genel olarak "tuple" denilmektedir. JavaSE'de "tuple"'ı
    temsil eden sınıflar doğrudan bulunmamaktadır. Böylesi sınıflar pratikte gerektiğinde programcı ya kendisi bir
    kütüphane yazar ve projelerinde kullanır ya da yazılmış olan iyi kütüphaneleri projelerinde kullanır. Şüphesiz
    bir tuple'ın generic olması daha uygundur.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Generic bir sınıfın generic tür parametreleri için açılımda ? (wildcard) kullanılabilir. Bu generic
    tür anlamında "any type" demektir. Türün kullanımının önemli olmadığı durumlar için düşünülmüştür. "Wildcard" kullanımına
    ilişkin detaylar uygulama kurslarında ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pair sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.tuple.test;

import org.csystem.tuple.Pair;
import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

public class PairCtorTest {
    public static void run()
    {
        ArrayList<Pair<Integer, String>> pairs = new ArrayList<>();
        Random random = new Random();


        while (true) {
            int val = random.nextInt(-100, 100);

            if (val == 0)
                break;

            pairs.add(new Pair<>(val, StringUtil.generateRandomTextTR(random, random.nextInt(5, 11))));
        }

        for (Pair<Integer, String> p : pairs)
            Console.writeLine(p);
    }

    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.tuple.test;

import org.csystem.tuple.Pair;
import org.csystem.util.console.Console;
import org.csystem.util.string.StringUtil;

import java.util.ArrayList;
import java.util.Random;

public class PairOfTest {
    public static void run()
    {
        ArrayList<Pair<Integer, String>> pairs = new ArrayList<>();
        Random random = new Random();


        while (true) {
            int val = random.nextInt(-100, 100);

            if (val == 0)
                break;

            pairs.add(Pair.of(val, StringUtil.generateRandomTextTR(random, random.nextInt(5, 11))));
        }

        for (Pair<Integer, String> p : pairs)
            Console.writeLine(p);
    }

    public static void main(String[] args)
    {
        run();
    }
}

/*--------------------------------------------------------
	FILE NAME	: Pair.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 3rd March 2024

	Pair class that represents a tuple

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.tuple;

public final class Pair<F, S> {
    public final F first;
    public final S second;

    public Pair(F first, S second)
    {
        this.first = first;
        this.second = second;
    }

    public static <F, S> Pair<F, S> of(F first, S second)
    {
        return new Pair<>(first, second);
    }

    public boolean equals(Object other)
    {
        return other instanceof Pair<?, ?> p && first.equals(p.first) && second.equals(p.second);
    }

    //...

    public String toString()
    {
        return String.format("(%s, %s)", first, second);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    09.03.2024
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.tuple.test;

import org.csystem.tuple.Triple;
import org.csystem.util.console.Console;

import java.util.ArrayList;
import java.util.Random;

public class TripleOfTest {
    public static void run()
    {
        ArrayList<Triple<Integer, Integer, Integer>> points = new ArrayList<>();
        Random random = new Random();

        while (true) {
            int val = random.nextInt(-100, 100);

            if (val == 0)
                break;

            points.add(Triple.of(random.nextInt(-100, 100), random.nextInt(-100, 100), random.nextInt(-100, 100)));
        }

        for (Triple<Integer, Integer, Integer> point : points)
            Console.writeLine(point);
    }

    public static void main(String[] args)
    {
        run();
    }
}
/*--------------------------------------------------------
	FILE NAME	: Triple.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 9th March 2024

	Triple class that represents a tuple

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.tuple;

public final class Triple<F, S, T> {
    public final F first;
    public final S second;
    public final T third;

    public Triple(F first, S second, T third)
    {
        this.first = first;
        this.second = second;
        this.third = third;
    }

    public static <F, S, T> Triple<F, S, T> of(F first, S second, T third)
    {
        return new Triple<>(first, second, third);
    }

    public boolean equals(Object other)
    {
        return other instanceof Triple<?,?,?> t
                && first.equals(t.first) && second.equals(t.second) && third.equals(t.third);
    }

    //...

    public String toString()
    {
        return String.format("(%s, %s, %s)", first, second, third);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıf ya da bir metodun generic tür parametresi için bir kısıt verilebilir. Örneğin bir sınıf generic tür
    parametresi için TWR kullanmak isteyebilir. Yani genric türün AutoCloseable olması tasarımdan dolayı gerekebilir. Bu
    durumda derleyici generic tür parametresinin AutoCloseable olduğunu nasıl anlayacaktır? Bu durumda generic tür
    parametreleri için kısıtlar (constraint) verilebilir. Bunun için genel olarak extends anahtar söcüğü kullanılır.
    Kısıt verilen generic tür parametreleri, verilen kısıtlara uygun olarak açılmalıdır. Aksi durumda error oluşur.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.FileOutputStream;

class App {
    public static void main(String[] args)
    {
        Sample<FileOutputStream, MyRunnable> s1 = new Sample<>();
        Sample<Closeable, Runnable> s2 = new Sample<>();
        Sample<String, Runnable> s3; //error
        //...
    }
}

class MyRunnable implements Runnable {
    public void run()
    {
        //...
    }
}

class Sample<T extends AutoCloseable, K extends Runnable> {
    //...
    public void foo(T t, K k)
    {
        try (t) {
            k.run();
        }
        catch (Exception ex)  {
            //...
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Generic parametrelere ilişkin kısıtların diğer detayları Java ile Uygulama Geliştirme kurslarında
    ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Generic türden bir nesne new operatörü ile doğrudan yaratılamaz. Benzer şekilde generi türden bir dizi de new
    operatörü ile doğrudan yaratılamaz. Bunun için pek çok yöntem vardır. Burada aşağıdaki yöntemle nesne yaratma ele
    alınacaktır. Aşağıdaki yöntemde nesne için önce Object türden nesne yaratılmış sonra tür dönüştürme operatörü ile
    generic türe dönüştürülmüştür. Benzer şekilde dizi için önce Object türden bir dizi yaratılmış sonra generic dizi
    referansına explicit olarak dönüştürülmüştür. Diğer yöntemler burada ele alınmayacaktır.

    Anahtar Notlar: Bu yöntemde bir çok static kod analizi aracı uyarı verebilecektir. Bu uyarı ve nedeni şu aşamda
    önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
class Sample<T> {
    private T m_t;
    private T [] m_a;

    public Sample(int size)
    {
        m_t = (T)new Object();
        m_a = (T[])new Object[size];
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    17.03.2024
----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: ArrayUtil.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 17th March 2024

	Utility class for array operations

	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.util.array;

import java.util.ArrayList;
import java.util.random.RandomGenerator;


public final class ArrayUtil {
    private ArrayUtil()
    {}

    private static void bubbleSortAscending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k + 1] < a[k])
                    swap(a, k, k + 1);
    }

    private static void bubbleSortDescending(int [] a)
    {
        for (int i = 0; i < a.length - 1; ++i)
            for (int k = 0; k < a.length - 1 - i; ++k)
                if (a[k] < a[k + 1])
                    swap(a, k, k + 1);
    }

    private static void selectionSortAscending(int [] a)
    {
        int min, minIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            min = a[i];
            minIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (a[k] < min) {
                    min = a[k];
                    minIndex = k;
                }

            a[minIndex] = a[i];
            a[i] = min;
        }
    }

    private static void selectionSortDescending(int [] a)
    {
        int max, maxIndex;

        for (int i = 0; i < a.length - 1; ++i) {
            max = a[i];
            maxIndex = i;

            for (int k = i + 1; k < a.length; ++k)
                if (max < a[k]) {
                    max = a[k];
                    maxIndex = k;
                }

            a[maxIndex] = a[i];
            a[i] = max;
        }
    }

    public static void addBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] += val;
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc)
            bubbleSortDescending(a);
        else
            bubbleSortAscending(a);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [] a, int origin, int bound)
    {
        fillRandomArray(randomGenerator, a, a.length, origin, bound);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [] a, int count, int origin, int bound)
    {
        for (int i = 0; i < count; ++i)
            a[i] = randomGenerator.nextInt(origin, bound);
    }

    public static void fillRandomArray(RandomGenerator randomGenerator, int [][] a, int origin, int bound)
    {
        for (int [] array : a)
            fillRandomArray(randomGenerator, array, origin, bound);
    }

    public static int [] generateRandomArray(RandomGenerator random, int count, int origin, int bound)
    {
        int [] a = new int[count];

        fillRandomArray(random, a, origin, bound);

        return a;
    }

    public static int [] histogramData(int [] a, int n)
    {
        int [] result = new int[n + 1];

        for (int val : a)
            ++result[val];

        return result;
    }

    public static boolean isEmpty(int [] a)
    {
        return a.length == 0;
    }

    public static String join(ArrayList<String> list, char separator)
    {
        return join(list, String.valueOf(separator));
    }

    public static String join(ArrayList<String> list, String separator)
    {
        StringBuilder sb = new StringBuilder();

        for (String s : list)
            sb.append(s).append(separator);

        return sb.substring(0, sb.length() - separator.length());
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.max(val, result);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int val : a)
            result = Math.min(val, result);

        return result;
    }

    public static void multiplyBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] *= val;
    }

    public static int partition(int [] a, int threshold)
    {
        int partitionIndex = 0;

        while (partitionIndex != a.length && a[partitionIndex] < threshold)
            ++partitionIndex;

        if (partitionIndex == a.length)
            return partitionIndex;

        for (int i = partitionIndex + 1; i < a.length; ++i)
            if (a[i] < threshold)
                swap(a, i, partitionIndex++);

        return partitionIndex;
    }

    public static void print(int [] a)
    {
        print(1, a);
    }

    public static void print(int n, int [] a)
    {
        print(n, a, a.length);
    }

    public static void print(int [] a, int count)
    {
        print(1, a, count);
    }

    public static void print(int n, int [] a, int count)
    {
        print(n, a, count, " ", "\n");
    }

    public static void print(int [] a, int count, String sep, String end)
    {
        print(1, a, count, sep, end);
    }

    public static void print(int n, int [] a, int count, String sep, String end)
    {
        String fmt = String.format("%%0%dd%%s", n);

        for (int i = 0; i < count; ++i)
            System.out.printf(fmt, a[i], sep);

        System.out.print(end);
    }

    public static void print(int [][] a)
    {
        print(1, a);
    }

    public static void print(int n, int [][] a)
    {
        for (int [] array : a)
            print(n, array);
    }

    public static void reverse(int [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static void reverse(char [] a)
    {
        for (int i = 0; i < a.length / 2; ++i)
            swap(a, i, a.length - 1 - i);
    }

    public static int [] reversed(int [] a)
    {
        int [] result = new int[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static char [] reversed(char [] a)
    {
        char [] result = new char[a.length];

        for (int i = a.length - 1; i >= 0; --i)
            result[result.length - 1 - i] = a[i];

        return result;
    }

    public static void selectionSort(int [] a)
    {
        selectionSort(a, false);
    }

    public static void selectionSort(int [] a, boolean desc)
    {
        if (desc)
            selectionSortDescending(a);
        else
            selectionSortAscending(a);
    }

    public static void subtractBy(int [][] a, int val)
    {
        for (int i = 0; i < a.length; ++i)
            for (int k = 0; k < a[i].length; ++k)
                a[i][k] -= val;
    }

    public static int sum(int [] a)
    {
        int total = 0;

        for (int val : a)
            total += val;

        return total;
    }

    public static void swap(int [] a, int i, int k)
    {
        int temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }

    public static void swap(char [] a, int i, int k)
    {
        char temp = a[i];

        a[i] = a[k];
        a[k] = temp;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Sınıf Çalışması: CSDArrayList<E> sınıfını aşağıdaki açıklamalara göre yazınız:
    Açıklamalar:
        - Sınıfın metotları ArrayList<E> sınıfındaki metotların yaptığı işleri yapacaktır.
        - Metotların karmaşıklıklarının ArrayList<E> ile aynı olması gerekir.
        - Metotlarda fırlatılacak exception'lar yine ArrayList<E> ile aynı olacaktır.
        - Sınıfın public bölümünü değiştirmeden istediğiniz eklemeyi yapabilirsiniz.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Anahtar Notlar: Anımsanacağı gibi bir nesneyi gösteren en az bir tane referans kaldığında nesne eligible duruma
    geçemez. Bu durumda GC devreye girdiğinde nesneyi çöp olarak kabul etmez. Bazı durumlarda programcı nesneyi referanstan
    kopartmayı gözden kaçırırsa bu durumda nesne hiç bir zaman eligible duruma gelemez. ArrayList sınıfının clear metodunda
    ve remove metodunda böylesi bir durum oluşmaması için referanslar null'a çekilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.collection.test;

import org.csystem.collection.CSDArrayList;
import org.csystem.util.console.Console;

public class CSDArrayListConstructorTest {
    public static void run()
    {
        CSDArrayList<String> list = new CSDArrayList<>(11);

        Console.writeLine("Size:%d", list.size());
        Console.writeLine("Capacity:%d", list.capacity());
    }
    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.collection.test;

import org.csystem.collection.CSDArrayList;
import org.csystem.util.console.Console;

public class CSDArrayListAddTest {
    public static void run()
    {
        CSDArrayList<String> list = new CSDArrayList<>(3);

        while (true) {
            String str = Console.readString("Bir yazı giriniz:");

            if ("elma".equals(str))
                break;

            list.add(str);
        }

        Console.writeLine(list);
        Console.writeLine("Size:%d", list.size());
        Console.writeLine("Capacity:%d", list.capacity());
    }
    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.collection.test;

import org.csystem.collection.CSDArrayList;
import org.csystem.util.console.Console;

public class CSDArrayListAddWithIndexTest {
    public static void run()
    {
        CSDArrayList<String> list = new CSDArrayList<>(3);

        while (true) {
            String str = Console.readString("Bir yazı giriniz:");

            if ("elma".equals(str))
                break;

            list.add(0, str);
        }

        Console.writeLine(list);
        Console.writeLine("Size:%d", list.size());
        Console.writeLine("Capacity:%d", list.capacity());
    }
    public static void main(String[] args)
    {
        run();
    }
}

package org.csystem.collection.test;

import org.csystem.collection.CSDArrayList;
import org.csystem.util.console.Console;

public class CSDArrayListRemoveTest {
    public static void run()
    {
        CSDArrayList<String> list = new CSDArrayList<>(3);

        while (true) {
            String str = Console.readString("Bir yazı giriniz:");

            if ("elma".equals(str))
                break;

            list.add(str);
        }

        Console.writeLine(list);

        try {
            String old = list.remove(3);

            Console.writeLine("Silinen eleman:%s", old);
        }
        catch (IndexOutOfBoundsException ex) {
            Console.writeLine(ex.getMessage());
        }

        Console.writeLine(list);
    }
    public static void main(String[] args)
    {
        run();
    }
}

/*----------------------------------------------------------------
	FILE		: CSDArrayList.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 17th Mar 2024

	CSDArrayList collection class that represents a dynamic array

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.collection;

import java.util.Arrays;

public class CSDArrayList<E> {
    private static final int DEFAULT_CAPACITY = 10;
    private E [] m_elements;
    private int m_index;

    private void throwIllegalArgumentException(String message)
    {
        throw new IllegalArgumentException(message);
    }

    private void throwIndexOutOfBoundsException(String message)
    {
        throw new IndexOutOfBoundsException(message);
    }

    private void checkCapacity(int capacity)
    {
        if (capacity < 0)
            throwIllegalArgumentException(String.format("Capacity must be non-negative:%d", capacity));
    }

    private void checkIndex(int index)
    {
        if (index < 0 || index >= m_index)
            throwIndexOutOfBoundsException(String.format("Index out of bounds:%d", index));
    }

    private void changeCapacity(int capacity)
    {
        m_elements = Arrays.copyOf(m_elements, capacity);
    }

    private void increaseCapacityIfNecessary()
    {
        if (m_elements.length == m_index)
            changeCapacity(m_elements.length == 0 ? 1 : m_elements.length * 2);
    }

    public CSDArrayList()
    {
        m_elements = (E[])new Object[DEFAULT_CAPACITY];
    }

    public CSDArrayList(int initialCapacity)
    {
        checkCapacity(initialCapacity);
        m_elements = (E[])new Object[initialCapacity];
    }

    public boolean add(E element)
    {
        increaseCapacityIfNecessary();
        m_elements[m_index++] = element;

        return true;
    }

    public void add(int index, E element)
    {
        increaseCapacityIfNecessary();

        for (int i = m_index++; i > index; --i)
            m_elements[i] = m_elements[i - 1];

        m_elements[index] = element;
    }

    public int capacity()
    {
        return m_elements.length;
    }

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elements[i] = null;

        m_index = 0;
    }

    public void ensureCapacity(int minCapacity)
    {
        if (minCapacity > m_elements.length)
            changeCapacity(Math.max(minCapacity, m_elements.length * 2));
    }

    public E get(int index)
    {
        checkIndex(index);

        return m_elements[index];
    }

    public E remove(int index)
    {
        checkIndex(index);
        E oldElement = m_elements[index];

        for (int i = index; i < m_index - 1; ++i)
            m_elements[i] = m_elements[i + 1];

        m_elements[--m_index] = null;

        return oldElement;
    }

    public E set(int index, E element)
    {
        checkIndex(index);
        E oldElement = m_elements[index];

        m_elements[index] = element;

        return oldElement;
    }

    public int size()
    {
        return m_index;
    }

    public void trimToSize()
    {
        if (m_elements.length != m_index)
            changeCapacity(m_index);
    }

    public String toString()
    {
        StringBuilder sb = new StringBuilder("[");

        for (int i = 0; i < m_index; ++i)
            sb.append(m_elements[i]).append(", ");

        return (m_index != 0 ? sb.substring(0, sb.length() - 2) : sb.toString()) + "]";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Bir kesri temsil eden Fraction isimli sınıfı aşağıdaki açıklamalara göre yazınız
	Açıklamalar:
	+ Sınıf Matematikteki bir kesri temsil ettiğinden pay (numerator) ve payda (denominator) değerleri tutulacaktır

	+ Sınıfın ilgili set ve get metotları yazılacaktır

	+ Pay'ın sıfırdan farklı veya sıfır ve paydanın sıfır olması durumunda uygun mesajla birlikte NumberFormatException
	fırlatılacaktır

	+ Kesir her durumda sadeleşmiş bir biçimde tutulacaktır. Örneğin kesrin pay ve paydası sırasıyla 4 ve 18 olarak
	verildiğinde kesir 2 / 9 olarak tutulacaktır.

	+ Kesir negatif ise işaret payda bulunacaktır. Örneğin kesrin pay ve paydası sırasıyla 3 ve -4 olarak verilmişse
	kesir -3 / 4 biçiminde tutulacaktır

	+ Kesrin pay ve paydasının her ikisinin birden negatif olması durumunda kesir pozitif olarak tutulacaktır

	+ Kesrin payının sıfır olması durumunda payda ne olursa olsun 1(bir) yapılacaktır

	+ Sınıfın iki kesri toplayan, bir kesir ile bir tamsayıyı toplayan metotları olacaktır. Aynı işlemler
	 çıkarma, çarpma ve bölme için de yapılacaktır

	+ Sınıfın kesri 1(bir) artıran ve bir azaltan inc ve dec metotları yazılacaktır

	+ Sınıfın toString metodu şu formatta yazı döndürecek şekilde override edilecektir:
	    3 / 10 kesri için -> 3 / 10 = 3.333333
	    10 / 1 kesri için -> 10
	 Ondalık kısımda 6 basamak gösterilecektir. Geri kalan basamaklar yuvarlanacaktır,

	+ Sınıfın equals metodu iki kesrin eşitlik karşılaştırması için override edilecektir

	+ Sınıfın default ctor'u "0 / 1" kesrini temsil eden nesneyi yaratmak için kullanılabilecektir

	+ Sınıfın compareTo metodu iki kesrin büyüklük küçüklük karşılaştırmasını yapacaktır. String sınıfının compareTo
	 metodunun mantığına göre tasarlayınız

	+ Kesrin double türden ondalık değerini döndüren getRealValue metodu yazılacaktır

	+ Sınıfın public bölümünü değiştirmeden istediğiniz değişikliği ve eklemeleri yapabilirsiniz

	Sınıfın public bölümü ile birlikte iskeleti şu şekildedir:

    package org.csystem.math;

    public class Fraction {
         public Fraction()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction(int a)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction(int a, int b)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public int getNumerator()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public void setNumerator(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public int getDenominator()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public void setDenominator(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public double getRealValue()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction add(Fraction other)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction add(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction subtract(Fraction other)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction subtract(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction multiply(Fraction other)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction multiply(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction divide(Fraction other)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public Fraction divide(int val)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public void inc()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public void dec()
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public int compareTo(Fraction other)
         {
             throw new UnsupportedOperationException("TODO:");
         }

         public boolean equals()
         {
            throw new UnsupportedOperationException("TODO:");
         }

         public String toString()
         {
             throw new UnsupportedOperationException("TODO:");
         }
    }
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------
	FILE		: Fraction.java
	AUTHOR		: Java-Mar-2023 Group
	LAST UPDATE	: 6th April 2024

	Fraction class that represents fraction

	Copyleft (c) 1993 C and System Programmers Association
	All Rights Free
----------------------------------------------------------------*/
package org.csystem.math;

import java.io.Serial;
import java.io.Serializable;

public class Fraction implements Serializable {
    @Serial
    private static final long serialVersionUID = -1L;
    private int m_a;
    private int m_b;

    private static Fraction add(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Fraction subtract(int a1, int b1, int a2, int b2)
    {
        return add(a1, b1, -a2, b2);
    }

    private static Fraction multiply(int a1, int b1, int a2, int b2)
    {
        return new Fraction(a1 * a2, b1 * b2);
    }

    private static Fraction divide(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void check(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
                throw new NumberFormatException("Indeterminate");

            throw new NumberFormatException("Undefined");
        }
    }

    private void setSign()
    {
        if (m_b < 0) {
            m_b = -m_b;
            m_a = -m_a;
        }
    }

    private void simplify()
    {
        int min = Math.min(m_b, Math.abs(m_a));

        for (int i = min; i >= 2; --i)
            if (m_a % i == 0 && m_b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
    }

    private void set(int a, int b)
    {
        if (a == 0) {
            m_a = 0;
            m_b = 1;
            return;
        }
        m_a = a;
        m_b = b;
        setSign();
        simplify();
    }

    public Fraction()
    {
        m_b = 1;
    }

    public Fraction(int a)
    {
        m_a = a;
        m_b = 1;
    }

    public Fraction(int a, int b)
    {
        check(a, b);
        set(a, b);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public void setNumerator(int val)
    {
        if (val == m_a)
            return;

        set(val, m_b);
    }

    public int getDenominator()
    {
        return m_b;
    }

    public void setDenominator(int val)
    {
        if (val == m_b)
            return;

        check(m_a, val);
        set(m_a, val);
    }

    public double getRealValue()
    {
        return (double)m_a / m_b;
    }

    public Fraction add(Fraction other)
    {
        return add(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction add(int val)
    {
        return add(m_a, m_b, val, 1);
    }

    public Fraction subtract(Fraction other)
    {
        return subtract(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction subtract(int val)
    {
        return subtract(m_a, m_b, val, 1);
    }

    public Fraction multiply(Fraction other)
    {
        return multiply(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    public Fraction divide(Fraction other)
    {
        return divide(m_a, m_b, other.m_a, other.m_b);
    }

    public Fraction divide(int val)
    {
        return divide(m_a, m_b, val, 1);
    }

    public void inc()
    {
        m_a += m_b;
    }

    public void dec()
    {
        m_a -= m_b;
    }

    public int compareTo(Fraction other)
    {
        //Burada Ortak Katların En Küçüğü (Least Common Multiplier) bulunabilir
        return m_a * other.m_b - other.m_a * m_b;
    }

    public boolean equals(Object other)
    {
        return other instanceof Fraction f && m_a == f.m_a && m_b == f.m_b;
    }

    public String toString()
    {
        return String.format("%d%s", m_a, m_b != 1 ? String.format(" / %d = %f", m_b, getRealValue()) : "");
    }
}



/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
