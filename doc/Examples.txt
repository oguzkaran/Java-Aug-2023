/*----------------------------------------------------------------------------------------------------------------------
										Java ile Nesne Yönelimli Programlama

											   Eğitmen: Oğuz KARAN

										C ve Sistem Programcıları Derneği
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	05.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java, hem programlama diline hem de ortamına (platform) verilen bir isimdir. Genel olarak kursumuzda Java dendiğinde
	programlama dili anlaşılacaktır. Ayrıca Java ortamı için JavaSE'de kullanılacaktır. Aslında JavaSE de genel bir
	terimdir.

	Java Ortamının Temel Özellikler:
	- Arakodlu çalışma sistemi: C ve C++ gibi dillerde yazılan programdan üretilen dosya (executable file)
	sistem düzeyinde (donanım, isletim sistemi vs.) çalışabilir. Örneğin, Windows işletim sistemi için üretilmiş
	bir program, Mac OS işletim sisteminde doğrudan çalıştırılamaz. O sistem için çalışabilir dosyanın ayrıca üretilmesi
	gerekir. Java'da yazılan programdan üretilen kod geneldir ve herhangi bir sisteme özgü değildir. Kendine ait
	standart formatı vardır. Bu şekilde üretilen dosyalara genel olarak "ara kod (intermediate code)" denir. Java özelinde
	bu arakoda "byte code" denir. Bu durumda byte code'u işletim sistemi çalıştıramaz. İşte bu durumda bu kodu çalıştıran
	işletim sistemine özgü ayrı bir program kullanılır. Bu programa genel olarak "Java Virtual Machine (JVM)" denir. Aslında
	sistem düzeyinde çalışan program budur. JVM arakodu yorumlayarak makine koduna (machine code) dönüştürür. Bu işleme
	"Just In Time Compilation (JIT)" denir. Böylesi bir tasarımın en büyük avantajı programın taşınabilirliğidir. Yani
	Java programcısı, programını bir kez yazar ve bir kez byte code'unu üretir ve bu byte her sistemde çalıştırılabilir.
	Şüphesiz bu durumun da istisnaları vardır. Ancak unutulmamalıdır ki, arakodlu çalışma sistemi görece yavaştır. Ancak
	bu yavaşlık Java'nın hedeflediği uygulamalar açısından önemsizdir. Geliştirme ve çalıştırma anlamında şu temel kavramlar
	önemlidir:
		- JVM (Java Virtual Machine): Byte code'u yorumlayarak aşağı seviyeli makine koduna dönüştürür. Aslında JVM
		byte code'un nasıl yorumlayanacağına yönelik soyut bir kavramdır.

		- JRE (Java Runtime Environment): genel olarak Java ile yazılmış bir uygulamayı çalıştırmak için gereken araçları ve
		uygulamaları içeren bir pakettir. Yani Java ile yazılmış bir programın çalıştırılabilmesi için JRE gereklidir.

		- JDK (Java Development Kit): Geliştirme (development) için kullanılan araçları barındıran bir pakettir. JDK içerisinde
		geliştirme yaparken kullanılmak üzere çalıştırma araçları da bulunur.

		Ticari kullanımlarda Java 11 ile birlikte bir takım değişiklikler yapılmıştır. Şu şekilde özetlenebilir: Genel olarak geliştirme ortamı
		ücretsizdir, çalıştırma ortamı ücretli olabilir ancak ücretsiz olanları da vardır. Bu konuların detayları vardır. Bu
		bölümde ele alınmayacaktır. Örneğin Oracle firmasının JRE'si ücretlidir ancak Open JRE denilen tamamen ücretsiz bir
		ortam da mevcuttur.

		Arakodlu çalışma sisteminin yukarıda anlatılan avantajına "Write Once Run Anywhere (WORA)" da denilmektedir.

	- Hızlı uygulama geliştirme ortamı: Java hızlı uygulama geliştirme (rapid application development) ortamı sunar. Bu anlamda
	ürün elde edilmesi daha çabuk olabilmektedir ve aynı zamanda öğrenmesi de görece kolay olabilmektedir.

	- Geniş bir sınıf kütüphanesi: Java'da (JavaSE'de) geniş bir sınıf kütüphanesi vardır. Veritabanı işlemleri, web programlama
	vb. için gereken bir çok sınıf hazır olarak bulunmaktadır.

	- Güvenli çalışma ortamı: Java'da yazılan programların, programcının yaptığı hatalardan dolayı sisteme zarar verme olasıkları
	çok çok azdır. Bu da güvenli bir çalışma ortamı sunmasına yol açar.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	06.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programlama Dillerinin Sınıflandırılması: Programlama dilleri çeşitli şekillerde sınıflandırılabilse de genel olarak
	3 şekilde sınıflandırma eğilimi söz konusudur:
	1. Seviyelerine (level) göre sınıflandırma: Programlama dilinin seviyesi onun insan algısına yakınlığının ölçüsüdür. Yüksek
	seviyeli diller (high level languages) hem dil özellikleri, hem de uygulama geliştirme anlamında insan algısına yakınlıkları
	dolayısıyla daha kolay öğrenebilirler. Düşük seviyeli diller (low level languages) makineye daha yakın dillerdir. Olabilecek
	en düşük seviyeli dil makine dilidir.

	2. Kullanım alanlarına göre sınıflandırma: Dilin hangi alanlarda kullanılabileceğine göre sınıflandırmadır. Bazı diller
	birden fazla alanda kullanılabilirler. Bazı diller ise sadece bir alanda kullanılabilirler. Bu anlamda genel amaçlı diller,
	bilimsel ve mühendislik dilleri, veritabanı dilleri, yapay zeka dilleri, oyun ve animasyon dilleri vb. alanlar için diller
	söz konusu olabilmektedir.

	3. Programlama modeline göre sınıflandırma: Bir programı yazarken kullanılan genel model (paradigm) önemlidir. Bazı dillerde
	sınıf yoktur. Program çeşitli alt programların (function) bir araya getirilmesiyle yazılır. Bu modele "procedurel model"
	denir. Bazı dillerde sınıflar vardır ve programlar sınıflar kullanılarak yazılır. Başka bir çok kavramla birlikte sınıflar
	kullanılarak yazılan programlama modeline "nesne yönelimli model (object oriented model)" denir. Bazı dillerde programlar
	matematiksel formül yazıyormuş gibi yazılmaktadır. Bu tarz programlama modeline "fonksiyonel (functional)" model denir.
	Bazı diller birden fazla modeli desteklerler. Bu tarz dillere "multi paradigm languages" denilmektedir. Birden fazla modeli
	destekleyen diller, modellerin tüm özelliklerini desteklemeyebilir.

	Bu durumda Java, bilimsel ve mühendislik uygulamalarında, web uygulamalarında, yapay zeka uygulamalarında, mobil
	programlamada vb. kullanılabilen genel amaçlı, yüksek seviyeli, nesne yönelimli programlama modeli ile uygulama
	geliştirilebilen ve özellikle Java 8 ile birlike fonksiyonel programlama modelini de belirli ölçüde destekleyen
	"multi paradigm" bir dildir.

	Anahtar Notlar: Bir dilin bir çok alanda kullanılabilmesi, o dilin tüm alanlarında pratikte kullanılacağı anlamına gelmez.
	Bir alanda daha etkin kullanılabilen bir dil varsa o dil daha fazla tercih edilebilir.

	Anahtar Notlar: Yukarıda anlatılan kavramların detayları vardır. Zaman içerisinde anlaşılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Temel Kavramlar:
	Çevirici Programlar, Derleyiciler ve Yorumlayıcılar: Bir dilde yazılmış programı başka bir dile çeviren programlara
	çevirici programlar (translator) denir. Çevirici programlarda bir kaynak dil (source language) ve bir hedef dil (target/destination language)
	vardır. Kaynak dil yüksek seviyeli, hedef dil düşük seviyeli bir programlama diliyse bu durumda çevirici programa
	derleyici (compiler) denir. Örneğin Java programlama dilinden Kotlin programlama diline dönüştürme yapan program
	bir translator, Java programlama dilinden byte code'a dönüştürme yapan program ise bir compiler'dır. JVM'in byte code'u
	makine kodu makine koduna çevirme faaliyeti de bir derleme işlemidir. Bu sebeple buna JIT compilation denir. Bazı
	dillerde yazılan programlar herhangi bir kod üretilmeden çalıştırılırlar. Bu tarz dillerde yazılmış programları
	herhangi bir kod üretmeden çalıştıran programlara "interpreter" denir. Bazı diller hem derleyici hem yorumlayıcı ile
	kullanılabilirler. Java pratikte derleyici ile kullanılan Java 11 ile birlikte "java" programı yorumlayıcı olarak da
	java kodunu byte code üretilmeden çalıştırabilmektedir. Yorumlayıcı ile kullanılan diller derleyici ile kullanılan dillere
	göre daha yavaş olma eğilimindedir.

	Anahtar Notlar: Bir uygulama tek bir java dosyasından oluşmak zorunda değildir. Hatta bir Java uygulaması yalnızca
	java kodlarından da oluşmak zorunda değildir. Bu durumda farklı java dosyaları ayrı derlenir. Hatta aynı dosyada
	bulunan sınıflar da ayrı derlenir. Bir ürün aslında tüm birimlerinin uygun şekilde derlenmesi ve ele alınmasıyla
	elde edilir. Bu işleme genel olarak "build" terimi kullanılır. Build işlemi yalnızca derleme işlemi değildir. Yani
	bir uygulamanın ürün olarak elde edilmesi süreci "build" işlemidir. Burada anlatılanların da detayları zamanla
	ele alınacaktır.

	İşletim Sistemi (Operating System): Makinenin donanımını yöneten, bilgisayar ile kullanıcı arasında bir köprü oluşturan
	yazılımdır. Br işletim sisteminin pek çok görevi vardır. Programları çalıştırmak, çeşitli cihazları ve aygıtları yönetmek,
	dosyaları ve dizinleri (directory) organize etmek vb. görevler sayılabilir. İşletim sistemleri genel olarak iki gruba
	ayrılabilir: masaüstü işletim sistemleri (desktop operating systems), mobil işletim sistemleri (mobile operating systems).
	Şüphesiz başka çeşit işletim sistemleri de vardır. Popüler masaüstü işletim sistemleri Windows, Mac OS X, Unix ve Linux
	gibi işlemleridir. Popüler mobil işletim sistemleri Android ve IOS'dur.

	Açık kaynak kodlu yazılım, özgür yazılım ve mülkiyete sahip yazılım: Özgür yazılım (free software) ve açık kaynak kodlu
	(open source) yazılımlar arasında farklar olsa genel olarak aşağıdaki ortak özelliklere sahiptirler:
		- Bedavadır. Kullanılabilmesi için herhangi bir lisans gerekmez.
		- Kaynak kodlar sahiplenilemez. Kaynak koda ekleme yapıldığında ya da bir kaynak kod kullanıldığında kodlar kapatılamaz.
		Onların da açılması gerekir.
		- Çoğaltılabilir, izin almadan kullanılabilir.

	Bunun tam tersi olarak mülkiyete sahip (propriatery) yazlımlardır. Bu yazılımlar para verilerek kullanılır ve izin
	almadan çoğaltılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	IDE (Integrated Development Environment): Derleyicler ve yorumlayıcılar komut satırından çalışan ve basit arayüzlere
	sahip programlardır. Aslında teorik olarak bir uygulamadaki tüm Java dosyaları ve diğer dosyalar basit bir editör programla
	yazılıp komut satırından derlenebilir. Ancak bu uygulama büyüdükçe zahmetli olmaya başlar. Bu da programcıya zaman
	kaybettirir. Bu amaçla pratikte yazılm geliştirmeyi kolaylaştırmak için IDE denilen yazılımlar kullanılır. IDE'lerde
	örneğin bir takım yardımlar veren editörler, tasarım araçları, test araçları, debug araçları vb. programcının geliştirme
	sırasında kullandığı araçlar bulunur. Java ile uygulama geliştirmede iki tane IDE yoğun olarak kullanılmaktadır:
	Eclipse, IntelliJIDEA. Biz kursumuzda belirli bir zaman (yaklaşık kursun yarısına kadar) Eclipse, sonrasında IntelliJIDEA
	kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	12.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	JDK'nın kurulumu için işletim sistemine göre aşağıdaki şu link'den ilgili "installer" indirilebilir: 
	https://www.oracle.com/tr/java/technologies/downloads/. Burada LTS olması açısından 17 seçilebilir. Ya da en son
	versiyon seçilebilir. Dersin tarihinde en son versiyon JDK 20 'dir. Kursumuzda Java 17 özellikleri de konular
	içerisinde ele alınacağından en az Java 17 kurulumu önerilir. Java 17 öncesinde en az Java 11 olmalıdır. Kurulum
	aşamasından sonra java ve javac programları -version seçeneği ile çalıştırılarak versiyon kontrolü yapılabilir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki programı çalıştırmak için JDK kurulu olan bir bilgisayarda aşağıdaki işlemlerin yapılması gerekir:
	1. Herhangi bir dizinde (directory/folder) csd isimli bir dizin açılır. Buradaki csd isminin tamamı küçük harf olacak
	şekilde yapılmalıdır.

	2. csd dizini içerisinde App.java isimli bir dosya açılır. Windows sisteminde uzantılar gizlenmişse görünür hale getirilip
	uzantının .java olduğuna dikkat ediniz. Buradaki dosya isminin de büyük küçük harf duyarlı olarak yazılması gerekir

	3. Komut yorumlayıcı program (command prompt or terminal) ile ilgili dizine geçilir. Dizin geçişleri için tüm sistemlerde
	aynı olan cd (change directory) komutu kullanılabilir. Örneğin: cd Dropbox/CSD/Kurslar/Java-Aug-2023/src/src-console

	4. Harhangi bir editör program ile App.java dosyasında aşağıdaki programı yazınız

	5. Komut yorumlayıcı programda, csd'nin bulunduğu dizinde aşağıdaki komutları çalıştırarak derleme işlemi yapılır:
		javac csd/App.java -> Windows dışı sistemler için
		javac csd\App.java -> Windows sistemi için
	Derleme işleminde herhangi bir hata (error) mesajı alınmazsa derleme işlemi başarılıdır ve App.class isminde byte code
	üretilir

	6. Komut yorumlayıcı programda aşağıdaki biçimde byte code çalıştırılır:
		java csd.App

	Anahtar Notlar: Yukarıdaki maddelerdek,i bazı zorunluluklar ilerideki konularda anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dil Kavramı: İletişimde kullanılan semboller topluluğudur. Bir dilin kurallarına "gramer" denir.  Gramerin pek çok
	bileşeni vardır. Bunlardan en önemlileri "sentaks (syntax) ve semantik (semaintic)" kavramlarıdır. Bir olgunun dil
	olabilmesi için en az sentaks ve semantiğesahip olması gerekir. Tersine sentaks ve semantiğe sahip olan bir olgu dildir. 

	Sentaks (sözdizim) doğru yazılmış ve doğru dizilmiş öğelere ilişkin kurallardır:
		"I am from Turkey"
	cümlesi sentaks olarak doğru yazılmıştır. Burada örneğin cümle "I from am Turkey" olarak yazılsaydı sentaks olarak
	hatalı olurdu. Java olarak bakarsak, örneğin
		System.out.println("Hello, World"); 
	cümlesinde noktalı virgül olmazsa sentaks hatası yapılmış olur. 

	Dildeki doğru yazılmış ve dizilmiş öğelerin ne anlam ifade ettiğine yönelik kurallara semantik kurallar denir. 

	Anahtar Notlar: Gramer'in daha çok doğal dillere özgü morfoloji gib başka bileşenleri de bulunur

	Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar sistemlerinde kullanılmak üzere tasarlanmış dillere bilgisayar 
	dilleri (computer languages) denir. Bir bilgisayar dilinde akış (flow) öğesi de varsa programlama dili (programming language)
	denir. Her programlama dili bir bilgisayar dilidir, her bilgisayar dili programlama dili değildir. Örneğin HTML, XML
	dilleri bilgisayar dilleridir ancak programlama dilleri değildir. Java'da bir akış olduğundan, programlama dilidir dolayısıyla
	bilgisayar dilidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Boşluk karakterleri (whitespace characters): Klavyeden basıldığında boşluk hissi veren karakterlerdir. Bu anlamda
	SPACE, ENTER ve TAB karakterleri klavyedeki tipik boşluk karakterleridir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atom (Token): Programlam dilinin parçalanamayan en küçük birimine denir. Burada parçalama terimi genel olarak boşluk
	karakterleri ile ayırma anlamında düşünülebilir. Java'da atomlar şunlardır:
	1. Anahtar Sözcükler (keywords/reserved words): Dile ait olan, herhangi bir şekilde tanıtılması gerekmeyen ve doğrudan
	değişken ismi olarak kullanılamayan atomlardır. Örneğin package, class, public, static, void.

	2. Değişkenler (variables/identifiers): İsmini programcının belirlediği ve isimlendirmesinde çeşitli kuralların bulunduğu
	atomlardır. Örneğin: csd, App, main, String, args, System, out, println.

	3. Sabitler (literals/constants): Program içerisinde doğrudan yazılan değerlere denir. Örneğin x = 10 ifadesinde 10 
	bir sabittir. 

	4. Operatörler (operators): Belirli işleme yol açan ve bu işlem sonucunda değer üreten atomlardır. 
	Örneğin, nokta (.), metot çağırma (()) operatörleri.

	5. String'ler (string literals/strings): İki tane iki tırnak (double quote) arasındaki yazılara tırnaklarıyla birlikte
	string denir. Örneğin, "Hello, World".

	6. Ayraçlar (delimiters/punctuators): Yukarıdakiler dışında kalan diğer atomlardır. Örneğin:;, {}, (), [].
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da kod yazma kuralları:
	1. Atomlar arasında istenildiği kadar boşluk(whitespace) bırakılabilir
	2. Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir. İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	
	Atomlar arasında istenildiği kadar boşluk bırakılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	






public static 









void main(String [






] args)
	{
		System.out





.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
	İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
packagecsd;class App{public static void main(String [] args){System.out.println("Hello, World");}} //error

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki iki kural aslında programcının okunabilir/algılanabilir (readable) kodlar yazabilmesini
	sağlar. Bu anlamda şirketlerin kendilerine özgü yazım stillerini içeren kuralları bulunabilir. Bu kurallara 
	İnglizce olarak "coding convention" ya da "code style guide" gibi terimler kullanılabilir. Buradaki yazım stilleri
	şirketten şirkete farklılıklar ya da benzerlikler içerebilir. Burada C ve Sistem Programcıları Derneği'nin 
	yazım stili ile yazılacaktır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da "derleme zamanı (compile time)" ve "çalışma zamanı (run time)" denilen iki önemli kavram vardır.
	Derleme zamanı, derleme sürecine ilişkin işlemlere denir. Çalışma zamanı ise, byte code'un çalıştırılması sürecine 
	ilişkin işlemlere denir. Bu kavramlar birbirleriyle ilişkili olsalar da, ayrı kavramlardır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	13.08.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Derleyicinin Teşhis Mesajları (Diagnostics):
	1. Gerçek hatalar (Errors): Dilin sentaks ya da semantik kurallarına uyulmamasından dolayı verilen mesajlardır. Bu durumda
	"byte code" üretilmez. Programcının bu hataları düzeltip kodu derlemesi gerekir.

	2. Uyarılar (Warnings): Byte code'un üretimine engel olmayan, olası programlama ve mantık hatalarının bildirilmesi
	için verilen mesajlardır. Programcı bu uyarıları kesinlikle dikkate almalıdır. Özel bir durum yoksa uyarı mesajlarının
	oluşumuna yol açan kodlar düzeltilmeldir. Bazı durumlarda derleyicinin uyarı mesajı vermediği ancak IDE'nin kullandığı
	bir "static kod analizi aracları" konfigürasyonları gereği uyarı verebilir. Bunlar da dikkate alınmalıdır. Ancak hepsinin
	düzeltilmesi gerekmez. Tipik olarak ürün elde edilmesi aşamasında derleyici anlamında hiç bir uyarı mesajının olmaması gerekir.

	3. Ölümcül hatalar (Fatal errors): Derleme işleminin bile tamamlanmasını engelleyen hatalardır. Bu durumda programcının
	yazdığı kod açısından yapacak birşeyi yoktur. Çünkü kod henüz derlenmemiş bile olabilir. Programcının ölümcül hataya 
	yol açan durumu ortadan kaldırması gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar
	ölümcül hatalara yol açar

	Programın çalışma zamanı sırasında oluşan hatalı durumlara genel olarak "exception" denir. Exception işlemleri
	ileride "exception handling" isimli bölümde ele alınacaktır. Bu konu ele alınana kadar exception oluştuğunda
	"program sonlanır" olarak anlaşılacaktır. Exception terimi yerine "run time error" da kullanılmaktadır. "error" dendiğinde
	"compile time error" anlaşılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Program içerisinde derleyicinin görmezden geleceği yazılara "yorum satırları (comment lines)" denir. Java'da iki
	çeşit yorum satırı kullanılmaktadır. Aşağıda örnekleri gösterilmiştir. İç içe yorum satırlarının kullanımında
	dikkatli olunmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

//App sınıfı
class App {
/*
	Burası da 
	derleyici tarafından dikkate alınmayacak
*/
	public static void main(String [] args) 
	{
		
		System.out.println("Hello, World"); //Burası derleyici tarafından dikkate alınmayacak
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programcı yorum satırlarını gereksiz yere ve karışık olarak yazmamalıdır. Gereksiz ve karışık olarak
	yazılmış yorum satırlarının da okunabilirliği/algılanabilirliği olumsuz etkileyebileceği unutulmamalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da birden fazla ".java" dosyası ile çalışmanın bir takım ayrıntıları vardır. Bu sebeple 
	paketler konusuna kadar yalnızca tek bir ".java" dosyası (App.java) ile çalışacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlama dili gibi formal olarak tasarlanmış kavramlar açıklanırken genel biçimlere ilişkin bir 
	takım yöntemler kullanılır. Özellikle bir takım standartlar BNF (Backus Neuer Form) notasyonu kullanırlar. 
	"Java Language Specification (JLS)" içerisinde de büyük ölçüde BNF kullanılmıiştır. BNF görece karmaşık bir yapıya 
	sahiptir. Özellikle başlangıç düzeyinde öğrenmek için kullanılması çok etkin bir yöntem değildir. Bu sebeple biz 
	kursumuzda BNF notasyonu kullanmayacağız. Biz açısal parantez köşeli parantez tekniğini kullanacağız. Bir genel 
	biçimde açısal parantez içerisine alınan bir bilgi zorunlu bir bilgi anlamına gelir, köşeli parantez içerisine 
	alınan bilgi ise seçenekli bir bilgi yani orada olmaya dabilir anlamına gelir. Şüphesiz olması ile olmaması aynı 
	anlamda olmak zorunda değildir. Açısal parantez veya köşeli parantez içerisine alınmamış her bilgi orda olması 
	gereken şeklinde anlamına gelir. Örneğin:
		package <paket ismi>;
	anlatımında package sözcüğü olması ve onu takip eden bir paket ismi bulunmalı anlamındadır. Ayrıca kodlar
	içerisinde //... biçimindeki gösterim de burada bir takım kodlar olabilir ancak şu durumda bizi ilgilendirmiyor
	anlamındadır. Ayrıca son 15 yıldır kaynaklarda (buna JSL de dahil) bir takım konular anlatılırken herhangi bir 
	senaryodan bağımsız olması anlamında isimlendirmede foo, bar, tar, car, zar gibi uydurma isimler kullanılmaktadır.
	Biz de konularımızda bu isimleri kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bildirim (declaration): Bir ismin derleyiciye tanıtılmasıdır. Yani derleyici bir ismin bildirimini arar 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı genel olarak paketlerden, paketler sınıflardan, sınıflar da metotlardan oluşur. Paket bildiriminin
	genel biçimi şu şekildedir:
		package <paket ismi>;
	Paket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Örneğin:
		package csd;
	Paket bildirimi tüm diğer bildirimlerden önce yani tipik olarak kaynak kodun tepesinde bulunmalıdır. Bu sebeple bir 
	".java" dosyasında yalnızca bir tane paket bildirimi bulunabilir. Paketler konusu ayrıntılı bir konudur. İleride detaylı 
	olarak ele alınacaktır. Sınıf bildiriminin genel biçimi şu şekildedir:
		[erişim belirleyici] class <sınıf ismi> {
			//...
		}
	Erişim belirleyici dışında başka sözcükler de olabilir. Erişim belirleyici ve diğerleri konular içerisinde ele
	alınacaktır. Sınıf ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Sınıflar konusu da
	oldukça detaylı bir konudur. Neredeyse her konuda sınıflarla ilgili detaylar ele alınacaktır. Örneğin:
		class Sample {
			//...
		}
		
		class Person {
			//...
		}
		
		class SerialPort {
			//...
		}
	Java'da alt programlara metot (method) denir. Bir metodun ne iş yapacağının yani kodlarının yazılmasına 
	metot bildirimi (method declaration), kodlarının çalıştırılmasına ise metot çağrısı (method call) denir. Java'da
	bir metot bir sınıf içerisinde bildirilmek zorundadır. Metot bildiriminin genel biçimi şu şekildedir:
	  [erişim belirleyici] [static] <geri dönüş değeri> <metot ismi>([parametre değişkenleri])
	  {
	  		//...
	  }
	Erişim belirleyici şunlardan biri olabilir: public, protected, no-modifier, private. Burada no-modifier hiç bir şey
	yazmamak anlamındadır. Bu erişim belirleyicilerin hepsi farklı anlamdadır. İlgili konuya gelene kadar bir tüm
	metotlardaki erişim belirleyicileri public yapacağız. Java'da bir metot static veya non-static olarak bildirilebilir.
	Bir metodun bildiriminde static anahtar sözcüğü yazılırsa metot static olur. İlgili konuya gelene kadar tüm metotlarımızı
	static olarak bildireceğiz. Metodun kodlarının yazıldığı bölüme metodun gövdesi (method body) denir. static bir metodu 
	çağırmanın genel biçimi şu şekildedir:
		[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);
	Bir metot genel olarak başka bir metot içerisinde çağrılabilir. Akış java programına verilen sınıfın main metodundan
	başlar. main metodu bittiğinde akış sonlanır. Bizim bu kursdaki programlarımızda bir tane akış olduğundan main metodu
	bittiğinde program sonlanır. main metodu JVM tarafından akışı başlatmak üzere çağrılır. Bu anlamda akışı başlatmak
	için çağrılan main metoduna "giriş noktası (entry point)" denir. Bir metot çağrıldığında akış metodun kodlarına 
	dallanır ve metodun kodları çalıştırıldıktan sonra akış çağrılan noktaya geri döner. Metodun geri dönüş değeri
	yoksa void anahtar sözcüğü yazılır. Metodun ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir.
	Metodun parametre değişkenleri olabilir. Metodun geri dönüş değeri ve parametre değişkenleri ileride ele
	alınacaktır. Yani aslında bir program main metodun çağrılmasıyla başlar ve bi rçok metodun çağrılması ile devam eder.
	print ve println'de birer metottur. Ancak bu metotlar static metot değildir. Bu sebeple System.out.print veya
	System.out.println çağrıları yukarıdaki biçimden farklıdır. Burada System bir sınıf, out bir referans, print ve prinln de
	birer metot ismidir. Detaylar şu an önemsizdir. Bu iki metot aldıkları yazıyı basarlar. println son yazdığı 
	karakterden sonra bir sonra satıra geçme karakterini de basar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		csd.Mample.tar();
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı pakette ise çağrı
	sırasında paket ismi yazılmayabilir. Çağıran metodun ait olduğu sınıf ile çağrılan metodun ait olduğu sınıf aynı ise
	paket ismi yazılmazsa sınıf ismi de yazılmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		Sample.foo();
		Sample.bar();
		Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		Mample.tar();		
	}
	
	public static void bar()
	{
		System.out.println("bar");
		foo();
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sayı sistemleri
	Biz 10'luk sistemi (decimal system) kullanmaktayız. 10'luk sistemde sayıları ifade etmek için 10 sembol vardır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9

	10'luk sistemde sayının her bir basamağı 10'nun kuvvetleriyle çarpılıp toplanmaktadır. Örneğin:

	123.25 = 3 * 10^0 + 2 * 10^1 + 1 * 10^2 + 2 * 10^-1 + 5 * 10^-2

	Halbuki bilgisayarlar 'lik sistemi (binary system) kullanmaktadır. 2'lik sistemde sayıları ifade etmek için 2 sembol kullanılmaktadır:

	0 
	1

	2'lik sistemde sayının her bir basamağına "bit (binary digit)" denilmektedir. 2'lik sistemde sayının her basamağı 2'nin kuvvetiyle çarpılarak sayı elde edilir.
	Bit en küçük bellek birimidir. 8 bite 1 byte denilmektedir. Genellikle bitler 4'erli gruplanarak yazılırlar. Örneğin:

	1010 0010

	Burada 1 byte'lık bir bilgi vardır. Byte temel bellek birimidir. 

	Byte da küçük bir birimdir. Kile diğer bilimlerde "1000 katı" anlamına gelmektedir. Ancak bilgisayarlar 2'lik sistemi kullandığj için 1000 katı iyi bir
	kat değildir. Bu nedenle genel olarak Kilo byte için 2'nin 102uncu kuvveti olan 1024 kat kullanılır. Yani 1KB (kısaca 1K) 1024 byte'tır. Mega diğer bilimlerde 
	kilonun 1000 katıdır. Dolayısıyla milyan kat anlamına gelmektedir. Ancak bilgisayar bilimlerinde genel olarak mega kilonun 1024 katı olarak alınır. 
	Bu durumda 1 MB = 1020 * 1024 (2^20) KB'dir. Giga ise meganın 1024 katıdır. Bu durumda 1 GB = 1024 * 1024 * 1024 byte'tır ( 2^30). Giga'dan sonra tera, tera'dan sonra 
	peta, ondan sonra da exa gelmektedir. 

	1 byte içerisinde yazılabilecek en küçük ve en büyük sayılar şöyledir:

	0000 0000 ---> 0
	1111 1111 ---> 255

	1 byte içerisinde 1 ve 0'ların bütün permütasyonları 256 tanedir. 2 byte içerisinde en büyük sayıyı yazacak olsak şöyle olurdu:

	1111 1111 1111 1111 ---> 65535

	Biz burada ikilik sistemde tamsayıları ifade ettik. Ama bütün sayıları pozitif kabul ettik. Pekiyi negatif tamsayılar nasıl ifade edilmektedir?

	Bugün negatif sayıların ifade edilmesi için "ikiye tümleyeb (two's complement)" sistemi denilen bir sistem kullanılmaktadır. Bu sistemde pozitif ve 
	negatif sayılar birbirlerinin ikiye tümleyenidirler. ikiye tümleyen bire tümleyene bir eklenerek bulunmaktadır. Bir sayının bire tümleyeni sayıdaki
	o'ların 1, 1'lerin 0 yapılmasıyla bulunur. Bu durumda ikiye tümleyen şöyle hesaplanır. örneğin aşağıdaki sayının ikiye tümleyenini bulmaya çalışalım:

	0101 0110

	Sayının bire tümleyenine bir ekleyeceğiz:

	1010 1001
    0000 0001
    ---------
    1010 1010

	Aslında ikiye tümleyeni bulmanın kolay bir yolu da vardır: Sayıda sağdan sola ilk 1 görene ilk 1 dahil olmak üzere aynısı yazılarak ilerlenir. 
	Sonra 0'lar 1, 1'ler 0 yapılarak devam edilir. Örneğin:

	0101 0110

	sayının ikiye tümleyenini tek hamlede bulalım:

	10101010

	Negatif sayıları ifade edebilmek için kullanılan ikiye tümleme sisteminde en soldaki bit işaret bitidir. Bu bit 0 ise sayı pozitif, 1 ise negatiftir.
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidir. Örneğin bu sistemde +10 yazmak isteyelim. Bunu işaret 0 yaparak yazabiliriz:

	0 000 1010		---> +10

	Şimdi -10 yazmak isteyelim. Bunun için +10'un ikiye tümleyenini alalım:

	1 111 0110       ---> -10

	Bu sistemde +n ile -n toplandığında 0 elde edilir:

	0 000 1010   ---> +10
	1 111 0110   ---> -10
	---------------------
  1	0 000 0000   ---> 0

  	Bu sistemde tek bir sıfır vardır. O da tüm bitleri 0 olan sıfırdır. Bu sistemde 1 byte içerisinde yazılabilecek en büyük pozitif sayı şöyledir:

	0 111 1111    ---> +127

	Şimdi bunun ikiye tümleyenini alalım:

	1 000 0001    ---> -127

	Pekiyi en küçük negatif sayı nedir? Bu sistemde bir tane sıfır olduğuna göre 255 tane permütasyon eşit bölünemez. Demek ki ya pozitif sayılar ya negatif sayılar 
	bir tane daha fazla olmak zorundadır. Bu sistemde ikiye tümleyeni olmayan iki sayı vardır:

	0000 0000 
	1000 0000

	Birincisi 0'dır. İkinci sayı -127'den bir eksik olan sayıdır. O halde bu sayının -128 kabul edilmesi daha uygundur. 

	Demek ki bu sistemde n byte içerisinde yazılabilecek en büyük pozitif sayı ilk biti 0 olan diğer tüm birleri 1 olan sayıdır. En küçük 
	negatif sayı ise ilk biti 1 olan diğer tüm bitleri 0 olan sayıdır. Örneğin bu sistemde iki byte ile yazabileceğimiz en büyük pozitif sayı
	şöyledir:

	0111 1111 1111 1111		---> +32767

	En küçük negatif sayı ise şöyledir:

	1000 0000 0000 000   	---> -32768

	Bu sisteme ilişkin tipik sorular ve yanıtları şöyledir:

	SORU: Bu sistemde +n sayısını nasıl yazarsınız?
	CEVAP: En soldaki bit 0 yapılıp n sayısı 2'lik sistemde yazılır.

	SORU: Bu sistemde -n nasıl yazarsınız?
	CEVAP: Yazabiliyorsanız doğrudan yazın. Ancak doğrudan yazamıyorsanız önce +n değerini yazın ve ikiye tümleyenini alın. Örneğin bu sistemde -1 
	yazalım. Önce +1 yazalım:

	0000 0001   ---> +1

	Şimdi bunun ikiye tümleyenini alalım:

	1111 1111   ----> -1

	SORU: Bu sistemde bir sayının kaç olduğu bize sorulsa bunu nasıl yanıtlarız?
	CEVAP: Eğer en soldaki bit 0 ise sayının değeri doğrudan hesplanır. Eğer en soldaki bit 1 ise bu sayının negatif olduğunu gösterir. Bu durumda 
	sayının ikiye tümleyeni alınır. Pozitifinden hareketle negatifi bulunur. Örneğin 1110 1110 sayısı kaçtır? Burada işaret biti 1 olduğuna göre sayı negatiftir. 
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidirler. O zaman bu sayının ikiye tümleyenini alıp pozitifinden faydalanarak sayıyı bulalım:

	0001 0010  ---> +18

	o zaman bize sorulan sayı -18'dir.

	Bu sistemde örneğin 1 byte içerisinde yazılabilecek en büyük pozitif sayıya 1 toplayalım:

	0111 1111   ---> +127
	1000 0000   ---> -128

	Demek ki bu sistemde bir sayıyı üst limitten taşırırsak yüksek bir negatif sayıyla karşılaırız. Benzer şekilde alt limitten taşırırsak yüksek bir 
	pozitif sayı ile karşılaşırız	 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Tamsayılar ikilik sistemde "işaretsiz (unsigned)" ya da "işaretli (signed)" sistemde yorumlanabilirler. İşaretsiz sistemde sayının en soldaki biti
	olarak yorumlanmaz. Sayı herzaman sıfır ya da pozitiftir. İşaretli sistemde ise sayının en solundaki bit işaret bitidir. Sayı ikiye tümleyen aritmetiğine 
	göre yorumlanır.
	 
	İşlemciler aslında genellikle işaretli ve işaretsiz ayırımını yapmazlar. Çünkü bu tür de aslında aynı biçimde işleme sokulmaktadır. Sonucun yorumu değişmektedir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi noktalı sayılar ikilik sistemde nasıl ifade edilmektedir? İşte insanlar noktalı sayıları ifade etmek için iki format geliştirmişlerdir. Bunlardan birine
	"sabit noktalı formatlar (fixed point formats)" diğerine "kayan noktalı formatlar (floating point formats)" denilmektedir. Sabit noktalı formatlar eski 
	devirlerde basit bir mantıkla tasarlanmıştır. Bu formatlar bugün hala kullanılıyor olsa da büyük ölçüde artık bunların çağı kapanmıştır. Bugün kayan noktalı
	format denilen formatlar kullanılmaktadır. 

	Sabit noktalı formatlarda noktalı sayı için n byte yer ayrılır. Noktanın yeri önceden bellidir. Örneğin sayı 4 byte ile ifade edilsin. 
	Noktanın yeri de tam ortada olsun. Bu durumda syının tam kısmı 2 byte ile noktalı kısmı 2 byte ile ifade edilir. Ancak sayının noktalı kısmı 2'nin
	negatif kuvvetleriyle kodlanmaktadır. VBöylece iki sabit noktalı sayıyı paralel toplayıcılarla kolay bir biçimde toplayabiliriz: Örneğin bu sistemde 
	5.25 ile 6.25 sayılarını ifade edip toplayalım:

	0000 0000 0000 0101 . 0100 0000 0000 0000    ---> 5.25
	0000 0000 0000 0110 . 0100 0000 0000 0000    ---> 6.25
	-------------------------------------------------------
	0000 0000 0000 1011 . 1000 0000 0000 0000    ---> 11.5

	Pekiyi bu yöntemin ne dezavantajı vardır? Yöntemin en önemli dezavantajı dinamik olmamasıdır. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sabit noktalı formatların dinamik olmaması nedeniyle kayan noktalşı formatlar geliştirilmiştir. Bu formatlarda noktanın yeri sabit değildir. 
	Noktanın yeri format içerisinde ayrıca tutulmaktadır. Noktalı sayının noktası yokmuş gibi ifade edilmesi durumunda sayının bu haline "mantis (mantissa)" 
	denilmektedir. İşte kayan formatlarda sayı için ayrılan alanın bir bölümünde manris bir bölümünde de "noktanın yeri" tutulmaktadır. Noktanın yerini belirleyen
	kısma "üstel kısım (exponential part)" denilmektedir. Tabii bir de sayının başında işaret biti bulunur. Bu durumda kayan noktalı bir sayının format aşağıdakine benzerdir:

	[işaret biti] [mantis] [noktanın yeri (exponential)]

	Bugün ağırlıklı kullanılan kayan noktalı format IEEE 754 denilen formattır. Bu formatın üç farklı genişlikte biçimi vardır:

	IEEE 754 - Short Real Format (4 byte)
	IEEE 754 - Long Real Format (8 byte)
	IEEE 754 - Extended Real Format (10 byte)
	
	Bugün Intel, ARM, MIPS, Alpha, Power PC gibi yaygın işlemciler donanımsal olarak bu formatı desteklemektedir. Aynı zamanda bu format yaygın olarak Reel Sayı Ünitesi
	olmayan mikrodenetleyicilerdeki derleyiciler tarafından da kullanılmaktadır.

	Kayan noktalı formatların (örneğin IEEE 754 formatının) en ilginç ve problemli tarafı "yuvarlama hatası (rounding error)" denilen durumdur. Yuvarlama hatası
	noktalı sayının tam olarak ifade edilemeyip onun yerine ona yakın bir sayının ifade edilmesiyle oluşan hatadır. Yuvarlama hatası sayıyı ilk kez depolarken de 
	oluşabilir, aritmetik işlemlerin sonucunda da oluşabilir. Tabii noktalı sayıların bir bölümü bu formatta hiçbir yuvarlama hatasına maruz kalmadan ifade edilebilmektedir. 
	Ancak bazı sayılarda bu hata oluşabilmektedir. Bu hatayı ortadan kaldırmanın yolu yoktur. Tabii sayı için daha fazla bir ayrılırsa yuvarlama hatasının etkisi de 
	azalacaktır. 

	Yuvarlama hatalarından dolayı programlama dillerinde iki noktalı sayının tam eşitliğinin karşılaştırılması anlamlı değildir. Örneğin aşağıdaki işlemde
	yuvarlama hatasından dolayı sayılar sanki eşit değişmiş gibi ele alınacaktır.  

	0.2 + 0.1 == 0.3 (false)
	
	Pekiyi yuvarlama hatasının önemli olduüu ve bunun istenmediği tarzda uygulamalarda (örneğin finansal uygulamalarda, bilimsel birtakım uygulamalarda)
	ne yapak gerekir? İşte bunun tek yolu noktalı sayıları kayan noktalı formatta tutmamak olabilir. Bazı programlama dillerinde noktalı sayıyı 
	kayan noktalı formatta tutmayan böylece yuvarlama hatalarına maruz bırkmayan özel türler (örneğin C#'taki decimal) vardır. Ancak bu türler işlemciler tarafından 
	desteklenmediği için yapay türlerdir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Yazılar da aslında bilgisayar belleğinde 2'lik sistemde sayılar biçiminde tutulmaktadır. Bir yazıyı oluşturan elemanlara "karakter" denilmektedir. İşte
	bir yazıda her bir karakter 2'lik sistemde bir sayı ile ifade edilir. Böylece yazı aslında ikilik sistemde bir sayı dizisi gibi tutulmaktadır. İşte
	bir karakter için hangi sayının karşı geldiğini belirten tablolara "karakter tabloları" denilmektedir. Karakter tablosundaki karakter şekillerine "glyph"
	denilmektedir. Her karaktere tabloda bir sıra numarası verilmiştir. Buna da "code point" denilmektedir. Dünyanın ilk standart karakter tablosu "ASCII (American
	Standard Code Information Interchange)" denilen tablodur. ASCII tablosu aslında 7 bit bir tablodur. Dolayısıyla tabloda 128 tane glyph için code point
	bulundurulmuştur. ASCII dışında IBM EBCDIC tablosunu geliştirmiştir. Wang firması WISCII tablosunu kullanmıştır. ASCII tablosu Amerikalılar tarafından yalnızca İngilizce
	karakterleri ifade etmek için oluşturulmuştur. Bilgisayarlar yaygınlaşmaya başladığında farklı karakterlere sahip olan Türkiye gibi, Yunanistan gibi, Almanya gibi
	ülkeler bu ASCII tablosunu 8 bite çıkartıp elde edilen 128'lik yeni alanı kendi karakterlerini ifade etmek için kullanmışlardır. ASCII tablosunun ilk yarısı 
	(yani [0, 128] numaraları karakterleri) standarttır. Ancak ikinci yarısı "code page" adı altında farklı ülkeler tarafından farklı yerleşimler yapılarak kullanılmaktadır. 
	DOS zamanlarında Türkçe karakterler için OEM 857 denilen code page kullanılıyordu. Daha sonra Microsoft Windows sistemlerinde Türkçe karakterler için 1254 code page'i
	düzenledi. ISO, bu code page'leri standart hale getirmiştir. Bugün Türkçe karakterler ISO tarafından ASCII 8859-9 Code page'i ile düzenlenmiştir.

	ASCII tablosu ve onların code page'leri uzun süre kullanılmış ve hala kullanılmakta olsa da maalesef karışıklıklara yol açmaktadır. İşte son 20 yıldır
	artık karakterleri 2 byte içerisinde ifade ederek dünyanın bütün dillerinin ve ortak sembollerinin tek bir tabloya yerleştirilmesi ile ismine UNICODE 
	denilen bir tablo oluşturulmuştur (www-unicode.org). UNICODE tablo ISO tarafından 10646 ismiyle de bazı farklılıklarla standardize edilmiştir. UNICODE tablonun
	ilk 128 karakteri standart ASCII karakterleri, ikinci 128 karakteri ISO 8859-9 code page'indeki karakterlerdir. 

	Bir karakter tablosundaki code point'lerin ikilik sistemde ifade edilme biçimine "encoding" denilmektedir. ASCII code page'lerinde encoding doğrudan 
	code point'in 1 byte'lık sayı karşılığıdır. Ancak UNICODE tablonun değişik encoding'leri kullanılmaktadır. UNICODE tablonun klasik encoding'i UTF-16'dır. 
	Burada code point doğrudan 16 bir bir sayı biçiminde ifade edilir. UTF-32 encoding'inde ise code point 32 bitlik bir sayı biçiminde ifade edilmektedir. 
	Ancak UNICODE tablonun en yaygın kullanılan encoding'i UTF-8 encoding'idir. UTF-8 kodlamasında standart ASCII karakterler 1 byte ile, diğer karakterler 
	2 byte, 3 byte, 4 byte ve 5 byte kodlanabilmekedir. Türkçe karakterler UTF-8 encoding'inde 2 byte yer kaplamaktadr. UTF-8 encoding'i UNICODE bir yazının 
	adeta sıkıştırılmış bir hali gibi düşünülebilir. 

	Bugün pek çok programlama editörleri default durumda dosyayı UNICODE UTF-8 encoding'ine göre saklamaktadır.
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Bilgisayar dünyasında çok kullanılan diğer bir sayı sistemi de 16'lık sistemdir. 16'lık sisteme İngilizce "hexadecimal system" denilmektedir. 16'lık 
	sistemde syaıları ifade etmek için 16 sembol bulunmaktadır. İlk 10 sembol 10'luk sistemdeki sembollerden alınmıştır. Sonraki 6 sembol alfabetik karakterlerden alınmıştır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9
	A
	B
	C
	D
	E
	F

	16'lık sistemdeki her bir basamağa "hex digit" denilmektedir. Örneğin:

	1FC8

	Burada 4 hex digit'lik bir sayı vardır. 16'lık sistemdeki bir sayıyı 10'luk sisteme dönüştürmek için her hex digit 16'lık kuvvetleriyle çarpılıp toplanır. 
	Ancak 16'lık sistemdeki sayı kullanım gereği bakımından aslında 10'lu sisteme pek dönüştürülmez. 16'lık sistemdeki her bir hex digit 4 bit ile ifade edilebilmektedir:

	0		0000
	1		0001
	2		0010
	3		0011
	4		0100
	5		0101
	6		0110
	7		0111
	8		1000
	9		1001
	A		1010
	B 		1011
	C 		1100
	D 		1101
	E 		1110
	F       1111

	16'lık sistemden 2'lik sisteme dönüştürme yapmak çok kolaydır. Tek yapılacak şey bir hex digit'e karşılık yandaki tablodaki 4 biti getirmektir. Örneğin:

	1FC9  =  0001 1111 1100 1001
	FA3D  =  1111 1010 0011 1101

	2'lik sistemdeki bir sayı da 16'lık sisteme çok kolay dönüştürülür. Tek yapılacak şey sayıyı dörderli gruplayıp ona karşı gelen hex digit'i yazmaktır. Örneğin:

	1010 0001 1110 1000 0011 0101 = A1E835

	Bilgisayar dünyasında 162lık sistem aslında 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Yani 2'lik sistem çok yer kapladığı için kişiler
	2'lik sistem yerine 16'lık sistemi kullanırlar. Bu nedenle belleği, dosyayı gösteren programlar bunları 2'lik sistem yerine 16'lık sistemde gösterirler. 

	1 byte 2 hex digit ile ifade edilmektedir. Örneğin:

	1A 23 5C 78

	Burada 4 byte'lık bir bilgi vardır. Örneğin 2 byte içerisinde yazılabilecek en küçük negatif işaretli sayının hex karşılığı 8000 biçimindedir. Örneğin
	bir byte'lık işaretli sistemde yazılabilecek en büyük pozitif sayı 7F biçimindedir. İşareti tamsayı sisteminde 4 byte içerisinde -1 sayısı FFFFFFFF 
	biçimindedir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Eskiden daha fazla kullanılıyor olsa da toplamda oldukça seyrek kullanılan diğer bir sayı sistemi de 8'lik sayı sistemidir. Bu sisteme İngilizce 
	"octal system" denilmektedir. 8'lik sayı sistemindeki her bir basamağa "octal digit" denir. Octal digit sembolleri olarak 10'luk sistemin ilk 8 sembolü 
	kullanılmaktadır:

	0
	1
	2
	3
	4
	5
	6
	7

	Her octal digit 3 bir ile ifade edilebilir:

	0	000
	1	001
	2	010
	3	011
	4	100
	5	101
	6	110
	7	111

	Bu durumda bir octal sayı 2'lik sisteme kolay bir biçimde dönüştürülebilir:

	476		100 111 110
	741		111	100	001

	Benzer biçimde 2'lik sistemdeki bir sayı da sağdan sola üçer bir gruplandırılarak 8'lik sisteme dönüştürülebilmektedir. Örneğin:

	1011 1011	=  273
	0111 1110	=  176

	8'lik sistem de 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Ancak 8'i tam ortalayamadığı için kullanımı seyrektir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Tür (type): Bir değişkenin içerisindeki değerin hangi formatta tutulduğunu ve bellekte ne kadar uzunlukta (byte) yer
	ayrılacağını belirtir. Java'da türler temel türler (primitive/built-in/predefined types) ve programcının tanımladığı
	türler (user defined types) olmak üzere iki gruba ayrılabilir. Programcının tanımladığı türler ileride ele alınacaktır.
	Temel türler birer anahtar sözcük olarak temsil edilmektedir. Java'nın tamel türleri şunlardır:
	
	Temel Tür				Uzunluğu (byte)
	short						2
	int							4
	long						8
	byte						1
	
	float						4
	double						8
	
	char						2
	boolean						-
	
	Temel türlere ilişkin özellikler:
	- Temel türler genel olarak tamsayı türleri (integer/integral types), gerçek sayı türleri (real types) ve özel amaçlı
	türler olarak ayrılabilir. 
	
	- Tamsayı türlerinde işaretli (signed) sistemde, 2'ye yöntemi kullanılır.
	
	- Gerçek sayı türleri IEEE 754 formatına göre çalışırlar. Bu formatta yuvarlama hataları (rounding error) oluşabilir. 
	double türü "çift hassasiyetli (double precision)", float türü ise "tek hassasiyetli (single precision)" olarak çalışırlar.
	Bu kavramlar IEEE 754 standardına ilişkindir. Burada bilinmesi gereken yuvarlama hatalarının oluşabileceği ve double
	türünün, float türüne göre daha az yuvarlanacağıdır. Yani float türünün yuvarlamaya karşı direnci, double türüne göre daha
	zayıftır. Yuvarlama hataları, bir işlemin sonucunda oluşabileceği gibi bir değer yerleştirilirken de olabilir.
	
	- Gerçek sayılardaki yuvarlama hatası, IEEE 754 standardının yöntemidir. Hatalı bir çalışma değildir. Programcı 
	bu yuvarlama hatalarının problem oluşturabileceği (örneğin parasal ve finansal uygulamalar) uygulamalarda bu türleri
	kullanmaz. Böyle bir durumda hangi türün kullanılacağı ileride ele alınacaktır. Böylesi bir durum dışında yani yuvarlama
	hatalarının öneminin olmadığı uygulamalarda bu türler kullanılır. Çünkü, yuvarlama hatası yapılmamasını sağlayan
	yöntemlerde yüzlerce makine komutunun kullanıldığı yerde, IEEE 754 ile bu tek bir makine komutuyla yapılabilir.
	
	- char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türden 
	bir değişken içerisinde tutulan sayı UNICODE tabloda bir sıra numarası anlamına gelir. Dolayısıyla mantıksal olarak
	char türü içerisinde bir karakter tutulmuş olur.
	
	- boolean türünün alabileceği 2 tane değer vardır: true, false. boolean türünün uzunluğu JLS'de belirtilmemiştir.
	Sistemden sisteme değişebilir. Ancak bunu bir önemi yoktur.
	
	Anahtar Notlar: Java'da boolean türü dışında kalan temel türlerin uzunlukları her sistemde aynıdır.
	
	Anahtar Notlar: int türüne "integer" demek yanlış bir tanım kullanmak demektir. integer kavramı tam sayılara verilen
	genel bir isimdir. int ise 4 byte'lık bir tamsayı türüdür. Ayrıca JavaSE'de Integer isimli önemli bir sınıf da 
	bulunmaktadır
	
	Anahtar Notlar: Java'da en çok kullanılan tamsayı türü int'dir, en çok kullanılan gerçek sayı türü de double'dır. 
	Programcı öncelikle bu türleri düşünmeli. Bu türler gereksinimi karşılamıyorsa (ki karşılamadığı da bir çok senaryo
	mevcuttur) diğer türleri düşünmelidir. Bu anlamda int ve double türüne "default types" da denilmektedir	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatasını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);		
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatalarını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	20.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir değişken kullanılmadan önce bildirilmelidir. Değişken bildiriminin genel biçimi şu şekildedir:
		<tür> <ismi>;
	Örnek:
		int a;
		double b;
		
	Java'da 3 çeşit değişken vardır:
	1. Yerel değişken (local variable)
	2. Parametre değişkeni (parameter variable)
	3. Sınıf veri elemanı (class member variable)
	
	Değişkene ait için temel kavramlar:
	Tür (type): Bellekte ne kadar ayrılacağını ve o alanda bilginin hangi formatta tutulacağını belirtir.
	
	İsim (name): Belirli kurallara göre yazılabilen karakter topluluğudur.
	
	Faaliyet Alanı (scope): Değişken isminin görülebildiği (bilindiği) kod aralığıdır. Derleme zamanına ilişkin
	bir bilgidir.
	
	Ömür (storage duration): Bir değişkenin bellekte yaratılması ile yok edilmesi arasındaki süredir. Çalışma zamanına
	ilişkin bir bilgidir. İleride ele alınacaktır
	
	Anahtar Notlar: Değişken (variable) terimi değişken atomlar için de kullanılmaktadır. Burada değişken bellekte
	yer ayrılan ve içerisinde değer tutabilen atomlardır. Yani burada ele alından değişken de bir değişken atomdur. Ancak
	her değişken atom burada ele alınan değişken değildir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun içerisinde { ile } arasında kalan bölgeye bu küme parantezleri ile birlikte blok (block) denir. Aslında 
	metodun gövdesi de bir bloktur. Metot içerisinde istenildiği kadar içiçe veya ayrık bloklar olabilir. Bu anlamda örneğin
	sınıf bildirimindeki {}'leri blok değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...
			{
				//...
			}
		}
		
		{
			//...
			{
				//...
				{
					//...
				}
			}
		}
	}
}

class Sample {
	public static void foo() 
	{
		{
			//...			
		}
		
		{
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		int a;
		double b;
		
		{
			boolean flag;
			//...
		}
	}
}

class Sample {
	public static void foo() 
	{
		int x;
		double y;
		
		{
			float z;
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yerel bir değişkenin faaliyet alanı (scope), bildirildiği yerden bildirildiği bloğun sonuna kadardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		{
			a = 10;
			int x;
			
			x = 10;
		}
		
		x = 20; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		boolean a; //error
		
		{			
			float a; //error			
			
		}		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
						
		}	
		
		{
			int a;
			
			a = 20;
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
		}
		
		int a;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir. Aşağıdaki örnekte her iki metotta da
	count isimde yerel değişken bildirimi olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int count;
		
		//...		
	}
	
	
	public static void bar()
	{
		int count;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aslında ekrana basmak ve klavyeden okuma kavramları JLS'de doğrudan bu şekilde belirtilmemiştir.
	print ve println metotları aslında "standard output (stdout)" denilen bir dosyaya yazma yaparlar. Bu anlamda klavyeden 
	bilgi okuyan metotlar da "standard input (stdin)" denilen bir dosyadan okuma yaparlar. Ancak, bu dosyalar çeşitli
	sistemlerde belli aygıtlara yönlendirilmiştir. Örneğin klasik masaüstü işletim sistemlerinde tipik olarak stdout ekrana,
	stdin de klavyeye yönlendirilmiştir. Biz kursumuzda ekran ve kalvye terimlerini kullanacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	print ve println metotları bir değişkenin değerini ekrana yazabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		a = 10;
		
		System.out.println(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir değişkene bildirim noktasında değer verilmesine "ilkdeğer verme (initialization)" denir. Bir değişkene bildirildikten
	sonra yapılan atama işlemi teknik olarak "initialization" ile aynı anlamda değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10; //initialization
		int b;
		
		b = 20; //assignment
		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamda, çeşitli sebeplerden dolayı artık kullanılması önerilmeyen durumlarda "deprecated"
	terimi kullanılır. Deprecated olmanın bir çok sebebi olabilir. Bu, neyin deprecated olduğu ile ilgilidir. Deprecated
	olan durumlar gerelçeleri ve yerine kullanılacakları ile birlikte dokümante edilir. Deprecated durumlarda derleyici
	uyarı mesajı verir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirme kuralları:
	Bu kurallar Java'da tüm değişken atomlar için geçerlidir.
	
	- Değişken isimleri sayısal bir karakter ile başlatılamaz. Uygun bir karakter ile başlatılıp istenildiği kadar 
	sayısal karakter kullanılabilir.
	
	- Değişken ismi alfabetik bir karakter ile başlatılabilir.
	
	- Değişken isminde _ karakteri kullanılabilir. Hatta değişken ismi _ karakteri ile başlatılabilir.
	
	- Java 8 ile birlikte _ karakterinin tek başına kullanılması deprecated olmuştur. Java 9 ile birlikte de artık 
	geçersiz duruma gelmiştir.
	
	- Anahtar sözcükler tek başına değişken ismi olarak kullanılamaz. Java'ya daha sonra eklenen ancak kullanımına göre
	anahtar sözcük gibi işlem gören bazı özel atomlar vardır. Bunlar doğrudan değişken ismi olarak kullanılabilirler. Bu
	tarz atomlara programlamada "contextual keyword" de denilmektedir.
	
	- Değişken isimlerinde whitespace karakterler kullanılamaz.
	
	- Değişken isimlendirmede UNICODE karakterler kullanılabilir. Örneğin, Türkçe karakterler geçerlidir. Her ne kadar 
	kullanılabiliyor olsa da, değişken isimlendirmede İngilizce alfabedeki karakter dışında karakter kullanmayacağız. Hatta
	değişken isimlerinde geçen kelimeleri de İngilizce dışında kelimeler olarak kullanmayacağız.
	
	- Değişken isimlendirmede $ karakteri kullanılabilir. Dolar karakteri tek başına kullanılabilir, değişken ismi $
	karakteri ile başlatılabilir. Ancak programcı hiç bir zaman değişken isimlendirmede $ karakterini kullanmamalıdır.
	Derleyici bazı durumlarda bir takım isimler vermek zorunda kalabilir. İşte $ karakteri bu tip durumlarda isim çakışmasını
	engellemek için düşünülmüştür. Programcı bu karakteri kullanmazsa, derleyici de ürettiği isimlerde bu karakteri için
	herhangi bir isim çakışması oluşmaz.
	
	- Değişken isimleri büyük-küçük harf duyarlıdır (case sensitive). Aslında Java case sensitive bir dildir.
	
	- JLS'de değişken isimlerinin uzunluğu (karakter sayısı) konusunda bir üst sınır belirtilmemiştir. Ancak pratikte
	kullanılan uzunluklar açısından bir problem yoktur. 
	
	- Değişken isimlerinde bazı teknikler kullanılabilir. Zaman içerisinde bu teknikler anlatılacak ve hangi durumlarda
	hangisinin kullanıldığı anlaşılacaktır. Örneğin programcı Java'da sınıf isimlerini büyük harf ile başlatır, birden 
	fazla kelimeden oluşuyorsa tüm kelimeler bitişik,  tüm kelimelerin baş harfleri büyük ve geri kalan karakterler
	küçük olacak şekilde isimlendirme yapılır. Bu stile "upper camel case veya pascal case" denilmektedir.
	
	- Değişken isimleri kolay telaffuz edilebilir, yeterince uzunlukta ve anlamlı olmalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da klavyeden (aslında stdin'den değil mi?) değer okumak için pek çok yöntem bulunmaktadır. Burada kullanacağımız
	yöntemde bazı ayrıntılar ileride anlaşılacaktır. Bu sebeple şu an bazı detaylar göz ardı edilmelidir. Bir kalıp
	biçiminde düşünülebilir. Ayrıca bu kalıpta bazı uyarı mesajları oluşabilir. Bunlar da şu aşamada önemsizdir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
				
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
				
		double total;
		
		total = a + b;
		
		System.out.println(total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();		
		double total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: double ve float türleri için klavyeden girişleride nokta veya virgül kullanımı sistemden sisteme ve 
	kullanılan kalıba göre değişiklik gösterebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());
				
		long total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		long a = kb.nextLong();
		long b = kb.nextLong();		
		long total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir geçerli dizilimdir. Değişkenler
	ve sabitler tek başına ifade olabilirken, operatörler tek başına ifade olamazlar. Her ifadenin bir değeri vardır. İfade
	hesaplandığında elde edilir. Bu durumun tek bir istisnası vardır. İleride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisi yerine bir tür ismi yazıldığında o metot o türe geri dönmüş olur. Bir metodun 
	geri dönüş değeri varsa çağrılan noktaya bir değer ile geri döner. Bu değer bir işleme sokulabilir. Bir metodun
	geri dönüş değeri return deyimi ile oluşturulur. return deyiminin genel biçimi şu şekildedir:
	
		return [ifade];
		
	return deyimi nasıl kullanılırsa kullanılsın temel görevi metodu sonlandırmaktır. Yani akış return deyimine geldiğinde
	metot sonlanır. Eğer return ifade ile kullanılırsa (ki geri dönüş değeri olan metotlarda bu zorunludur) ifadenin değerine
	geri döner
	
	Anahtar Notlar: ** ile belirtilen kodda önce add metodu çağrılır. Bu durum operatör önceliği (operator precedence)
	konusu ile ilgilidir. İleride detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		int total = a + b;
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Akış return deyimine geldiğinde önce return deyimine ilişkin ifade hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2;
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda return tek başına kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		if (a > b)
			return a + b;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java derleyicisi akışın herhangi bir noktaya kesinlikle gelemeyeceğini anladığında genel olarak 
	error oluşturur. Bu tip kod parçalarına "unreachable codes" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
		System.out.println("Unreachable code"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	26.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri geçici değişken (temporary variable) yaratılarak iletilir. Geçici değişken, metodun geri dönüş 
	değerinin türündendir. Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodunun geri dönüş değerinin iletimi 
	ve işleme sokuluşuna ilişkin yaklaşık kodlar şu şekildedir:
		int temp = a + b;
		
		result = temp * 2;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar, geri dönüş değeri yokmuş gibi çağrılabilir. Yani geri dönüş değeri bir işleme sokulmayabilir.
	Şüphesiz metodun da buna uygun olarak yazılmış olması gerekir. Aşağıdaki add metodu toplam değerini ekrana basmasaydı
	örnekteki çağrının bir anlamı olur muydu?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;
		
		System.out.println(result);
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri, başka bir metodun geri dönüş olabilir. Bu durum aslında şu kuralın bir sonucudur:
	akış return deyimine geldiğinde, return deyimine ilişkin ifade önce hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int total = Sample.getTotal();
		
		System.out.println(total);
	}
}

class Sample {
	public static int getTotal()
	{
		System.out.println("getTotal");
		
		return NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;		
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş olmayan metotların, geri dönüş değeri bilgisi void anahtar ile yazılır. Geri dönüş değeri bilgisi yerine
	hiç bir şey yazılmaması error oluşturur. Geri dönüş değeri olmayan metotlarda return deyimi zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		System.out.println(result);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Geri dönüş değeri olmayan metotlara "void metot (void method)" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına (yani ifade olmadan) kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return;
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyiminin ifade ile kullanımı error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return a + b; //error
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlar geri dönüş değeri varmış gibi çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result = NumberUtil.printAdd() * 2; //error
		
		//...
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;		
		
		//...
		
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Anımsanacağı gibi her ifadenin bir türü vardır. Yani her ifade hesaplandıktan sonra bir değer
	üretir. Ancak void bir ifadenin (void expression) değeri olmaz. void ifade, void metot çağrısına ilişkin ifadedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metoların parametre değişkenleri: Metot bildiriminde parantezler arasında bildirilen değişkenlere denir. Metot 
	parametre değişkenlerinin faaliyet alanı (scope) metot boyuncadır. Bu anlamda faaliyet alanı bakımından metodun 
	başında bildirilmiş yerel değişkenler gibidir. Metot çağrısında, metodun parametrelerine geçilen ifadelere 
	argüman (argument) denir. Bir metodun kaç tane parametresi varsa o kadar sayıda argüman ile çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		Sample.foo(a, b);
	}
}


class Sample {	
	public static void foo(int a, double b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Parametre değişkenleri aynı türden bile olsa bildirimde tür yazılmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {	
	public static void foo(int a, b) //error
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metoda geçilen argümanlara ilişkin ifadeler önce hesaplanır, elde edilen değerler ilgili parametre değişkenlerine
	aktarılarak metot çağrılır. Yani aslında aşağıdaki örnekte foo metoduna argüman olarak geçilen değerler ilgili ifadelerin
	değerleridir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		Sample.foo(a + 1, b * 3);		
	}
}


class Sample {	
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte add metodunun geri dönüş değeri println metoduna argüman olarak geçilmiştir. Bu da aslında bir önceki
	kuralın bir sonucudur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a + 2, b * 3));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki gibi ifadelerin yazımında okunabilirlik/algılanabilirlik olumsuz yönde etkileniyorsa,
	compact yazım tercih edilmemelidir. Ya da başka bir deyişle compact ifadeler okunabilir/algılanabilir olması 
	durumunda yazılmalıdır. 	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile *** arasındaki kodlarda a ve b değişkenlerinin değerleri değişmediğinden add metodu iki
	defa gereksiz yere çağrılmıştır. Çünkü her iki durumda da aynı sonuç elde edilecektir. Bu durumda metodun gereksiz
	yere çağrılması maliyeti dışında, kodun okunabilirliği açısından da olumsuz bir durum söz konusudur. Çünkü bu kodu 
	okuyan kişi, add çağrısını iki kere gördüğünde ** ve *** arasındaki kodlarda a ve/veya b değişkenlerinin değerlerinin
	değiştiğini algılar.  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo aşağıdaki gibi daha okunabilir/algılanabilir ve görece daha az maliyetli olarak yazılabilir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		int result = NumberUtil.add(a, b);
		
		System.out.println(result); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(result); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodu yeni a değeri için de çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();	
		
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... 
		
		a = a * 2;
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun parametre değişkenleri aslında o metodun girdileridi (input). Bu anlamda metot parametre
	değişkenleri ile aldığı girdilerin nasıl elde edildiğinden bağımsız çalışır. Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
		
	ve
		public static int add()
		{
			java.util.Scanner kb = new java.util.Scanner(System.in);
			System.out.println("İki sayı giriniz:");
			int a = kb.nextInt();
			int b = kb.nextInt();
			int result = a + b;		
			
			return result;
		}
	metotları için parametreli add metodu toplayacağı değerlerin nereden geldiğini ve nasıl elde edildiğini bilmez.
	parametresiz add metodu ise değerleri klavyeden elde eder. Bu anlamda parametreli add metodu daha genel yazılmıştır. 
	Bir metodun geri dönüş değeri de o metodun çıktısıdır (output). Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
	ve
		public static void printTotal(int a, int b)
		{
			System.out.println(a + b);
		} 
		
	metotları için add metodu elde edilen değeri çıktı olarak verdiğinden toplam değerinin kullanılması anlamında genel
	yazılmıştır. Buradaki örnekler karşılaştırma amaçlı yazılmıştır. Bir metot diğerinden daha iyidir anlamı çıkartılmamalıdır.
	Hangisinin gerekeceği yazılan uygulamaya göre şüphesiz değişebilir.
	
	Anahtar Notlar: Bir metodun geri dönüş değeri olması ya da olmaması ve parametre değişkeni olması ya da olmaması
	birbiriyle doğrundan doğrudan ilişkili değildir. Şüphesiz dolaylı bir ilişki vardır. Bu anlamda geri dönüş değeri ve 
	parametre değişkenleri anlamında bir metot aşağıdakilerden biri biçiminde olabilir:
		1. Geri dönüş değeri var, parametre veya parametreleri var
		2. Geri dönüş değeri var, parametresi yok
		3. Geri dönüş değeri yok, parametre veya parametreleri var
		4. Geri dönüş değeri yok, parametresi yok	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da atama işlemi 3 yerde yapılır:
	- Atama operatörü (işlemli atama operatörleri dahil) ile. Initialization işlemi de bu gruba sokulabilir.
	- Bir metodun geri dönüş değerinin geçici değişkene aktarılması
	- Metot çağrısında, argümanların parametre değişkenlerine aktarılması
	
	İstisna bazı durumlar dışında atama operatörü ile ilgili kuralların hepsi, diğer iki atama için de geçerlidir. İstisna
	durumlar konular içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	27.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Neden metot yazalım? Yani, programcının uygulamayı geliştirirken çeşitli metotları yazması ne gibi bir avatajlar 
	sağlar? Aslında bu sorulara tek bir cümle ile cevap verilemez. Bu avantajlar genel olarak şu şekilde belirtilebilir: 
	- Bir metodun yaptığı işin detayları yani kabaca nasıl yaptığı, çağıran tarafından bilinmek zorunda değildir. Bu anlamda
	metot aslında, metodu çağrıdan programcıdan detayları gizlemiş olur.
	
	- Bir metodun yaptığı iş başka konuları da bilmeyi gerektirebilir. Ancak kullanan açısından bu durum önemsiz olabilir. 
	Örneğin bir sayının asal olup olmadığının anlaşılması konusu, asal sayı üretirken kullanılır ancak birbirlerinden 
	algoritmik olarak bağımsızdır. Bu durumda asal sayı üreten bir programcı, elinde sayının asal olup olmadığını test 
	etmek için kullanılan bir metodu çağırarak, sayının asal olup olmadığının nasıl anlaşılacağından bağımsız kod yazabilir.
	
	- Metot çağrılması okunabilirliği/algılanabilirliği artırır
	
	- Bir algoritma akış içerisinde bir çok yerde yazılmak isteneblir. Örneğin, bir sayının faktoriyel değerini bulan
	bir kod akış içerisinde bir çok yerde gerekebilir. Programcı bu kodu gereken her yerde yazarsa bu durumda hata yapma
	olasılığı artar. Aynı zamanda kodunda bir hata yaptığını farkederse veya kodda değişiklik yapmak isterse bunu yazdığı
	her yerde yapmak zorunda kalır. Bu da görece karmaşık bir hale getirebilir. İşte bu durumda programcı bir metot yazar
	ve gereken her yerde o metodu çağırırsa hata yapma olasılığı azalır, hata yaptığını anladığında veya bir değişiklik 
	gerektiğinde sadece metotta bu değişiklik yapılır. Bu da daha kolay ve çabuk bir biçimde yapılmasını sağlar. 
	
	- Uzun bir kodu bir çok yerde yazmak byte code'u büyütebilir. Ancak metot yazılıp çağrıldığında bu durum oluşmaz
	
	- Bir kodu metot olarak yazmak, o koda ilişkin test işlemlerini yaparak olası programlama hatalarının daha kolay
	belirlenebilmesini ve dolayısıyla daha kolay düzeltilmesini sağlar
	
	Anahtar Notlar: Buradaki maddelerinin hiç birisi birbirinden daha az önemli değildir.
	
	Anahtar Notlar: Programlamada en temel prensip kod tekrarından mümkün olduğunca kaçınmaktır. Yani, aynı işi yapan bir 
	kodu tekrar yazmak ZORUNLU OLMADIKÇA iyi bir teknik değildir. Bu kavrama programlamada "DO NOT REPEAT YOURSELF (DRY)" de 
	denilmektedir. İşte bu tekrarlamanın en yalın yöntemi metot yazmaktır ve çağırmaktır. Ayrıca ileride Nesne Yönelimli
	Programlama tekniğine ilişkin kavramlarla birlikte DRY çok daha etkin bir biçimde yapılabilmektedir.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu formatlı yazdırmak için kullanılan çok temel bir metottur. Bu metodun birinci parametresine
	argüman olarak bir yazı (bir String literal olabilir) geçilmelidir. Bu metot değişken sayıda argüman ile (vararg) 
	çağrılabilen bir metottur. Bu metodun diğer parametrelerinde herhangi bir türden argüman geçilebilir. Birinci parametre
	geçilen argümana ilişkin yazıda % karakteri ile birlikte özel bazı karakterler (format characters/specifiers) 
	yer tutucu (placeholder) olarak kullanılır. Örneğin n format karakteri imleci bir sonraki satırın başına geçirir. Bu 
	metot ileride göreceğimiz bazı metotlarla da aynı sistematik ile çalışır. printf metodunda format karakterlerin yer 
	tutucu dışında anlamı vardır. Bu anlamda bu metodu tanımak programcı açısından önemlidir. Örnek bir kullanım aşağıda 
	verilmiştir. Detaylar şu an önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bugün ve yarınki tahmini hava sıcaklığını giriniz:");
		int today = kb.nextInt();
		int tomorrow = kb.nextInt();
		
		System.out.printf("Bugün hava %d derece. Yarın %d derece olacak%n", today, tomorrow);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türden bir değeri decimal olarak formatlamak için d format karakteri kullanılır, hexadecimal olarak formatlamak
	için x (küçük veya büyük) format karakteri kullanılır, octal formatlamak için o format karakteri kullanılır. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%na = %x%na = %X%na = %o%n", a, a, a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerinin formatlanmasında % ile format karakteri arasına sıfır dışında pozitif bir sayı hizalama (alignment)
	anlamına gelir. Eğer sayının başına sıfır da yazılırsa basılacak karakterler hizalanacak sayıdan küçükse başına sıfır
	eklenir. Eğer sıfır yazılmazsa space karakteri eklenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %02d%na = %08X%n", a, a);
		System.out.printf("a = %2d%na = %8X%n", a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Gün, Ay ve Yıl bilgilerini giriniz:");
		int day = kb.nextInt();
		int month = kb.nextInt();
		int year = kb.nextInt();
		
		System.out.printf("%02d/%02d/%04d%n", day, month, year);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayıların formatlanmasında f format karakteri kullanılır. f format karakteri noktadan sonraki basamak sayısını
	default olarak belirli bir sayıda basamak kadar alır. Bu sayı doğrudan belirtilmemiş olsa da pek çok sistemde 6 dır.
	Geri kalan basamaklar bilimsel yuvarlama yöntemiyle yuvarlanır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayılarda noktadan sonra istenilen sayıda basamağın formatlanması için % ile f karakteri arasında . (nokta)
	ve negatif olmayan bir sayı yazılır. Bu durumda sayı o kadar sayıda basamak olarak formatlanmış olur. Geri kalan
	basamaklar yine yuvarlanarak atılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %.2f, b = %.2f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türünün için c format karakteri kullanılır. Bu durumda char türü içerisinde tutulan sayıya karşılık gelen
	karakter formatlanmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = 68;
		
		System.out.printf("c = %c%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	boolean türünün için b format karakteri kullanılır. Bu durumda boolean türüne ilişkin değerin (true veya false) yazısal
	karşılığı ile formatlama yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		boolean flag1 = true;
		boolean flag2 = false;
		
		System.out.printf("flag1 = %b, flag2 = %b%n", flag1, flag2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda kullanılan format karakteri geçilen argümanın türünden farklı ise bu durumda genel olarak exception 
	oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda s format karakteri ile her tür formatlanabilir. Tabii bu durumda türe özgü bazı formatlama biçimleri
	kullanılamaz. s format karakteri ile bu işlemin nasıl yapıldığı ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.printf("a = %s, b = %s%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu ile tamamen aynı işi yapan System.out.format isimli bir metot da vardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.format("a = %d, b = %.20f%n", a, b);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: printf (ve format) metodu için başka format karakterleri ve format karakterlerine özgü başka 
	detaylar da vardır. Bunlar zaman içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
